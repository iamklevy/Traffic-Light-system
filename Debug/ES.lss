
ES.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00007a2c  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         000000d4  00800060  00007a2c  00007ac0  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000479  00800134  00800134  00007b94  2**0
                  ALLOC
  3 .stab         00009834  00000000  00000000  00007b94  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      00004604  00000000  00000000  000113c8  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_aranges 00000140  00000000  00000000  000159cc  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_pubnames 00000170  00000000  00000000  00015b0c  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_info   00001c49  00000000  00000000  00015c7c  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_abbrev 00000eeb  00000000  00000000  000178c5  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_line   00000dad  00000000  00000000  000187b0  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_frame  00000160  00000000  00000000  00019560  2**2
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_str    0000028d  00000000  00000000  000196c0  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_loc    000007ce  00000000  00000000  0001994d  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_ranges 00000050  00000000  00000000  0001a11b  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 2a 00 	jmp	0x54	; 0x54 <__ctors_end>
       4:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
       8:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
       c:	0c 94 23 3c 	jmp	0x7846	; 0x7846 <__vector_3>
      10:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      14:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      18:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      1c:	0c 94 0b 2d 	jmp	0x5a16	; 0x5a16 <__vector_7>
      20:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      24:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      28:	0c 94 d1 05 	jmp	0xba2	; 0xba2 <__vector_10>
      2c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      30:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      34:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      38:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      3c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      40:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      44:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      48:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      4c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      50:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>

00000054 <__ctors_end>:
      54:	11 24       	eor	r1, r1
      56:	1f be       	out	0x3f, r1	; 63
      58:	cf e5       	ldi	r28, 0x5F	; 95
      5a:	d8 e0       	ldi	r29, 0x08	; 8
      5c:	de bf       	out	0x3e, r29	; 62
      5e:	cd bf       	out	0x3d, r28	; 61

00000060 <__do_copy_data>:
      60:	11 e0       	ldi	r17, 0x01	; 1
      62:	a0 e6       	ldi	r26, 0x60	; 96
      64:	b0 e0       	ldi	r27, 0x00	; 0
      66:	ec e2       	ldi	r30, 0x2C	; 44
      68:	fa e7       	ldi	r31, 0x7A	; 122
      6a:	02 c0       	rjmp	.+4      	; 0x70 <.do_copy_data_start>

0000006c <.do_copy_data_loop>:
      6c:	05 90       	lpm	r0, Z+
      6e:	0d 92       	st	X+, r0

00000070 <.do_copy_data_start>:
      70:	a4 33       	cpi	r26, 0x34	; 52
      72:	b1 07       	cpc	r27, r17
      74:	d9 f7       	brne	.-10     	; 0x6c <.do_copy_data_loop>

00000076 <__do_clear_bss>:
      76:	15 e0       	ldi	r17, 0x05	; 5
      78:	a4 e3       	ldi	r26, 0x34	; 52
      7a:	b1 e0       	ldi	r27, 0x01	; 1
      7c:	01 c0       	rjmp	.+2      	; 0x80 <.do_clear_bss_start>

0000007e <.do_clear_bss_loop>:
      7e:	1d 92       	st	X+, r1

00000080 <.do_clear_bss_start>:
      80:	ad 3a       	cpi	r26, 0xAD	; 173
      82:	b1 07       	cpc	r27, r17
      84:	e1 f7       	brne	.-8      	; 0x7e <.do_clear_bss_loop>
      86:	0e 94 99 38 	call	0x7132	; 0x7132 <main>
      8a:	0c 94 14 3d 	jmp	0x7a28	; 0x7a28 <_exit>

0000008e <__bad_interrupt>:
      8e:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000092 <__fixunssfsi>:
      92:	ef 92       	push	r14
      94:	ff 92       	push	r15
      96:	0f 93       	push	r16
      98:	1f 93       	push	r17
      9a:	7b 01       	movw	r14, r22
      9c:	8c 01       	movw	r16, r24
      9e:	20 e0       	ldi	r18, 0x00	; 0
      a0:	30 e0       	ldi	r19, 0x00	; 0
      a2:	40 e0       	ldi	r20, 0x00	; 0
      a4:	5f e4       	ldi	r21, 0x4F	; 79
      a6:	0e 94 49 03 	call	0x692	; 0x692 <__gesf2>
      aa:	88 23       	and	r24, r24
      ac:	8c f0       	brlt	.+34     	; 0xd0 <__fixunssfsi+0x3e>
      ae:	c8 01       	movw	r24, r16
      b0:	b7 01       	movw	r22, r14
      b2:	20 e0       	ldi	r18, 0x00	; 0
      b4:	30 e0       	ldi	r19, 0x00	; 0
      b6:	40 e0       	ldi	r20, 0x00	; 0
      b8:	5f e4       	ldi	r21, 0x4F	; 79
      ba:	0e 94 c1 01 	call	0x382	; 0x382 <__subsf3>
      be:	0e 94 a9 03 	call	0x752	; 0x752 <__fixsfsi>
      c2:	9b 01       	movw	r18, r22
      c4:	ac 01       	movw	r20, r24
      c6:	20 50       	subi	r18, 0x00	; 0
      c8:	30 40       	sbci	r19, 0x00	; 0
      ca:	40 40       	sbci	r20, 0x00	; 0
      cc:	50 48       	sbci	r21, 0x80	; 128
      ce:	06 c0       	rjmp	.+12     	; 0xdc <__fixunssfsi+0x4a>
      d0:	c8 01       	movw	r24, r16
      d2:	b7 01       	movw	r22, r14
      d4:	0e 94 a9 03 	call	0x752	; 0x752 <__fixsfsi>
      d8:	9b 01       	movw	r18, r22
      da:	ac 01       	movw	r20, r24
      dc:	b9 01       	movw	r22, r18
      de:	ca 01       	movw	r24, r20
      e0:	1f 91       	pop	r17
      e2:	0f 91       	pop	r16
      e4:	ff 90       	pop	r15
      e6:	ef 90       	pop	r14
      e8:	08 95       	ret

000000ea <_fpadd_parts>:
      ea:	a0 e0       	ldi	r26, 0x00	; 0
      ec:	b0 e0       	ldi	r27, 0x00	; 0
      ee:	eb e7       	ldi	r30, 0x7B	; 123
      f0:	f0 e0       	ldi	r31, 0x00	; 0
      f2:	0c 94 b5 3c 	jmp	0x796a	; 0x796a <__prologue_saves__>
      f6:	dc 01       	movw	r26, r24
      f8:	2b 01       	movw	r4, r22
      fa:	fa 01       	movw	r30, r20
      fc:	9c 91       	ld	r25, X
      fe:	92 30       	cpi	r25, 0x02	; 2
     100:	08 f4       	brcc	.+2      	; 0x104 <_fpadd_parts+0x1a>
     102:	39 c1       	rjmp	.+626    	; 0x376 <_fpadd_parts+0x28c>
     104:	eb 01       	movw	r28, r22
     106:	88 81       	ld	r24, Y
     108:	82 30       	cpi	r24, 0x02	; 2
     10a:	08 f4       	brcc	.+2      	; 0x10e <_fpadd_parts+0x24>
     10c:	33 c1       	rjmp	.+614    	; 0x374 <_fpadd_parts+0x28a>
     10e:	94 30       	cpi	r25, 0x04	; 4
     110:	69 f4       	brne	.+26     	; 0x12c <_fpadd_parts+0x42>
     112:	84 30       	cpi	r24, 0x04	; 4
     114:	09 f0       	breq	.+2      	; 0x118 <_fpadd_parts+0x2e>
     116:	2f c1       	rjmp	.+606    	; 0x376 <_fpadd_parts+0x28c>
     118:	11 96       	adiw	r26, 0x01	; 1
     11a:	9c 91       	ld	r25, X
     11c:	11 97       	sbiw	r26, 0x01	; 1
     11e:	89 81       	ldd	r24, Y+1	; 0x01
     120:	98 17       	cp	r25, r24
     122:	09 f4       	brne	.+2      	; 0x126 <_fpadd_parts+0x3c>
     124:	28 c1       	rjmp	.+592    	; 0x376 <_fpadd_parts+0x28c>
     126:	af ed       	ldi	r26, 0xDF	; 223
     128:	b0 e0       	ldi	r27, 0x00	; 0
     12a:	25 c1       	rjmp	.+586    	; 0x376 <_fpadd_parts+0x28c>
     12c:	84 30       	cpi	r24, 0x04	; 4
     12e:	09 f4       	brne	.+2      	; 0x132 <_fpadd_parts+0x48>
     130:	21 c1       	rjmp	.+578    	; 0x374 <_fpadd_parts+0x28a>
     132:	82 30       	cpi	r24, 0x02	; 2
     134:	a9 f4       	brne	.+42     	; 0x160 <_fpadd_parts+0x76>
     136:	92 30       	cpi	r25, 0x02	; 2
     138:	09 f0       	breq	.+2      	; 0x13c <_fpadd_parts+0x52>
     13a:	1d c1       	rjmp	.+570    	; 0x376 <_fpadd_parts+0x28c>
     13c:	9a 01       	movw	r18, r20
     13e:	ad 01       	movw	r20, r26
     140:	88 e0       	ldi	r24, 0x08	; 8
     142:	ea 01       	movw	r28, r20
     144:	09 90       	ld	r0, Y+
     146:	ae 01       	movw	r20, r28
     148:	e9 01       	movw	r28, r18
     14a:	09 92       	st	Y+, r0
     14c:	9e 01       	movw	r18, r28
     14e:	81 50       	subi	r24, 0x01	; 1
     150:	c1 f7       	brne	.-16     	; 0x142 <_fpadd_parts+0x58>
     152:	e2 01       	movw	r28, r4
     154:	89 81       	ldd	r24, Y+1	; 0x01
     156:	11 96       	adiw	r26, 0x01	; 1
     158:	9c 91       	ld	r25, X
     15a:	89 23       	and	r24, r25
     15c:	81 83       	std	Z+1, r24	; 0x01
     15e:	08 c1       	rjmp	.+528    	; 0x370 <_fpadd_parts+0x286>
     160:	92 30       	cpi	r25, 0x02	; 2
     162:	09 f4       	brne	.+2      	; 0x166 <_fpadd_parts+0x7c>
     164:	07 c1       	rjmp	.+526    	; 0x374 <_fpadd_parts+0x28a>
     166:	12 96       	adiw	r26, 0x02	; 2
     168:	2d 90       	ld	r2, X+
     16a:	3c 90       	ld	r3, X
     16c:	13 97       	sbiw	r26, 0x03	; 3
     16e:	eb 01       	movw	r28, r22
     170:	8a 81       	ldd	r24, Y+2	; 0x02
     172:	9b 81       	ldd	r25, Y+3	; 0x03
     174:	14 96       	adiw	r26, 0x04	; 4
     176:	ad 90       	ld	r10, X+
     178:	bd 90       	ld	r11, X+
     17a:	cd 90       	ld	r12, X+
     17c:	dc 90       	ld	r13, X
     17e:	17 97       	sbiw	r26, 0x07	; 7
     180:	ec 80       	ldd	r14, Y+4	; 0x04
     182:	fd 80       	ldd	r15, Y+5	; 0x05
     184:	0e 81       	ldd	r16, Y+6	; 0x06
     186:	1f 81       	ldd	r17, Y+7	; 0x07
     188:	91 01       	movw	r18, r2
     18a:	28 1b       	sub	r18, r24
     18c:	39 0b       	sbc	r19, r25
     18e:	b9 01       	movw	r22, r18
     190:	37 ff       	sbrs	r19, 7
     192:	04 c0       	rjmp	.+8      	; 0x19c <_fpadd_parts+0xb2>
     194:	66 27       	eor	r22, r22
     196:	77 27       	eor	r23, r23
     198:	62 1b       	sub	r22, r18
     19a:	73 0b       	sbc	r23, r19
     19c:	60 32       	cpi	r22, 0x20	; 32
     19e:	71 05       	cpc	r23, r1
     1a0:	0c f0       	brlt	.+2      	; 0x1a4 <_fpadd_parts+0xba>
     1a2:	61 c0       	rjmp	.+194    	; 0x266 <_fpadd_parts+0x17c>
     1a4:	12 16       	cp	r1, r18
     1a6:	13 06       	cpc	r1, r19
     1a8:	6c f5       	brge	.+90     	; 0x204 <_fpadd_parts+0x11a>
     1aa:	37 01       	movw	r6, r14
     1ac:	48 01       	movw	r8, r16
     1ae:	06 2e       	mov	r0, r22
     1b0:	04 c0       	rjmp	.+8      	; 0x1ba <_fpadd_parts+0xd0>
     1b2:	96 94       	lsr	r9
     1b4:	87 94       	ror	r8
     1b6:	77 94       	ror	r7
     1b8:	67 94       	ror	r6
     1ba:	0a 94       	dec	r0
     1bc:	d2 f7       	brpl	.-12     	; 0x1b2 <_fpadd_parts+0xc8>
     1be:	21 e0       	ldi	r18, 0x01	; 1
     1c0:	30 e0       	ldi	r19, 0x00	; 0
     1c2:	40 e0       	ldi	r20, 0x00	; 0
     1c4:	50 e0       	ldi	r21, 0x00	; 0
     1c6:	04 c0       	rjmp	.+8      	; 0x1d0 <_fpadd_parts+0xe6>
     1c8:	22 0f       	add	r18, r18
     1ca:	33 1f       	adc	r19, r19
     1cc:	44 1f       	adc	r20, r20
     1ce:	55 1f       	adc	r21, r21
     1d0:	6a 95       	dec	r22
     1d2:	d2 f7       	brpl	.-12     	; 0x1c8 <_fpadd_parts+0xde>
     1d4:	21 50       	subi	r18, 0x01	; 1
     1d6:	30 40       	sbci	r19, 0x00	; 0
     1d8:	40 40       	sbci	r20, 0x00	; 0
     1da:	50 40       	sbci	r21, 0x00	; 0
     1dc:	2e 21       	and	r18, r14
     1de:	3f 21       	and	r19, r15
     1e0:	40 23       	and	r20, r16
     1e2:	51 23       	and	r21, r17
     1e4:	21 15       	cp	r18, r1
     1e6:	31 05       	cpc	r19, r1
     1e8:	41 05       	cpc	r20, r1
     1ea:	51 05       	cpc	r21, r1
     1ec:	21 f0       	breq	.+8      	; 0x1f6 <_fpadd_parts+0x10c>
     1ee:	21 e0       	ldi	r18, 0x01	; 1
     1f0:	30 e0       	ldi	r19, 0x00	; 0
     1f2:	40 e0       	ldi	r20, 0x00	; 0
     1f4:	50 e0       	ldi	r21, 0x00	; 0
     1f6:	79 01       	movw	r14, r18
     1f8:	8a 01       	movw	r16, r20
     1fa:	e6 28       	or	r14, r6
     1fc:	f7 28       	or	r15, r7
     1fe:	08 29       	or	r16, r8
     200:	19 29       	or	r17, r9
     202:	3c c0       	rjmp	.+120    	; 0x27c <_fpadd_parts+0x192>
     204:	23 2b       	or	r18, r19
     206:	d1 f1       	breq	.+116    	; 0x27c <_fpadd_parts+0x192>
     208:	26 0e       	add	r2, r22
     20a:	37 1e       	adc	r3, r23
     20c:	35 01       	movw	r6, r10
     20e:	46 01       	movw	r8, r12
     210:	06 2e       	mov	r0, r22
     212:	04 c0       	rjmp	.+8      	; 0x21c <_fpadd_parts+0x132>
     214:	96 94       	lsr	r9
     216:	87 94       	ror	r8
     218:	77 94       	ror	r7
     21a:	67 94       	ror	r6
     21c:	0a 94       	dec	r0
     21e:	d2 f7       	brpl	.-12     	; 0x214 <_fpadd_parts+0x12a>
     220:	21 e0       	ldi	r18, 0x01	; 1
     222:	30 e0       	ldi	r19, 0x00	; 0
     224:	40 e0       	ldi	r20, 0x00	; 0
     226:	50 e0       	ldi	r21, 0x00	; 0
     228:	04 c0       	rjmp	.+8      	; 0x232 <_fpadd_parts+0x148>
     22a:	22 0f       	add	r18, r18
     22c:	33 1f       	adc	r19, r19
     22e:	44 1f       	adc	r20, r20
     230:	55 1f       	adc	r21, r21
     232:	6a 95       	dec	r22
     234:	d2 f7       	brpl	.-12     	; 0x22a <_fpadd_parts+0x140>
     236:	21 50       	subi	r18, 0x01	; 1
     238:	30 40       	sbci	r19, 0x00	; 0
     23a:	40 40       	sbci	r20, 0x00	; 0
     23c:	50 40       	sbci	r21, 0x00	; 0
     23e:	2a 21       	and	r18, r10
     240:	3b 21       	and	r19, r11
     242:	4c 21       	and	r20, r12
     244:	5d 21       	and	r21, r13
     246:	21 15       	cp	r18, r1
     248:	31 05       	cpc	r19, r1
     24a:	41 05       	cpc	r20, r1
     24c:	51 05       	cpc	r21, r1
     24e:	21 f0       	breq	.+8      	; 0x258 <_fpadd_parts+0x16e>
     250:	21 e0       	ldi	r18, 0x01	; 1
     252:	30 e0       	ldi	r19, 0x00	; 0
     254:	40 e0       	ldi	r20, 0x00	; 0
     256:	50 e0       	ldi	r21, 0x00	; 0
     258:	59 01       	movw	r10, r18
     25a:	6a 01       	movw	r12, r20
     25c:	a6 28       	or	r10, r6
     25e:	b7 28       	or	r11, r7
     260:	c8 28       	or	r12, r8
     262:	d9 28       	or	r13, r9
     264:	0b c0       	rjmp	.+22     	; 0x27c <_fpadd_parts+0x192>
     266:	82 15       	cp	r24, r2
     268:	93 05       	cpc	r25, r3
     26a:	2c f0       	brlt	.+10     	; 0x276 <_fpadd_parts+0x18c>
     26c:	1c 01       	movw	r2, r24
     26e:	aa 24       	eor	r10, r10
     270:	bb 24       	eor	r11, r11
     272:	65 01       	movw	r12, r10
     274:	03 c0       	rjmp	.+6      	; 0x27c <_fpadd_parts+0x192>
     276:	ee 24       	eor	r14, r14
     278:	ff 24       	eor	r15, r15
     27a:	87 01       	movw	r16, r14
     27c:	11 96       	adiw	r26, 0x01	; 1
     27e:	9c 91       	ld	r25, X
     280:	d2 01       	movw	r26, r4
     282:	11 96       	adiw	r26, 0x01	; 1
     284:	8c 91       	ld	r24, X
     286:	98 17       	cp	r25, r24
     288:	09 f4       	brne	.+2      	; 0x28c <_fpadd_parts+0x1a2>
     28a:	45 c0       	rjmp	.+138    	; 0x316 <_fpadd_parts+0x22c>
     28c:	99 23       	and	r25, r25
     28e:	39 f0       	breq	.+14     	; 0x29e <_fpadd_parts+0x1b4>
     290:	a8 01       	movw	r20, r16
     292:	97 01       	movw	r18, r14
     294:	2a 19       	sub	r18, r10
     296:	3b 09       	sbc	r19, r11
     298:	4c 09       	sbc	r20, r12
     29a:	5d 09       	sbc	r21, r13
     29c:	06 c0       	rjmp	.+12     	; 0x2aa <_fpadd_parts+0x1c0>
     29e:	a6 01       	movw	r20, r12
     2a0:	95 01       	movw	r18, r10
     2a2:	2e 19       	sub	r18, r14
     2a4:	3f 09       	sbc	r19, r15
     2a6:	40 0b       	sbc	r20, r16
     2a8:	51 0b       	sbc	r21, r17
     2aa:	57 fd       	sbrc	r21, 7
     2ac:	08 c0       	rjmp	.+16     	; 0x2be <_fpadd_parts+0x1d4>
     2ae:	11 82       	std	Z+1, r1	; 0x01
     2b0:	33 82       	std	Z+3, r3	; 0x03
     2b2:	22 82       	std	Z+2, r2	; 0x02
     2b4:	24 83       	std	Z+4, r18	; 0x04
     2b6:	35 83       	std	Z+5, r19	; 0x05
     2b8:	46 83       	std	Z+6, r20	; 0x06
     2ba:	57 83       	std	Z+7, r21	; 0x07
     2bc:	1d c0       	rjmp	.+58     	; 0x2f8 <_fpadd_parts+0x20e>
     2be:	81 e0       	ldi	r24, 0x01	; 1
     2c0:	81 83       	std	Z+1, r24	; 0x01
     2c2:	33 82       	std	Z+3, r3	; 0x03
     2c4:	22 82       	std	Z+2, r2	; 0x02
     2c6:	88 27       	eor	r24, r24
     2c8:	99 27       	eor	r25, r25
     2ca:	dc 01       	movw	r26, r24
     2cc:	82 1b       	sub	r24, r18
     2ce:	93 0b       	sbc	r25, r19
     2d0:	a4 0b       	sbc	r26, r20
     2d2:	b5 0b       	sbc	r27, r21
     2d4:	84 83       	std	Z+4, r24	; 0x04
     2d6:	95 83       	std	Z+5, r25	; 0x05
     2d8:	a6 83       	std	Z+6, r26	; 0x06
     2da:	b7 83       	std	Z+7, r27	; 0x07
     2dc:	0d c0       	rjmp	.+26     	; 0x2f8 <_fpadd_parts+0x20e>
     2de:	22 0f       	add	r18, r18
     2e0:	33 1f       	adc	r19, r19
     2e2:	44 1f       	adc	r20, r20
     2e4:	55 1f       	adc	r21, r21
     2e6:	24 83       	std	Z+4, r18	; 0x04
     2e8:	35 83       	std	Z+5, r19	; 0x05
     2ea:	46 83       	std	Z+6, r20	; 0x06
     2ec:	57 83       	std	Z+7, r21	; 0x07
     2ee:	82 81       	ldd	r24, Z+2	; 0x02
     2f0:	93 81       	ldd	r25, Z+3	; 0x03
     2f2:	01 97       	sbiw	r24, 0x01	; 1
     2f4:	93 83       	std	Z+3, r25	; 0x03
     2f6:	82 83       	std	Z+2, r24	; 0x02
     2f8:	24 81       	ldd	r18, Z+4	; 0x04
     2fa:	35 81       	ldd	r19, Z+5	; 0x05
     2fc:	46 81       	ldd	r20, Z+6	; 0x06
     2fe:	57 81       	ldd	r21, Z+7	; 0x07
     300:	da 01       	movw	r26, r20
     302:	c9 01       	movw	r24, r18
     304:	01 97       	sbiw	r24, 0x01	; 1
     306:	a1 09       	sbc	r26, r1
     308:	b1 09       	sbc	r27, r1
     30a:	8f 5f       	subi	r24, 0xFF	; 255
     30c:	9f 4f       	sbci	r25, 0xFF	; 255
     30e:	af 4f       	sbci	r26, 0xFF	; 255
     310:	bf 43       	sbci	r27, 0x3F	; 63
     312:	28 f3       	brcs	.-54     	; 0x2de <_fpadd_parts+0x1f4>
     314:	0b c0       	rjmp	.+22     	; 0x32c <_fpadd_parts+0x242>
     316:	91 83       	std	Z+1, r25	; 0x01
     318:	33 82       	std	Z+3, r3	; 0x03
     31a:	22 82       	std	Z+2, r2	; 0x02
     31c:	ea 0c       	add	r14, r10
     31e:	fb 1c       	adc	r15, r11
     320:	0c 1d       	adc	r16, r12
     322:	1d 1d       	adc	r17, r13
     324:	e4 82       	std	Z+4, r14	; 0x04
     326:	f5 82       	std	Z+5, r15	; 0x05
     328:	06 83       	std	Z+6, r16	; 0x06
     32a:	17 83       	std	Z+7, r17	; 0x07
     32c:	83 e0       	ldi	r24, 0x03	; 3
     32e:	80 83       	st	Z, r24
     330:	24 81       	ldd	r18, Z+4	; 0x04
     332:	35 81       	ldd	r19, Z+5	; 0x05
     334:	46 81       	ldd	r20, Z+6	; 0x06
     336:	57 81       	ldd	r21, Z+7	; 0x07
     338:	57 ff       	sbrs	r21, 7
     33a:	1a c0       	rjmp	.+52     	; 0x370 <_fpadd_parts+0x286>
     33c:	c9 01       	movw	r24, r18
     33e:	aa 27       	eor	r26, r26
     340:	97 fd       	sbrc	r25, 7
     342:	a0 95       	com	r26
     344:	ba 2f       	mov	r27, r26
     346:	81 70       	andi	r24, 0x01	; 1
     348:	90 70       	andi	r25, 0x00	; 0
     34a:	a0 70       	andi	r26, 0x00	; 0
     34c:	b0 70       	andi	r27, 0x00	; 0
     34e:	56 95       	lsr	r21
     350:	47 95       	ror	r20
     352:	37 95       	ror	r19
     354:	27 95       	ror	r18
     356:	82 2b       	or	r24, r18
     358:	93 2b       	or	r25, r19
     35a:	a4 2b       	or	r26, r20
     35c:	b5 2b       	or	r27, r21
     35e:	84 83       	std	Z+4, r24	; 0x04
     360:	95 83       	std	Z+5, r25	; 0x05
     362:	a6 83       	std	Z+6, r26	; 0x06
     364:	b7 83       	std	Z+7, r27	; 0x07
     366:	82 81       	ldd	r24, Z+2	; 0x02
     368:	93 81       	ldd	r25, Z+3	; 0x03
     36a:	01 96       	adiw	r24, 0x01	; 1
     36c:	93 83       	std	Z+3, r25	; 0x03
     36e:	82 83       	std	Z+2, r24	; 0x02
     370:	df 01       	movw	r26, r30
     372:	01 c0       	rjmp	.+2      	; 0x376 <_fpadd_parts+0x28c>
     374:	d2 01       	movw	r26, r4
     376:	cd 01       	movw	r24, r26
     378:	cd b7       	in	r28, 0x3d	; 61
     37a:	de b7       	in	r29, 0x3e	; 62
     37c:	e2 e1       	ldi	r30, 0x12	; 18
     37e:	0c 94 d1 3c 	jmp	0x79a2	; 0x79a2 <__epilogue_restores__>

00000382 <__subsf3>:
     382:	a0 e2       	ldi	r26, 0x20	; 32
     384:	b0 e0       	ldi	r27, 0x00	; 0
     386:	e7 ec       	ldi	r30, 0xC7	; 199
     388:	f1 e0       	ldi	r31, 0x01	; 1
     38a:	0c 94 c1 3c 	jmp	0x7982	; 0x7982 <__prologue_saves__+0x18>
     38e:	69 83       	std	Y+1, r22	; 0x01
     390:	7a 83       	std	Y+2, r23	; 0x02
     392:	8b 83       	std	Y+3, r24	; 0x03
     394:	9c 83       	std	Y+4, r25	; 0x04
     396:	2d 83       	std	Y+5, r18	; 0x05
     398:	3e 83       	std	Y+6, r19	; 0x06
     39a:	4f 83       	std	Y+7, r20	; 0x07
     39c:	58 87       	std	Y+8, r21	; 0x08
     39e:	e9 e0       	ldi	r30, 0x09	; 9
     3a0:	ee 2e       	mov	r14, r30
     3a2:	f1 2c       	mov	r15, r1
     3a4:	ec 0e       	add	r14, r28
     3a6:	fd 1e       	adc	r15, r29
     3a8:	ce 01       	movw	r24, r28
     3aa:	01 96       	adiw	r24, 0x01	; 1
     3ac:	b7 01       	movw	r22, r14
     3ae:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     3b2:	8e 01       	movw	r16, r28
     3b4:	0f 5e       	subi	r16, 0xEF	; 239
     3b6:	1f 4f       	sbci	r17, 0xFF	; 255
     3b8:	ce 01       	movw	r24, r28
     3ba:	05 96       	adiw	r24, 0x05	; 5
     3bc:	b8 01       	movw	r22, r16
     3be:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     3c2:	8a 89       	ldd	r24, Y+18	; 0x12
     3c4:	91 e0       	ldi	r25, 0x01	; 1
     3c6:	89 27       	eor	r24, r25
     3c8:	8a 8b       	std	Y+18, r24	; 0x12
     3ca:	c7 01       	movw	r24, r14
     3cc:	b8 01       	movw	r22, r16
     3ce:	ae 01       	movw	r20, r28
     3d0:	47 5e       	subi	r20, 0xE7	; 231
     3d2:	5f 4f       	sbci	r21, 0xFF	; 255
     3d4:	0e 94 75 00 	call	0xea	; 0xea <_fpadd_parts>
     3d8:	0e 94 fd 03 	call	0x7fa	; 0x7fa <__pack_f>
     3dc:	a0 96       	adiw	r28, 0x20	; 32
     3de:	e6 e0       	ldi	r30, 0x06	; 6
     3e0:	0c 94 dd 3c 	jmp	0x79ba	; 0x79ba <__epilogue_restores__+0x18>

000003e4 <__addsf3>:
     3e4:	a0 e2       	ldi	r26, 0x20	; 32
     3e6:	b0 e0       	ldi	r27, 0x00	; 0
     3e8:	e8 ef       	ldi	r30, 0xF8	; 248
     3ea:	f1 e0       	ldi	r31, 0x01	; 1
     3ec:	0c 94 c1 3c 	jmp	0x7982	; 0x7982 <__prologue_saves__+0x18>
     3f0:	69 83       	std	Y+1, r22	; 0x01
     3f2:	7a 83       	std	Y+2, r23	; 0x02
     3f4:	8b 83       	std	Y+3, r24	; 0x03
     3f6:	9c 83       	std	Y+4, r25	; 0x04
     3f8:	2d 83       	std	Y+5, r18	; 0x05
     3fa:	3e 83       	std	Y+6, r19	; 0x06
     3fc:	4f 83       	std	Y+7, r20	; 0x07
     3fe:	58 87       	std	Y+8, r21	; 0x08
     400:	f9 e0       	ldi	r31, 0x09	; 9
     402:	ef 2e       	mov	r14, r31
     404:	f1 2c       	mov	r15, r1
     406:	ec 0e       	add	r14, r28
     408:	fd 1e       	adc	r15, r29
     40a:	ce 01       	movw	r24, r28
     40c:	01 96       	adiw	r24, 0x01	; 1
     40e:	b7 01       	movw	r22, r14
     410:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     414:	8e 01       	movw	r16, r28
     416:	0f 5e       	subi	r16, 0xEF	; 239
     418:	1f 4f       	sbci	r17, 0xFF	; 255
     41a:	ce 01       	movw	r24, r28
     41c:	05 96       	adiw	r24, 0x05	; 5
     41e:	b8 01       	movw	r22, r16
     420:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     424:	c7 01       	movw	r24, r14
     426:	b8 01       	movw	r22, r16
     428:	ae 01       	movw	r20, r28
     42a:	47 5e       	subi	r20, 0xE7	; 231
     42c:	5f 4f       	sbci	r21, 0xFF	; 255
     42e:	0e 94 75 00 	call	0xea	; 0xea <_fpadd_parts>
     432:	0e 94 fd 03 	call	0x7fa	; 0x7fa <__pack_f>
     436:	a0 96       	adiw	r28, 0x20	; 32
     438:	e6 e0       	ldi	r30, 0x06	; 6
     43a:	0c 94 dd 3c 	jmp	0x79ba	; 0x79ba <__epilogue_restores__+0x18>

0000043e <__mulsf3>:
     43e:	a0 e2       	ldi	r26, 0x20	; 32
     440:	b0 e0       	ldi	r27, 0x00	; 0
     442:	e5 e2       	ldi	r30, 0x25	; 37
     444:	f2 e0       	ldi	r31, 0x02	; 2
     446:	0c 94 b5 3c 	jmp	0x796a	; 0x796a <__prologue_saves__>
     44a:	69 83       	std	Y+1, r22	; 0x01
     44c:	7a 83       	std	Y+2, r23	; 0x02
     44e:	8b 83       	std	Y+3, r24	; 0x03
     450:	9c 83       	std	Y+4, r25	; 0x04
     452:	2d 83       	std	Y+5, r18	; 0x05
     454:	3e 83       	std	Y+6, r19	; 0x06
     456:	4f 83       	std	Y+7, r20	; 0x07
     458:	58 87       	std	Y+8, r21	; 0x08
     45a:	ce 01       	movw	r24, r28
     45c:	01 96       	adiw	r24, 0x01	; 1
     45e:	be 01       	movw	r22, r28
     460:	67 5f       	subi	r22, 0xF7	; 247
     462:	7f 4f       	sbci	r23, 0xFF	; 255
     464:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     468:	ce 01       	movw	r24, r28
     46a:	05 96       	adiw	r24, 0x05	; 5
     46c:	be 01       	movw	r22, r28
     46e:	6f 5e       	subi	r22, 0xEF	; 239
     470:	7f 4f       	sbci	r23, 0xFF	; 255
     472:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     476:	99 85       	ldd	r25, Y+9	; 0x09
     478:	92 30       	cpi	r25, 0x02	; 2
     47a:	88 f0       	brcs	.+34     	; 0x49e <__mulsf3+0x60>
     47c:	89 89       	ldd	r24, Y+17	; 0x11
     47e:	82 30       	cpi	r24, 0x02	; 2
     480:	c8 f0       	brcs	.+50     	; 0x4b4 <__mulsf3+0x76>
     482:	94 30       	cpi	r25, 0x04	; 4
     484:	19 f4       	brne	.+6      	; 0x48c <__mulsf3+0x4e>
     486:	82 30       	cpi	r24, 0x02	; 2
     488:	51 f4       	brne	.+20     	; 0x49e <__mulsf3+0x60>
     48a:	04 c0       	rjmp	.+8      	; 0x494 <__mulsf3+0x56>
     48c:	84 30       	cpi	r24, 0x04	; 4
     48e:	29 f4       	brne	.+10     	; 0x49a <__mulsf3+0x5c>
     490:	92 30       	cpi	r25, 0x02	; 2
     492:	81 f4       	brne	.+32     	; 0x4b4 <__mulsf3+0x76>
     494:	8f ed       	ldi	r24, 0xDF	; 223
     496:	90 e0       	ldi	r25, 0x00	; 0
     498:	c6 c0       	rjmp	.+396    	; 0x626 <__mulsf3+0x1e8>
     49a:	92 30       	cpi	r25, 0x02	; 2
     49c:	49 f4       	brne	.+18     	; 0x4b0 <__mulsf3+0x72>
     49e:	20 e0       	ldi	r18, 0x00	; 0
     4a0:	9a 85       	ldd	r25, Y+10	; 0x0a
     4a2:	8a 89       	ldd	r24, Y+18	; 0x12
     4a4:	98 13       	cpse	r25, r24
     4a6:	21 e0       	ldi	r18, 0x01	; 1
     4a8:	2a 87       	std	Y+10, r18	; 0x0a
     4aa:	ce 01       	movw	r24, r28
     4ac:	09 96       	adiw	r24, 0x09	; 9
     4ae:	bb c0       	rjmp	.+374    	; 0x626 <__mulsf3+0x1e8>
     4b0:	82 30       	cpi	r24, 0x02	; 2
     4b2:	49 f4       	brne	.+18     	; 0x4c6 <__mulsf3+0x88>
     4b4:	20 e0       	ldi	r18, 0x00	; 0
     4b6:	9a 85       	ldd	r25, Y+10	; 0x0a
     4b8:	8a 89       	ldd	r24, Y+18	; 0x12
     4ba:	98 13       	cpse	r25, r24
     4bc:	21 e0       	ldi	r18, 0x01	; 1
     4be:	2a 8b       	std	Y+18, r18	; 0x12
     4c0:	ce 01       	movw	r24, r28
     4c2:	41 96       	adiw	r24, 0x11	; 17
     4c4:	b0 c0       	rjmp	.+352    	; 0x626 <__mulsf3+0x1e8>
     4c6:	2d 84       	ldd	r2, Y+13	; 0x0d
     4c8:	3e 84       	ldd	r3, Y+14	; 0x0e
     4ca:	4f 84       	ldd	r4, Y+15	; 0x0f
     4cc:	58 88       	ldd	r5, Y+16	; 0x10
     4ce:	6d 88       	ldd	r6, Y+21	; 0x15
     4d0:	7e 88       	ldd	r7, Y+22	; 0x16
     4d2:	8f 88       	ldd	r8, Y+23	; 0x17
     4d4:	98 8c       	ldd	r9, Y+24	; 0x18
     4d6:	ee 24       	eor	r14, r14
     4d8:	ff 24       	eor	r15, r15
     4da:	87 01       	movw	r16, r14
     4dc:	aa 24       	eor	r10, r10
     4de:	bb 24       	eor	r11, r11
     4e0:	65 01       	movw	r12, r10
     4e2:	40 e0       	ldi	r20, 0x00	; 0
     4e4:	50 e0       	ldi	r21, 0x00	; 0
     4e6:	60 e0       	ldi	r22, 0x00	; 0
     4e8:	70 e0       	ldi	r23, 0x00	; 0
     4ea:	e0 e0       	ldi	r30, 0x00	; 0
     4ec:	f0 e0       	ldi	r31, 0x00	; 0
     4ee:	c1 01       	movw	r24, r2
     4f0:	81 70       	andi	r24, 0x01	; 1
     4f2:	90 70       	andi	r25, 0x00	; 0
     4f4:	89 2b       	or	r24, r25
     4f6:	e9 f0       	breq	.+58     	; 0x532 <__mulsf3+0xf4>
     4f8:	e6 0c       	add	r14, r6
     4fa:	f7 1c       	adc	r15, r7
     4fc:	08 1d       	adc	r16, r8
     4fe:	19 1d       	adc	r17, r9
     500:	9a 01       	movw	r18, r20
     502:	ab 01       	movw	r20, r22
     504:	2a 0d       	add	r18, r10
     506:	3b 1d       	adc	r19, r11
     508:	4c 1d       	adc	r20, r12
     50a:	5d 1d       	adc	r21, r13
     50c:	80 e0       	ldi	r24, 0x00	; 0
     50e:	90 e0       	ldi	r25, 0x00	; 0
     510:	a0 e0       	ldi	r26, 0x00	; 0
     512:	b0 e0       	ldi	r27, 0x00	; 0
     514:	e6 14       	cp	r14, r6
     516:	f7 04       	cpc	r15, r7
     518:	08 05       	cpc	r16, r8
     51a:	19 05       	cpc	r17, r9
     51c:	20 f4       	brcc	.+8      	; 0x526 <__mulsf3+0xe8>
     51e:	81 e0       	ldi	r24, 0x01	; 1
     520:	90 e0       	ldi	r25, 0x00	; 0
     522:	a0 e0       	ldi	r26, 0x00	; 0
     524:	b0 e0       	ldi	r27, 0x00	; 0
     526:	ba 01       	movw	r22, r20
     528:	a9 01       	movw	r20, r18
     52a:	48 0f       	add	r20, r24
     52c:	59 1f       	adc	r21, r25
     52e:	6a 1f       	adc	r22, r26
     530:	7b 1f       	adc	r23, r27
     532:	aa 0c       	add	r10, r10
     534:	bb 1c       	adc	r11, r11
     536:	cc 1c       	adc	r12, r12
     538:	dd 1c       	adc	r13, r13
     53a:	97 fe       	sbrs	r9, 7
     53c:	08 c0       	rjmp	.+16     	; 0x54e <__mulsf3+0x110>
     53e:	81 e0       	ldi	r24, 0x01	; 1
     540:	90 e0       	ldi	r25, 0x00	; 0
     542:	a0 e0       	ldi	r26, 0x00	; 0
     544:	b0 e0       	ldi	r27, 0x00	; 0
     546:	a8 2a       	or	r10, r24
     548:	b9 2a       	or	r11, r25
     54a:	ca 2a       	or	r12, r26
     54c:	db 2a       	or	r13, r27
     54e:	31 96       	adiw	r30, 0x01	; 1
     550:	e0 32       	cpi	r30, 0x20	; 32
     552:	f1 05       	cpc	r31, r1
     554:	49 f0       	breq	.+18     	; 0x568 <__mulsf3+0x12a>
     556:	66 0c       	add	r6, r6
     558:	77 1c       	adc	r7, r7
     55a:	88 1c       	adc	r8, r8
     55c:	99 1c       	adc	r9, r9
     55e:	56 94       	lsr	r5
     560:	47 94       	ror	r4
     562:	37 94       	ror	r3
     564:	27 94       	ror	r2
     566:	c3 cf       	rjmp	.-122    	; 0x4ee <__mulsf3+0xb0>
     568:	fa 85       	ldd	r31, Y+10	; 0x0a
     56a:	ea 89       	ldd	r30, Y+18	; 0x12
     56c:	2b 89       	ldd	r18, Y+19	; 0x13
     56e:	3c 89       	ldd	r19, Y+20	; 0x14
     570:	8b 85       	ldd	r24, Y+11	; 0x0b
     572:	9c 85       	ldd	r25, Y+12	; 0x0c
     574:	28 0f       	add	r18, r24
     576:	39 1f       	adc	r19, r25
     578:	2e 5f       	subi	r18, 0xFE	; 254
     57a:	3f 4f       	sbci	r19, 0xFF	; 255
     57c:	17 c0       	rjmp	.+46     	; 0x5ac <__mulsf3+0x16e>
     57e:	ca 01       	movw	r24, r20
     580:	81 70       	andi	r24, 0x01	; 1
     582:	90 70       	andi	r25, 0x00	; 0
     584:	89 2b       	or	r24, r25
     586:	61 f0       	breq	.+24     	; 0x5a0 <__mulsf3+0x162>
     588:	16 95       	lsr	r17
     58a:	07 95       	ror	r16
     58c:	f7 94       	ror	r15
     58e:	e7 94       	ror	r14
     590:	80 e0       	ldi	r24, 0x00	; 0
     592:	90 e0       	ldi	r25, 0x00	; 0
     594:	a0 e0       	ldi	r26, 0x00	; 0
     596:	b0 e8       	ldi	r27, 0x80	; 128
     598:	e8 2a       	or	r14, r24
     59a:	f9 2a       	or	r15, r25
     59c:	0a 2b       	or	r16, r26
     59e:	1b 2b       	or	r17, r27
     5a0:	76 95       	lsr	r23
     5a2:	67 95       	ror	r22
     5a4:	57 95       	ror	r21
     5a6:	47 95       	ror	r20
     5a8:	2f 5f       	subi	r18, 0xFF	; 255
     5aa:	3f 4f       	sbci	r19, 0xFF	; 255
     5ac:	77 fd       	sbrc	r23, 7
     5ae:	e7 cf       	rjmp	.-50     	; 0x57e <__mulsf3+0x140>
     5b0:	0c c0       	rjmp	.+24     	; 0x5ca <__mulsf3+0x18c>
     5b2:	44 0f       	add	r20, r20
     5b4:	55 1f       	adc	r21, r21
     5b6:	66 1f       	adc	r22, r22
     5b8:	77 1f       	adc	r23, r23
     5ba:	17 fd       	sbrc	r17, 7
     5bc:	41 60       	ori	r20, 0x01	; 1
     5be:	ee 0c       	add	r14, r14
     5c0:	ff 1c       	adc	r15, r15
     5c2:	00 1f       	adc	r16, r16
     5c4:	11 1f       	adc	r17, r17
     5c6:	21 50       	subi	r18, 0x01	; 1
     5c8:	30 40       	sbci	r19, 0x00	; 0
     5ca:	40 30       	cpi	r20, 0x00	; 0
     5cc:	90 e0       	ldi	r25, 0x00	; 0
     5ce:	59 07       	cpc	r21, r25
     5d0:	90 e0       	ldi	r25, 0x00	; 0
     5d2:	69 07       	cpc	r22, r25
     5d4:	90 e4       	ldi	r25, 0x40	; 64
     5d6:	79 07       	cpc	r23, r25
     5d8:	60 f3       	brcs	.-40     	; 0x5b2 <__mulsf3+0x174>
     5da:	2b 8f       	std	Y+27, r18	; 0x1b
     5dc:	3c 8f       	std	Y+28, r19	; 0x1c
     5de:	db 01       	movw	r26, r22
     5e0:	ca 01       	movw	r24, r20
     5e2:	8f 77       	andi	r24, 0x7F	; 127
     5e4:	90 70       	andi	r25, 0x00	; 0
     5e6:	a0 70       	andi	r26, 0x00	; 0
     5e8:	b0 70       	andi	r27, 0x00	; 0
     5ea:	80 34       	cpi	r24, 0x40	; 64
     5ec:	91 05       	cpc	r25, r1
     5ee:	a1 05       	cpc	r26, r1
     5f0:	b1 05       	cpc	r27, r1
     5f2:	61 f4       	brne	.+24     	; 0x60c <__mulsf3+0x1ce>
     5f4:	47 fd       	sbrc	r20, 7
     5f6:	0a c0       	rjmp	.+20     	; 0x60c <__mulsf3+0x1ce>
     5f8:	e1 14       	cp	r14, r1
     5fa:	f1 04       	cpc	r15, r1
     5fc:	01 05       	cpc	r16, r1
     5fe:	11 05       	cpc	r17, r1
     600:	29 f0       	breq	.+10     	; 0x60c <__mulsf3+0x1ce>
     602:	40 5c       	subi	r20, 0xC0	; 192
     604:	5f 4f       	sbci	r21, 0xFF	; 255
     606:	6f 4f       	sbci	r22, 0xFF	; 255
     608:	7f 4f       	sbci	r23, 0xFF	; 255
     60a:	40 78       	andi	r20, 0x80	; 128
     60c:	1a 8e       	std	Y+26, r1	; 0x1a
     60e:	fe 17       	cp	r31, r30
     610:	11 f0       	breq	.+4      	; 0x616 <__mulsf3+0x1d8>
     612:	81 e0       	ldi	r24, 0x01	; 1
     614:	8a 8f       	std	Y+26, r24	; 0x1a
     616:	4d 8f       	std	Y+29, r20	; 0x1d
     618:	5e 8f       	std	Y+30, r21	; 0x1e
     61a:	6f 8f       	std	Y+31, r22	; 0x1f
     61c:	78 a3       	std	Y+32, r23	; 0x20
     61e:	83 e0       	ldi	r24, 0x03	; 3
     620:	89 8f       	std	Y+25, r24	; 0x19
     622:	ce 01       	movw	r24, r28
     624:	49 96       	adiw	r24, 0x19	; 25
     626:	0e 94 fd 03 	call	0x7fa	; 0x7fa <__pack_f>
     62a:	a0 96       	adiw	r28, 0x20	; 32
     62c:	e2 e1       	ldi	r30, 0x12	; 18
     62e:	0c 94 d1 3c 	jmp	0x79a2	; 0x79a2 <__epilogue_restores__>

00000632 <__gtsf2>:
     632:	a8 e1       	ldi	r26, 0x18	; 24
     634:	b0 e0       	ldi	r27, 0x00	; 0
     636:	ef e1       	ldi	r30, 0x1F	; 31
     638:	f3 e0       	ldi	r31, 0x03	; 3
     63a:	0c 94 c1 3c 	jmp	0x7982	; 0x7982 <__prologue_saves__+0x18>
     63e:	69 83       	std	Y+1, r22	; 0x01
     640:	7a 83       	std	Y+2, r23	; 0x02
     642:	8b 83       	std	Y+3, r24	; 0x03
     644:	9c 83       	std	Y+4, r25	; 0x04
     646:	2d 83       	std	Y+5, r18	; 0x05
     648:	3e 83       	std	Y+6, r19	; 0x06
     64a:	4f 83       	std	Y+7, r20	; 0x07
     64c:	58 87       	std	Y+8, r21	; 0x08
     64e:	89 e0       	ldi	r24, 0x09	; 9
     650:	e8 2e       	mov	r14, r24
     652:	f1 2c       	mov	r15, r1
     654:	ec 0e       	add	r14, r28
     656:	fd 1e       	adc	r15, r29
     658:	ce 01       	movw	r24, r28
     65a:	01 96       	adiw	r24, 0x01	; 1
     65c:	b7 01       	movw	r22, r14
     65e:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     662:	8e 01       	movw	r16, r28
     664:	0f 5e       	subi	r16, 0xEF	; 239
     666:	1f 4f       	sbci	r17, 0xFF	; 255
     668:	ce 01       	movw	r24, r28
     66a:	05 96       	adiw	r24, 0x05	; 5
     66c:	b8 01       	movw	r22, r16
     66e:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     672:	89 85       	ldd	r24, Y+9	; 0x09
     674:	82 30       	cpi	r24, 0x02	; 2
     676:	40 f0       	brcs	.+16     	; 0x688 <__gtsf2+0x56>
     678:	89 89       	ldd	r24, Y+17	; 0x11
     67a:	82 30       	cpi	r24, 0x02	; 2
     67c:	28 f0       	brcs	.+10     	; 0x688 <__gtsf2+0x56>
     67e:	c7 01       	movw	r24, r14
     680:	b8 01       	movw	r22, r16
     682:	0e 94 4a 05 	call	0xa94	; 0xa94 <__fpcmp_parts_f>
     686:	01 c0       	rjmp	.+2      	; 0x68a <__gtsf2+0x58>
     688:	8f ef       	ldi	r24, 0xFF	; 255
     68a:	68 96       	adiw	r28, 0x18	; 24
     68c:	e6 e0       	ldi	r30, 0x06	; 6
     68e:	0c 94 dd 3c 	jmp	0x79ba	; 0x79ba <__epilogue_restores__+0x18>

00000692 <__gesf2>:
     692:	a8 e1       	ldi	r26, 0x18	; 24
     694:	b0 e0       	ldi	r27, 0x00	; 0
     696:	ef e4       	ldi	r30, 0x4F	; 79
     698:	f3 e0       	ldi	r31, 0x03	; 3
     69a:	0c 94 c1 3c 	jmp	0x7982	; 0x7982 <__prologue_saves__+0x18>
     69e:	69 83       	std	Y+1, r22	; 0x01
     6a0:	7a 83       	std	Y+2, r23	; 0x02
     6a2:	8b 83       	std	Y+3, r24	; 0x03
     6a4:	9c 83       	std	Y+4, r25	; 0x04
     6a6:	2d 83       	std	Y+5, r18	; 0x05
     6a8:	3e 83       	std	Y+6, r19	; 0x06
     6aa:	4f 83       	std	Y+7, r20	; 0x07
     6ac:	58 87       	std	Y+8, r21	; 0x08
     6ae:	89 e0       	ldi	r24, 0x09	; 9
     6b0:	e8 2e       	mov	r14, r24
     6b2:	f1 2c       	mov	r15, r1
     6b4:	ec 0e       	add	r14, r28
     6b6:	fd 1e       	adc	r15, r29
     6b8:	ce 01       	movw	r24, r28
     6ba:	01 96       	adiw	r24, 0x01	; 1
     6bc:	b7 01       	movw	r22, r14
     6be:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     6c2:	8e 01       	movw	r16, r28
     6c4:	0f 5e       	subi	r16, 0xEF	; 239
     6c6:	1f 4f       	sbci	r17, 0xFF	; 255
     6c8:	ce 01       	movw	r24, r28
     6ca:	05 96       	adiw	r24, 0x05	; 5
     6cc:	b8 01       	movw	r22, r16
     6ce:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     6d2:	89 85       	ldd	r24, Y+9	; 0x09
     6d4:	82 30       	cpi	r24, 0x02	; 2
     6d6:	40 f0       	brcs	.+16     	; 0x6e8 <__gesf2+0x56>
     6d8:	89 89       	ldd	r24, Y+17	; 0x11
     6da:	82 30       	cpi	r24, 0x02	; 2
     6dc:	28 f0       	brcs	.+10     	; 0x6e8 <__gesf2+0x56>
     6de:	c7 01       	movw	r24, r14
     6e0:	b8 01       	movw	r22, r16
     6e2:	0e 94 4a 05 	call	0xa94	; 0xa94 <__fpcmp_parts_f>
     6e6:	01 c0       	rjmp	.+2      	; 0x6ea <__gesf2+0x58>
     6e8:	8f ef       	ldi	r24, 0xFF	; 255
     6ea:	68 96       	adiw	r28, 0x18	; 24
     6ec:	e6 e0       	ldi	r30, 0x06	; 6
     6ee:	0c 94 dd 3c 	jmp	0x79ba	; 0x79ba <__epilogue_restores__+0x18>

000006f2 <__ltsf2>:
     6f2:	a8 e1       	ldi	r26, 0x18	; 24
     6f4:	b0 e0       	ldi	r27, 0x00	; 0
     6f6:	ef e7       	ldi	r30, 0x7F	; 127
     6f8:	f3 e0       	ldi	r31, 0x03	; 3
     6fa:	0c 94 c1 3c 	jmp	0x7982	; 0x7982 <__prologue_saves__+0x18>
     6fe:	69 83       	std	Y+1, r22	; 0x01
     700:	7a 83       	std	Y+2, r23	; 0x02
     702:	8b 83       	std	Y+3, r24	; 0x03
     704:	9c 83       	std	Y+4, r25	; 0x04
     706:	2d 83       	std	Y+5, r18	; 0x05
     708:	3e 83       	std	Y+6, r19	; 0x06
     70a:	4f 83       	std	Y+7, r20	; 0x07
     70c:	58 87       	std	Y+8, r21	; 0x08
     70e:	89 e0       	ldi	r24, 0x09	; 9
     710:	e8 2e       	mov	r14, r24
     712:	f1 2c       	mov	r15, r1
     714:	ec 0e       	add	r14, r28
     716:	fd 1e       	adc	r15, r29
     718:	ce 01       	movw	r24, r28
     71a:	01 96       	adiw	r24, 0x01	; 1
     71c:	b7 01       	movw	r22, r14
     71e:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     722:	8e 01       	movw	r16, r28
     724:	0f 5e       	subi	r16, 0xEF	; 239
     726:	1f 4f       	sbci	r17, 0xFF	; 255
     728:	ce 01       	movw	r24, r28
     72a:	05 96       	adiw	r24, 0x05	; 5
     72c:	b8 01       	movw	r22, r16
     72e:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     732:	89 85       	ldd	r24, Y+9	; 0x09
     734:	82 30       	cpi	r24, 0x02	; 2
     736:	40 f0       	brcs	.+16     	; 0x748 <__ltsf2+0x56>
     738:	89 89       	ldd	r24, Y+17	; 0x11
     73a:	82 30       	cpi	r24, 0x02	; 2
     73c:	28 f0       	brcs	.+10     	; 0x748 <__ltsf2+0x56>
     73e:	c7 01       	movw	r24, r14
     740:	b8 01       	movw	r22, r16
     742:	0e 94 4a 05 	call	0xa94	; 0xa94 <__fpcmp_parts_f>
     746:	01 c0       	rjmp	.+2      	; 0x74a <__ltsf2+0x58>
     748:	81 e0       	ldi	r24, 0x01	; 1
     74a:	68 96       	adiw	r28, 0x18	; 24
     74c:	e6 e0       	ldi	r30, 0x06	; 6
     74e:	0c 94 dd 3c 	jmp	0x79ba	; 0x79ba <__epilogue_restores__+0x18>

00000752 <__fixsfsi>:
     752:	ac e0       	ldi	r26, 0x0C	; 12
     754:	b0 e0       	ldi	r27, 0x00	; 0
     756:	ef ea       	ldi	r30, 0xAF	; 175
     758:	f3 e0       	ldi	r31, 0x03	; 3
     75a:	0c 94 c5 3c 	jmp	0x798a	; 0x798a <__prologue_saves__+0x20>
     75e:	69 83       	std	Y+1, r22	; 0x01
     760:	7a 83       	std	Y+2, r23	; 0x02
     762:	8b 83       	std	Y+3, r24	; 0x03
     764:	9c 83       	std	Y+4, r25	; 0x04
     766:	ce 01       	movw	r24, r28
     768:	01 96       	adiw	r24, 0x01	; 1
     76a:	be 01       	movw	r22, r28
     76c:	6b 5f       	subi	r22, 0xFB	; 251
     76e:	7f 4f       	sbci	r23, 0xFF	; 255
     770:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     774:	8d 81       	ldd	r24, Y+5	; 0x05
     776:	82 30       	cpi	r24, 0x02	; 2
     778:	61 f1       	breq	.+88     	; 0x7d2 <__fixsfsi+0x80>
     77a:	82 30       	cpi	r24, 0x02	; 2
     77c:	50 f1       	brcs	.+84     	; 0x7d2 <__fixsfsi+0x80>
     77e:	84 30       	cpi	r24, 0x04	; 4
     780:	21 f4       	brne	.+8      	; 0x78a <__fixsfsi+0x38>
     782:	8e 81       	ldd	r24, Y+6	; 0x06
     784:	88 23       	and	r24, r24
     786:	51 f1       	breq	.+84     	; 0x7dc <__fixsfsi+0x8a>
     788:	2e c0       	rjmp	.+92     	; 0x7e6 <__fixsfsi+0x94>
     78a:	2f 81       	ldd	r18, Y+7	; 0x07
     78c:	38 85       	ldd	r19, Y+8	; 0x08
     78e:	37 fd       	sbrc	r19, 7
     790:	20 c0       	rjmp	.+64     	; 0x7d2 <__fixsfsi+0x80>
     792:	6e 81       	ldd	r22, Y+6	; 0x06
     794:	2f 31       	cpi	r18, 0x1F	; 31
     796:	31 05       	cpc	r19, r1
     798:	1c f0       	brlt	.+6      	; 0x7a0 <__fixsfsi+0x4e>
     79a:	66 23       	and	r22, r22
     79c:	f9 f0       	breq	.+62     	; 0x7dc <__fixsfsi+0x8a>
     79e:	23 c0       	rjmp	.+70     	; 0x7e6 <__fixsfsi+0x94>
     7a0:	8e e1       	ldi	r24, 0x1E	; 30
     7a2:	90 e0       	ldi	r25, 0x00	; 0
     7a4:	82 1b       	sub	r24, r18
     7a6:	93 0b       	sbc	r25, r19
     7a8:	29 85       	ldd	r18, Y+9	; 0x09
     7aa:	3a 85       	ldd	r19, Y+10	; 0x0a
     7ac:	4b 85       	ldd	r20, Y+11	; 0x0b
     7ae:	5c 85       	ldd	r21, Y+12	; 0x0c
     7b0:	04 c0       	rjmp	.+8      	; 0x7ba <__fixsfsi+0x68>
     7b2:	56 95       	lsr	r21
     7b4:	47 95       	ror	r20
     7b6:	37 95       	ror	r19
     7b8:	27 95       	ror	r18
     7ba:	8a 95       	dec	r24
     7bc:	d2 f7       	brpl	.-12     	; 0x7b2 <__fixsfsi+0x60>
     7be:	66 23       	and	r22, r22
     7c0:	b1 f0       	breq	.+44     	; 0x7ee <__fixsfsi+0x9c>
     7c2:	50 95       	com	r21
     7c4:	40 95       	com	r20
     7c6:	30 95       	com	r19
     7c8:	21 95       	neg	r18
     7ca:	3f 4f       	sbci	r19, 0xFF	; 255
     7cc:	4f 4f       	sbci	r20, 0xFF	; 255
     7ce:	5f 4f       	sbci	r21, 0xFF	; 255
     7d0:	0e c0       	rjmp	.+28     	; 0x7ee <__fixsfsi+0x9c>
     7d2:	20 e0       	ldi	r18, 0x00	; 0
     7d4:	30 e0       	ldi	r19, 0x00	; 0
     7d6:	40 e0       	ldi	r20, 0x00	; 0
     7d8:	50 e0       	ldi	r21, 0x00	; 0
     7da:	09 c0       	rjmp	.+18     	; 0x7ee <__fixsfsi+0x9c>
     7dc:	2f ef       	ldi	r18, 0xFF	; 255
     7de:	3f ef       	ldi	r19, 0xFF	; 255
     7e0:	4f ef       	ldi	r20, 0xFF	; 255
     7e2:	5f e7       	ldi	r21, 0x7F	; 127
     7e4:	04 c0       	rjmp	.+8      	; 0x7ee <__fixsfsi+0x9c>
     7e6:	20 e0       	ldi	r18, 0x00	; 0
     7e8:	30 e0       	ldi	r19, 0x00	; 0
     7ea:	40 e0       	ldi	r20, 0x00	; 0
     7ec:	50 e8       	ldi	r21, 0x80	; 128
     7ee:	b9 01       	movw	r22, r18
     7f0:	ca 01       	movw	r24, r20
     7f2:	2c 96       	adiw	r28, 0x0c	; 12
     7f4:	e2 e0       	ldi	r30, 0x02	; 2
     7f6:	0c 94 e1 3c 	jmp	0x79c2	; 0x79c2 <__epilogue_restores__+0x20>

000007fa <__pack_f>:
     7fa:	df 92       	push	r13
     7fc:	ef 92       	push	r14
     7fe:	ff 92       	push	r15
     800:	0f 93       	push	r16
     802:	1f 93       	push	r17
     804:	fc 01       	movw	r30, r24
     806:	e4 80       	ldd	r14, Z+4	; 0x04
     808:	f5 80       	ldd	r15, Z+5	; 0x05
     80a:	06 81       	ldd	r16, Z+6	; 0x06
     80c:	17 81       	ldd	r17, Z+7	; 0x07
     80e:	d1 80       	ldd	r13, Z+1	; 0x01
     810:	80 81       	ld	r24, Z
     812:	82 30       	cpi	r24, 0x02	; 2
     814:	48 f4       	brcc	.+18     	; 0x828 <__pack_f+0x2e>
     816:	80 e0       	ldi	r24, 0x00	; 0
     818:	90 e0       	ldi	r25, 0x00	; 0
     81a:	a0 e1       	ldi	r26, 0x10	; 16
     81c:	b0 e0       	ldi	r27, 0x00	; 0
     81e:	e8 2a       	or	r14, r24
     820:	f9 2a       	or	r15, r25
     822:	0a 2b       	or	r16, r26
     824:	1b 2b       	or	r17, r27
     826:	a5 c0       	rjmp	.+330    	; 0x972 <__stack+0x113>
     828:	84 30       	cpi	r24, 0x04	; 4
     82a:	09 f4       	brne	.+2      	; 0x82e <__pack_f+0x34>
     82c:	9f c0       	rjmp	.+318    	; 0x96c <__stack+0x10d>
     82e:	82 30       	cpi	r24, 0x02	; 2
     830:	21 f4       	brne	.+8      	; 0x83a <__pack_f+0x40>
     832:	ee 24       	eor	r14, r14
     834:	ff 24       	eor	r15, r15
     836:	87 01       	movw	r16, r14
     838:	05 c0       	rjmp	.+10     	; 0x844 <__pack_f+0x4a>
     83a:	e1 14       	cp	r14, r1
     83c:	f1 04       	cpc	r15, r1
     83e:	01 05       	cpc	r16, r1
     840:	11 05       	cpc	r17, r1
     842:	19 f4       	brne	.+6      	; 0x84a <__pack_f+0x50>
     844:	e0 e0       	ldi	r30, 0x00	; 0
     846:	f0 e0       	ldi	r31, 0x00	; 0
     848:	96 c0       	rjmp	.+300    	; 0x976 <__stack+0x117>
     84a:	62 81       	ldd	r22, Z+2	; 0x02
     84c:	73 81       	ldd	r23, Z+3	; 0x03
     84e:	9f ef       	ldi	r25, 0xFF	; 255
     850:	62 38       	cpi	r22, 0x82	; 130
     852:	79 07       	cpc	r23, r25
     854:	0c f0       	brlt	.+2      	; 0x858 <__pack_f+0x5e>
     856:	5b c0       	rjmp	.+182    	; 0x90e <__stack+0xaf>
     858:	22 e8       	ldi	r18, 0x82	; 130
     85a:	3f ef       	ldi	r19, 0xFF	; 255
     85c:	26 1b       	sub	r18, r22
     85e:	37 0b       	sbc	r19, r23
     860:	2a 31       	cpi	r18, 0x1A	; 26
     862:	31 05       	cpc	r19, r1
     864:	2c f0       	brlt	.+10     	; 0x870 <__stack+0x11>
     866:	20 e0       	ldi	r18, 0x00	; 0
     868:	30 e0       	ldi	r19, 0x00	; 0
     86a:	40 e0       	ldi	r20, 0x00	; 0
     86c:	50 e0       	ldi	r21, 0x00	; 0
     86e:	2a c0       	rjmp	.+84     	; 0x8c4 <__stack+0x65>
     870:	b8 01       	movw	r22, r16
     872:	a7 01       	movw	r20, r14
     874:	02 2e       	mov	r0, r18
     876:	04 c0       	rjmp	.+8      	; 0x880 <__stack+0x21>
     878:	76 95       	lsr	r23
     87a:	67 95       	ror	r22
     87c:	57 95       	ror	r21
     87e:	47 95       	ror	r20
     880:	0a 94       	dec	r0
     882:	d2 f7       	brpl	.-12     	; 0x878 <__stack+0x19>
     884:	81 e0       	ldi	r24, 0x01	; 1
     886:	90 e0       	ldi	r25, 0x00	; 0
     888:	a0 e0       	ldi	r26, 0x00	; 0
     88a:	b0 e0       	ldi	r27, 0x00	; 0
     88c:	04 c0       	rjmp	.+8      	; 0x896 <__stack+0x37>
     88e:	88 0f       	add	r24, r24
     890:	99 1f       	adc	r25, r25
     892:	aa 1f       	adc	r26, r26
     894:	bb 1f       	adc	r27, r27
     896:	2a 95       	dec	r18
     898:	d2 f7       	brpl	.-12     	; 0x88e <__stack+0x2f>
     89a:	01 97       	sbiw	r24, 0x01	; 1
     89c:	a1 09       	sbc	r26, r1
     89e:	b1 09       	sbc	r27, r1
     8a0:	8e 21       	and	r24, r14
     8a2:	9f 21       	and	r25, r15
     8a4:	a0 23       	and	r26, r16
     8a6:	b1 23       	and	r27, r17
     8a8:	00 97       	sbiw	r24, 0x00	; 0
     8aa:	a1 05       	cpc	r26, r1
     8ac:	b1 05       	cpc	r27, r1
     8ae:	21 f0       	breq	.+8      	; 0x8b8 <__stack+0x59>
     8b0:	81 e0       	ldi	r24, 0x01	; 1
     8b2:	90 e0       	ldi	r25, 0x00	; 0
     8b4:	a0 e0       	ldi	r26, 0x00	; 0
     8b6:	b0 e0       	ldi	r27, 0x00	; 0
     8b8:	9a 01       	movw	r18, r20
     8ba:	ab 01       	movw	r20, r22
     8bc:	28 2b       	or	r18, r24
     8be:	39 2b       	or	r19, r25
     8c0:	4a 2b       	or	r20, r26
     8c2:	5b 2b       	or	r21, r27
     8c4:	da 01       	movw	r26, r20
     8c6:	c9 01       	movw	r24, r18
     8c8:	8f 77       	andi	r24, 0x7F	; 127
     8ca:	90 70       	andi	r25, 0x00	; 0
     8cc:	a0 70       	andi	r26, 0x00	; 0
     8ce:	b0 70       	andi	r27, 0x00	; 0
     8d0:	80 34       	cpi	r24, 0x40	; 64
     8d2:	91 05       	cpc	r25, r1
     8d4:	a1 05       	cpc	r26, r1
     8d6:	b1 05       	cpc	r27, r1
     8d8:	39 f4       	brne	.+14     	; 0x8e8 <__stack+0x89>
     8da:	27 ff       	sbrs	r18, 7
     8dc:	09 c0       	rjmp	.+18     	; 0x8f0 <__stack+0x91>
     8de:	20 5c       	subi	r18, 0xC0	; 192
     8e0:	3f 4f       	sbci	r19, 0xFF	; 255
     8e2:	4f 4f       	sbci	r20, 0xFF	; 255
     8e4:	5f 4f       	sbci	r21, 0xFF	; 255
     8e6:	04 c0       	rjmp	.+8      	; 0x8f0 <__stack+0x91>
     8e8:	21 5c       	subi	r18, 0xC1	; 193
     8ea:	3f 4f       	sbci	r19, 0xFF	; 255
     8ec:	4f 4f       	sbci	r20, 0xFF	; 255
     8ee:	5f 4f       	sbci	r21, 0xFF	; 255
     8f0:	e0 e0       	ldi	r30, 0x00	; 0
     8f2:	f0 e0       	ldi	r31, 0x00	; 0
     8f4:	20 30       	cpi	r18, 0x00	; 0
     8f6:	a0 e0       	ldi	r26, 0x00	; 0
     8f8:	3a 07       	cpc	r19, r26
     8fa:	a0 e0       	ldi	r26, 0x00	; 0
     8fc:	4a 07       	cpc	r20, r26
     8fe:	a0 e4       	ldi	r26, 0x40	; 64
     900:	5a 07       	cpc	r21, r26
     902:	10 f0       	brcs	.+4      	; 0x908 <__stack+0xa9>
     904:	e1 e0       	ldi	r30, 0x01	; 1
     906:	f0 e0       	ldi	r31, 0x00	; 0
     908:	79 01       	movw	r14, r18
     90a:	8a 01       	movw	r16, r20
     90c:	27 c0       	rjmp	.+78     	; 0x95c <__stack+0xfd>
     90e:	60 38       	cpi	r22, 0x80	; 128
     910:	71 05       	cpc	r23, r1
     912:	64 f5       	brge	.+88     	; 0x96c <__stack+0x10d>
     914:	fb 01       	movw	r30, r22
     916:	e1 58       	subi	r30, 0x81	; 129
     918:	ff 4f       	sbci	r31, 0xFF	; 255
     91a:	d8 01       	movw	r26, r16
     91c:	c7 01       	movw	r24, r14
     91e:	8f 77       	andi	r24, 0x7F	; 127
     920:	90 70       	andi	r25, 0x00	; 0
     922:	a0 70       	andi	r26, 0x00	; 0
     924:	b0 70       	andi	r27, 0x00	; 0
     926:	80 34       	cpi	r24, 0x40	; 64
     928:	91 05       	cpc	r25, r1
     92a:	a1 05       	cpc	r26, r1
     92c:	b1 05       	cpc	r27, r1
     92e:	39 f4       	brne	.+14     	; 0x93e <__stack+0xdf>
     930:	e7 fe       	sbrs	r14, 7
     932:	0d c0       	rjmp	.+26     	; 0x94e <__stack+0xef>
     934:	80 e4       	ldi	r24, 0x40	; 64
     936:	90 e0       	ldi	r25, 0x00	; 0
     938:	a0 e0       	ldi	r26, 0x00	; 0
     93a:	b0 e0       	ldi	r27, 0x00	; 0
     93c:	04 c0       	rjmp	.+8      	; 0x946 <__stack+0xe7>
     93e:	8f e3       	ldi	r24, 0x3F	; 63
     940:	90 e0       	ldi	r25, 0x00	; 0
     942:	a0 e0       	ldi	r26, 0x00	; 0
     944:	b0 e0       	ldi	r27, 0x00	; 0
     946:	e8 0e       	add	r14, r24
     948:	f9 1e       	adc	r15, r25
     94a:	0a 1f       	adc	r16, r26
     94c:	1b 1f       	adc	r17, r27
     94e:	17 ff       	sbrs	r17, 7
     950:	05 c0       	rjmp	.+10     	; 0x95c <__stack+0xfd>
     952:	16 95       	lsr	r17
     954:	07 95       	ror	r16
     956:	f7 94       	ror	r15
     958:	e7 94       	ror	r14
     95a:	31 96       	adiw	r30, 0x01	; 1
     95c:	87 e0       	ldi	r24, 0x07	; 7
     95e:	16 95       	lsr	r17
     960:	07 95       	ror	r16
     962:	f7 94       	ror	r15
     964:	e7 94       	ror	r14
     966:	8a 95       	dec	r24
     968:	d1 f7       	brne	.-12     	; 0x95e <__stack+0xff>
     96a:	05 c0       	rjmp	.+10     	; 0x976 <__stack+0x117>
     96c:	ee 24       	eor	r14, r14
     96e:	ff 24       	eor	r15, r15
     970:	87 01       	movw	r16, r14
     972:	ef ef       	ldi	r30, 0xFF	; 255
     974:	f0 e0       	ldi	r31, 0x00	; 0
     976:	6e 2f       	mov	r22, r30
     978:	67 95       	ror	r22
     97a:	66 27       	eor	r22, r22
     97c:	67 95       	ror	r22
     97e:	90 2f       	mov	r25, r16
     980:	9f 77       	andi	r25, 0x7F	; 127
     982:	d7 94       	ror	r13
     984:	dd 24       	eor	r13, r13
     986:	d7 94       	ror	r13
     988:	8e 2f       	mov	r24, r30
     98a:	86 95       	lsr	r24
     98c:	49 2f       	mov	r20, r25
     98e:	46 2b       	or	r20, r22
     990:	58 2f       	mov	r21, r24
     992:	5d 29       	or	r21, r13
     994:	b7 01       	movw	r22, r14
     996:	ca 01       	movw	r24, r20
     998:	1f 91       	pop	r17
     99a:	0f 91       	pop	r16
     99c:	ff 90       	pop	r15
     99e:	ef 90       	pop	r14
     9a0:	df 90       	pop	r13
     9a2:	08 95       	ret

000009a4 <__unpack_f>:
     9a4:	fc 01       	movw	r30, r24
     9a6:	db 01       	movw	r26, r22
     9a8:	40 81       	ld	r20, Z
     9aa:	51 81       	ldd	r21, Z+1	; 0x01
     9ac:	22 81       	ldd	r18, Z+2	; 0x02
     9ae:	62 2f       	mov	r22, r18
     9b0:	6f 77       	andi	r22, 0x7F	; 127
     9b2:	70 e0       	ldi	r23, 0x00	; 0
     9b4:	22 1f       	adc	r18, r18
     9b6:	22 27       	eor	r18, r18
     9b8:	22 1f       	adc	r18, r18
     9ba:	93 81       	ldd	r25, Z+3	; 0x03
     9bc:	89 2f       	mov	r24, r25
     9be:	88 0f       	add	r24, r24
     9c0:	82 2b       	or	r24, r18
     9c2:	28 2f       	mov	r18, r24
     9c4:	30 e0       	ldi	r19, 0x00	; 0
     9c6:	99 1f       	adc	r25, r25
     9c8:	99 27       	eor	r25, r25
     9ca:	99 1f       	adc	r25, r25
     9cc:	11 96       	adiw	r26, 0x01	; 1
     9ce:	9c 93       	st	X, r25
     9d0:	11 97       	sbiw	r26, 0x01	; 1
     9d2:	21 15       	cp	r18, r1
     9d4:	31 05       	cpc	r19, r1
     9d6:	a9 f5       	brne	.+106    	; 0xa42 <__unpack_f+0x9e>
     9d8:	41 15       	cp	r20, r1
     9da:	51 05       	cpc	r21, r1
     9dc:	61 05       	cpc	r22, r1
     9de:	71 05       	cpc	r23, r1
     9e0:	11 f4       	brne	.+4      	; 0x9e6 <__unpack_f+0x42>
     9e2:	82 e0       	ldi	r24, 0x02	; 2
     9e4:	37 c0       	rjmp	.+110    	; 0xa54 <__unpack_f+0xb0>
     9e6:	82 e8       	ldi	r24, 0x82	; 130
     9e8:	9f ef       	ldi	r25, 0xFF	; 255
     9ea:	13 96       	adiw	r26, 0x03	; 3
     9ec:	9c 93       	st	X, r25
     9ee:	8e 93       	st	-X, r24
     9f0:	12 97       	sbiw	r26, 0x02	; 2
     9f2:	9a 01       	movw	r18, r20
     9f4:	ab 01       	movw	r20, r22
     9f6:	67 e0       	ldi	r22, 0x07	; 7
     9f8:	22 0f       	add	r18, r18
     9fa:	33 1f       	adc	r19, r19
     9fc:	44 1f       	adc	r20, r20
     9fe:	55 1f       	adc	r21, r21
     a00:	6a 95       	dec	r22
     a02:	d1 f7       	brne	.-12     	; 0x9f8 <__unpack_f+0x54>
     a04:	83 e0       	ldi	r24, 0x03	; 3
     a06:	8c 93       	st	X, r24
     a08:	0d c0       	rjmp	.+26     	; 0xa24 <__unpack_f+0x80>
     a0a:	22 0f       	add	r18, r18
     a0c:	33 1f       	adc	r19, r19
     a0e:	44 1f       	adc	r20, r20
     a10:	55 1f       	adc	r21, r21
     a12:	12 96       	adiw	r26, 0x02	; 2
     a14:	8d 91       	ld	r24, X+
     a16:	9c 91       	ld	r25, X
     a18:	13 97       	sbiw	r26, 0x03	; 3
     a1a:	01 97       	sbiw	r24, 0x01	; 1
     a1c:	13 96       	adiw	r26, 0x03	; 3
     a1e:	9c 93       	st	X, r25
     a20:	8e 93       	st	-X, r24
     a22:	12 97       	sbiw	r26, 0x02	; 2
     a24:	20 30       	cpi	r18, 0x00	; 0
     a26:	80 e0       	ldi	r24, 0x00	; 0
     a28:	38 07       	cpc	r19, r24
     a2a:	80 e0       	ldi	r24, 0x00	; 0
     a2c:	48 07       	cpc	r20, r24
     a2e:	80 e4       	ldi	r24, 0x40	; 64
     a30:	58 07       	cpc	r21, r24
     a32:	58 f3       	brcs	.-42     	; 0xa0a <__unpack_f+0x66>
     a34:	14 96       	adiw	r26, 0x04	; 4
     a36:	2d 93       	st	X+, r18
     a38:	3d 93       	st	X+, r19
     a3a:	4d 93       	st	X+, r20
     a3c:	5c 93       	st	X, r21
     a3e:	17 97       	sbiw	r26, 0x07	; 7
     a40:	08 95       	ret
     a42:	2f 3f       	cpi	r18, 0xFF	; 255
     a44:	31 05       	cpc	r19, r1
     a46:	79 f4       	brne	.+30     	; 0xa66 <__unpack_f+0xc2>
     a48:	41 15       	cp	r20, r1
     a4a:	51 05       	cpc	r21, r1
     a4c:	61 05       	cpc	r22, r1
     a4e:	71 05       	cpc	r23, r1
     a50:	19 f4       	brne	.+6      	; 0xa58 <__unpack_f+0xb4>
     a52:	84 e0       	ldi	r24, 0x04	; 4
     a54:	8c 93       	st	X, r24
     a56:	08 95       	ret
     a58:	64 ff       	sbrs	r22, 4
     a5a:	03 c0       	rjmp	.+6      	; 0xa62 <__unpack_f+0xbe>
     a5c:	81 e0       	ldi	r24, 0x01	; 1
     a5e:	8c 93       	st	X, r24
     a60:	12 c0       	rjmp	.+36     	; 0xa86 <__unpack_f+0xe2>
     a62:	1c 92       	st	X, r1
     a64:	10 c0       	rjmp	.+32     	; 0xa86 <__unpack_f+0xe2>
     a66:	2f 57       	subi	r18, 0x7F	; 127
     a68:	30 40       	sbci	r19, 0x00	; 0
     a6a:	13 96       	adiw	r26, 0x03	; 3
     a6c:	3c 93       	st	X, r19
     a6e:	2e 93       	st	-X, r18
     a70:	12 97       	sbiw	r26, 0x02	; 2
     a72:	83 e0       	ldi	r24, 0x03	; 3
     a74:	8c 93       	st	X, r24
     a76:	87 e0       	ldi	r24, 0x07	; 7
     a78:	44 0f       	add	r20, r20
     a7a:	55 1f       	adc	r21, r21
     a7c:	66 1f       	adc	r22, r22
     a7e:	77 1f       	adc	r23, r23
     a80:	8a 95       	dec	r24
     a82:	d1 f7       	brne	.-12     	; 0xa78 <__unpack_f+0xd4>
     a84:	70 64       	ori	r23, 0x40	; 64
     a86:	14 96       	adiw	r26, 0x04	; 4
     a88:	4d 93       	st	X+, r20
     a8a:	5d 93       	st	X+, r21
     a8c:	6d 93       	st	X+, r22
     a8e:	7c 93       	st	X, r23
     a90:	17 97       	sbiw	r26, 0x07	; 7
     a92:	08 95       	ret

00000a94 <__fpcmp_parts_f>:
     a94:	1f 93       	push	r17
     a96:	dc 01       	movw	r26, r24
     a98:	fb 01       	movw	r30, r22
     a9a:	9c 91       	ld	r25, X
     a9c:	92 30       	cpi	r25, 0x02	; 2
     a9e:	08 f4       	brcc	.+2      	; 0xaa2 <__fpcmp_parts_f+0xe>
     aa0:	47 c0       	rjmp	.+142    	; 0xb30 <__fpcmp_parts_f+0x9c>
     aa2:	80 81       	ld	r24, Z
     aa4:	82 30       	cpi	r24, 0x02	; 2
     aa6:	08 f4       	brcc	.+2      	; 0xaaa <__fpcmp_parts_f+0x16>
     aa8:	43 c0       	rjmp	.+134    	; 0xb30 <__fpcmp_parts_f+0x9c>
     aaa:	94 30       	cpi	r25, 0x04	; 4
     aac:	51 f4       	brne	.+20     	; 0xac2 <__fpcmp_parts_f+0x2e>
     aae:	11 96       	adiw	r26, 0x01	; 1
     ab0:	1c 91       	ld	r17, X
     ab2:	84 30       	cpi	r24, 0x04	; 4
     ab4:	99 f5       	brne	.+102    	; 0xb1c <__fpcmp_parts_f+0x88>
     ab6:	81 81       	ldd	r24, Z+1	; 0x01
     ab8:	68 2f       	mov	r22, r24
     aba:	70 e0       	ldi	r23, 0x00	; 0
     abc:	61 1b       	sub	r22, r17
     abe:	71 09       	sbc	r23, r1
     ac0:	3f c0       	rjmp	.+126    	; 0xb40 <__fpcmp_parts_f+0xac>
     ac2:	84 30       	cpi	r24, 0x04	; 4
     ac4:	21 f0       	breq	.+8      	; 0xace <__fpcmp_parts_f+0x3a>
     ac6:	92 30       	cpi	r25, 0x02	; 2
     ac8:	31 f4       	brne	.+12     	; 0xad6 <__fpcmp_parts_f+0x42>
     aca:	82 30       	cpi	r24, 0x02	; 2
     acc:	b9 f1       	breq	.+110    	; 0xb3c <__fpcmp_parts_f+0xa8>
     ace:	81 81       	ldd	r24, Z+1	; 0x01
     ad0:	88 23       	and	r24, r24
     ad2:	89 f1       	breq	.+98     	; 0xb36 <__fpcmp_parts_f+0xa2>
     ad4:	2d c0       	rjmp	.+90     	; 0xb30 <__fpcmp_parts_f+0x9c>
     ad6:	11 96       	adiw	r26, 0x01	; 1
     ad8:	1c 91       	ld	r17, X
     ada:	11 97       	sbiw	r26, 0x01	; 1
     adc:	82 30       	cpi	r24, 0x02	; 2
     ade:	f1 f0       	breq	.+60     	; 0xb1c <__fpcmp_parts_f+0x88>
     ae0:	81 81       	ldd	r24, Z+1	; 0x01
     ae2:	18 17       	cp	r17, r24
     ae4:	d9 f4       	brne	.+54     	; 0xb1c <__fpcmp_parts_f+0x88>
     ae6:	12 96       	adiw	r26, 0x02	; 2
     ae8:	2d 91       	ld	r18, X+
     aea:	3c 91       	ld	r19, X
     aec:	13 97       	sbiw	r26, 0x03	; 3
     aee:	82 81       	ldd	r24, Z+2	; 0x02
     af0:	93 81       	ldd	r25, Z+3	; 0x03
     af2:	82 17       	cp	r24, r18
     af4:	93 07       	cpc	r25, r19
     af6:	94 f0       	brlt	.+36     	; 0xb1c <__fpcmp_parts_f+0x88>
     af8:	28 17       	cp	r18, r24
     afa:	39 07       	cpc	r19, r25
     afc:	bc f0       	brlt	.+46     	; 0xb2c <__fpcmp_parts_f+0x98>
     afe:	14 96       	adiw	r26, 0x04	; 4
     b00:	8d 91       	ld	r24, X+
     b02:	9d 91       	ld	r25, X+
     b04:	0d 90       	ld	r0, X+
     b06:	bc 91       	ld	r27, X
     b08:	a0 2d       	mov	r26, r0
     b0a:	24 81       	ldd	r18, Z+4	; 0x04
     b0c:	35 81       	ldd	r19, Z+5	; 0x05
     b0e:	46 81       	ldd	r20, Z+6	; 0x06
     b10:	57 81       	ldd	r21, Z+7	; 0x07
     b12:	28 17       	cp	r18, r24
     b14:	39 07       	cpc	r19, r25
     b16:	4a 07       	cpc	r20, r26
     b18:	5b 07       	cpc	r21, r27
     b1a:	18 f4       	brcc	.+6      	; 0xb22 <__fpcmp_parts_f+0x8e>
     b1c:	11 23       	and	r17, r17
     b1e:	41 f0       	breq	.+16     	; 0xb30 <__fpcmp_parts_f+0x9c>
     b20:	0a c0       	rjmp	.+20     	; 0xb36 <__fpcmp_parts_f+0xa2>
     b22:	82 17       	cp	r24, r18
     b24:	93 07       	cpc	r25, r19
     b26:	a4 07       	cpc	r26, r20
     b28:	b5 07       	cpc	r27, r21
     b2a:	40 f4       	brcc	.+16     	; 0xb3c <__fpcmp_parts_f+0xa8>
     b2c:	11 23       	and	r17, r17
     b2e:	19 f0       	breq	.+6      	; 0xb36 <__fpcmp_parts_f+0xa2>
     b30:	61 e0       	ldi	r22, 0x01	; 1
     b32:	70 e0       	ldi	r23, 0x00	; 0
     b34:	05 c0       	rjmp	.+10     	; 0xb40 <__fpcmp_parts_f+0xac>
     b36:	6f ef       	ldi	r22, 0xFF	; 255
     b38:	7f ef       	ldi	r23, 0xFF	; 255
     b3a:	02 c0       	rjmp	.+4      	; 0xb40 <__fpcmp_parts_f+0xac>
     b3c:	60 e0       	ldi	r22, 0x00	; 0
     b3e:	70 e0       	ldi	r23, 0x00	; 0
     b40:	cb 01       	movw	r24, r22
     b42:	1f 91       	pop	r17
     b44:	08 95       	ret

00000b46 <TIMER0_voidInit>:
#include "TIMER0_register.h"

static void (*TIMER0_pvCompCallBackFunc) (void)={NULL};

void TIMER0_voidInit(void)
{
     b46:	df 93       	push	r29
     b48:	cf 93       	push	r28
     b4a:	cd b7       	in	r28, 0x3d	; 61
     b4c:	de b7       	in	r29, 0x3e	; 62
	/*choose Wave Generation Mode*/
	SET_BIT(TCCR0,TCCR0_WGM01);
     b4e:	a3 e5       	ldi	r26, 0x53	; 83
     b50:	b0 e0       	ldi	r27, 0x00	; 0
     b52:	e3 e5       	ldi	r30, 0x53	; 83
     b54:	f0 e0       	ldi	r31, 0x00	; 0
     b56:	80 81       	ld	r24, Z
     b58:	88 60       	ori	r24, 0x08	; 8
     b5a:	8c 93       	st	X, r24
	CLR_BIT(TCCR0,TCCR0_WGM00);
     b5c:	a3 e5       	ldi	r26, 0x53	; 83
     b5e:	b0 e0       	ldi	r27, 0x00	; 0
     b60:	e3 e5       	ldi	r30, 0x53	; 83
     b62:	f0 e0       	ldi	r31, 0x00	; 0
     b64:	80 81       	ld	r24, Z
     b66:	8f 7b       	andi	r24, 0xBF	; 191
     b68:	8c 93       	st	X, r24
	OCR0 = TIMER0_COMP_MATCH_VALUE;
     b6a:	ec e5       	ldi	r30, 0x5C	; 92
     b6c:	f0 e0       	ldi	r31, 0x00	; 0
     b6e:	8d e7       	ldi	r24, 0x7D	; 125
     b70:	80 83       	st	Z, r24
	/*Output Compare Match Interrupt Enable*/
	SET_BIT(TIMSK,TIMSK_OCIE0);
     b72:	a9 e5       	ldi	r26, 0x59	; 89
     b74:	b0 e0       	ldi	r27, 0x00	; 0
     b76:	e9 e5       	ldi	r30, 0x59	; 89
     b78:	f0 e0       	ldi	r31, 0x00	; 0
     b7a:	80 81       	ld	r24, Z
     b7c:	82 60       	ori	r24, 0x02	; 2
     b7e:	8c 93       	st	X, r24
	/*Prescaler*/
	TCCR0&=TIMER_PRESCALER_MASK;
     b80:	a3 e5       	ldi	r26, 0x53	; 83
     b82:	b0 e0       	ldi	r27, 0x00	; 0
     b84:	e3 e5       	ldi	r30, 0x53	; 83
     b86:	f0 e0       	ldi	r31, 0x00	; 0
     b88:	80 81       	ld	r24, Z
     b8a:	88 7f       	andi	r24, 0xF8	; 248
     b8c:	8c 93       	st	X, r24
	TCCR0|=TIMER0_PRESCALER;
     b8e:	a3 e5       	ldi	r26, 0x53	; 83
     b90:	b0 e0       	ldi	r27, 0x00	; 0
     b92:	e3 e5       	ldi	r30, 0x53	; 83
     b94:	f0 e0       	ldi	r31, 0x00	; 0
     b96:	80 81       	ld	r24, Z
     b98:	82 60       	ori	r24, 0x02	; 2
     b9a:	8c 93       	st	X, r24
}
     b9c:	cf 91       	pop	r28
     b9e:	df 91       	pop	r29
     ba0:	08 95       	ret

00000ba2 <__vector_10>:

void __vector_10 (void) __attribute__((signal));
void __vector_10 (void)
{
     ba2:	1f 92       	push	r1
     ba4:	0f 92       	push	r0
     ba6:	0f b6       	in	r0, 0x3f	; 63
     ba8:	0f 92       	push	r0
     baa:	11 24       	eor	r1, r1
     bac:	2f 93       	push	r18
     bae:	3f 93       	push	r19
     bb0:	4f 93       	push	r20
     bb2:	5f 93       	push	r21
     bb4:	6f 93       	push	r22
     bb6:	7f 93       	push	r23
     bb8:	8f 93       	push	r24
     bba:	9f 93       	push	r25
     bbc:	af 93       	push	r26
     bbe:	bf 93       	push	r27
     bc0:	ef 93       	push	r30
     bc2:	ff 93       	push	r31
     bc4:	df 93       	push	r29
     bc6:	cf 93       	push	r28
     bc8:	cd b7       	in	r28, 0x3d	; 61
     bca:	de b7       	in	r29, 0x3e	; 62
	if(TIMER0_pvCompCallBackFunc!=NULL)
     bcc:	80 91 34 01 	lds	r24, 0x0134
     bd0:	90 91 35 01 	lds	r25, 0x0135
     bd4:	00 97       	sbiw	r24, 0x00	; 0
     bd6:	29 f0       	breq	.+10     	; 0xbe2 <__vector_10+0x40>
	{
		TIMER0_pvCompCallBackFunc();
     bd8:	e0 91 34 01 	lds	r30, 0x0134
     bdc:	f0 91 35 01 	lds	r31, 0x0135
     be0:	09 95       	icall
	}
}
     be2:	cf 91       	pop	r28
     be4:	df 91       	pop	r29
     be6:	ff 91       	pop	r31
     be8:	ef 91       	pop	r30
     bea:	bf 91       	pop	r27
     bec:	af 91       	pop	r26
     bee:	9f 91       	pop	r25
     bf0:	8f 91       	pop	r24
     bf2:	7f 91       	pop	r23
     bf4:	6f 91       	pop	r22
     bf6:	5f 91       	pop	r21
     bf8:	4f 91       	pop	r20
     bfa:	3f 91       	pop	r19
     bfc:	2f 91       	pop	r18
     bfe:	0f 90       	pop	r0
     c00:	0f be       	out	0x3f, r0	; 63
     c02:	0f 90       	pop	r0
     c04:	1f 90       	pop	r1
     c06:	18 95       	reti

00000c08 <TIMER_u8SetCallBack>:

u8 TIMER_u8SetCallBack(void (* Copy_pvCallBackFunc) (void))
{
     c08:	df 93       	push	r29
     c0a:	cf 93       	push	r28
     c0c:	00 d0       	rcall	.+0      	; 0xc0e <TIMER_u8SetCallBack+0x6>
     c0e:	0f 92       	push	r0
     c10:	cd b7       	in	r28, 0x3d	; 61
     c12:	de b7       	in	r29, 0x3e	; 62
     c14:	9b 83       	std	Y+3, r25	; 0x03
     c16:	8a 83       	std	Y+2, r24	; 0x02
	u8 Local_u8ErrorStatus=OK;
     c18:	19 82       	std	Y+1, r1	; 0x01
	if(Copy_pvCallBackFunc!=NULL)
     c1a:	8a 81       	ldd	r24, Y+2	; 0x02
     c1c:	9b 81       	ldd	r25, Y+3	; 0x03
     c1e:	00 97       	sbiw	r24, 0x00	; 0
     c20:	39 f0       	breq	.+14     	; 0xc30 <TIMER_u8SetCallBack+0x28>
	{
		/*pass The pointer to local function to global pointer to function to be called in ISR*/
		TIMER0_pvCompCallBackFunc=Copy_pvCallBackFunc;
     c22:	8a 81       	ldd	r24, Y+2	; 0x02
     c24:	9b 81       	ldd	r25, Y+3	; 0x03
     c26:	90 93 35 01 	sts	0x0135, r25
     c2a:	80 93 34 01 	sts	0x0134, r24
     c2e:	02 c0       	rjmp	.+4      	; 0xc34 <TIMER_u8SetCallBack+0x2c>
	}
	else
	{
		Local_u8ErrorStatus=NULL_POINTER;
     c30:	82 e0       	ldi	r24, 0x02	; 2
     c32:	89 83       	std	Y+1, r24	; 0x01
	}
	return Local_u8ErrorStatus;
     c34:	89 81       	ldd	r24, Y+1	; 0x01
     c36:	0f 90       	pop	r0
     c38:	0f 90       	pop	r0
     c3a:	0f 90       	pop	r0
     c3c:	cf 91       	pop	r28
     c3e:	df 91       	pop	r29
     c40:	08 95       	ret

00000c42 <GIE_voidEnable>:

#include "GIE_interface.h"
#include "GIE_register.h"

void GIE_voidEnable(void)
{
     c42:	df 93       	push	r29
     c44:	cf 93       	push	r28
     c46:	cd b7       	in	r28, 0x3d	; 61
     c48:	de b7       	in	r29, 0x3e	; 62
	SET_BIT(SREG,SREG_I);
     c4a:	af e5       	ldi	r26, 0x5F	; 95
     c4c:	b0 e0       	ldi	r27, 0x00	; 0
     c4e:	ef e5       	ldi	r30, 0x5F	; 95
     c50:	f0 e0       	ldi	r31, 0x00	; 0
     c52:	80 81       	ld	r24, Z
     c54:	80 68       	ori	r24, 0x80	; 128
     c56:	8c 93       	st	X, r24
}
     c58:	cf 91       	pop	r28
     c5a:	df 91       	pop	r29
     c5c:	08 95       	ret

00000c5e <GIE_voidDisable>:

void GIE_voidDisable(void)
{
     c5e:	df 93       	push	r29
     c60:	cf 93       	push	r28
     c62:	cd b7       	in	r28, 0x3d	; 61
     c64:	de b7       	in	r29, 0x3e	; 62
	CLR_BIT(SREG,SREG_I);
     c66:	af e5       	ldi	r26, 0x5F	; 95
     c68:	b0 e0       	ldi	r27, 0x00	; 0
     c6a:	ef e5       	ldi	r30, 0x5F	; 95
     c6c:	f0 e0       	ldi	r31, 0x00	; 0
     c6e:	80 81       	ld	r24, Z
     c70:	8f 77       	andi	r24, 0x7F	; 127
     c72:	8c 93       	st	X, r24
}
     c74:	cf 91       	pop	r28
     c76:	df 91       	pop	r29
     c78:	08 95       	ret

00000c7a <ADC_Init>:
#include"ADC.h"


static u8 ADC_flag=0;
void ADC_Init(ADC_VoltRef_type ref,ADC_Prescaler_type scaler)
{
     c7a:	df 93       	push	r29
     c7c:	cf 93       	push	r28
     c7e:	00 d0       	rcall	.+0      	; 0xc80 <ADC_Init+0x6>
     c80:	00 d0       	rcall	.+0      	; 0xc82 <ADC_Init+0x8>
     c82:	cd b7       	in	r28, 0x3d	; 61
     c84:	de b7       	in	r29, 0x3e	; 62
     c86:	89 83       	std	Y+1, r24	; 0x01
     c88:	6a 83       	std	Y+2, r22	; 0x02
	// prescaler

	ADCSRA=ADCSRA&0xF8;// 11111000
     c8a:	a6 e2       	ldi	r26, 0x26	; 38
     c8c:	b0 e0       	ldi	r27, 0x00	; 0
     c8e:	e6 e2       	ldi	r30, 0x26	; 38
     c90:	f0 e0       	ldi	r31, 0x00	; 0
     c92:	80 81       	ld	r24, Z
     c94:	88 7f       	andi	r24, 0xF8	; 248
     c96:	8c 93       	st	X, r24
	scaler=scaler&0x07;// 00000111
     c98:	8a 81       	ldd	r24, Y+2	; 0x02
     c9a:	87 70       	andi	r24, 0x07	; 7
     c9c:	8a 83       	std	Y+2, r24	; 0x02
	ADCSRA=ADCSRA|scaler;
     c9e:	a6 e2       	ldi	r26, 0x26	; 38
     ca0:	b0 e0       	ldi	r27, 0x00	; 0
     ca2:	e6 e2       	ldi	r30, 0x26	; 38
     ca4:	f0 e0       	ldi	r31, 0x00	; 0
     ca6:	90 81       	ld	r25, Z
     ca8:	8a 81       	ldd	r24, Y+2	; 0x02
     caa:	89 2b       	or	r24, r25
     cac:	8c 93       	st	X, r24

	//READ ADJUSTED
	CLR_BIT(ADMUX,ADLAR);
     cae:	a7 e2       	ldi	r26, 0x27	; 39
     cb0:	b0 e0       	ldi	r27, 0x00	; 0
     cb2:	e7 e2       	ldi	r30, 0x27	; 39
     cb4:	f0 e0       	ldi	r31, 0x00	; 0
     cb6:	80 81       	ld	r24, Z
     cb8:	8f 7d       	andi	r24, 0xDF	; 223
     cba:	8c 93       	st	X, r24

	// vref

	switch(ref)
     cbc:	89 81       	ldd	r24, Y+1	; 0x01
     cbe:	28 2f       	mov	r18, r24
     cc0:	30 e0       	ldi	r19, 0x00	; 0
     cc2:	3c 83       	std	Y+4, r19	; 0x04
     cc4:	2b 83       	std	Y+3, r18	; 0x03
     cc6:	8b 81       	ldd	r24, Y+3	; 0x03
     cc8:	9c 81       	ldd	r25, Y+4	; 0x04
     cca:	81 30       	cpi	r24, 0x01	; 1
     ccc:	91 05       	cpc	r25, r1
     cce:	c1 f0       	breq	.+48     	; 0xd00 <ADC_Init+0x86>
     cd0:	2b 81       	ldd	r18, Y+3	; 0x03
     cd2:	3c 81       	ldd	r19, Y+4	; 0x04
     cd4:	22 30       	cpi	r18, 0x02	; 2
     cd6:	31 05       	cpc	r19, r1
     cd8:	11 f1       	breq	.+68     	; 0xd1e <ADC_Init+0xa4>
     cda:	8b 81       	ldd	r24, Y+3	; 0x03
     cdc:	9c 81       	ldd	r25, Y+4	; 0x04
     cde:	00 97       	sbiw	r24, 0x00	; 0
     ce0:	61 f5       	brne	.+88     	; 0xd3a <ADC_Init+0xc0>
	{
		case VREF_AREF:
		CLR_BIT(ADMUX,REFS1);
     ce2:	a7 e2       	ldi	r26, 0x27	; 39
     ce4:	b0 e0       	ldi	r27, 0x00	; 0
     ce6:	e7 e2       	ldi	r30, 0x27	; 39
     ce8:	f0 e0       	ldi	r31, 0x00	; 0
     cea:	80 81       	ld	r24, Z
     cec:	8f 77       	andi	r24, 0x7F	; 127
     cee:	8c 93       	st	X, r24
		CLR_BIT(ADMUX,REFS0);
     cf0:	a7 e2       	ldi	r26, 0x27	; 39
     cf2:	b0 e0       	ldi	r27, 0x00	; 0
     cf4:	e7 e2       	ldi	r30, 0x27	; 39
     cf6:	f0 e0       	ldi	r31, 0x00	; 0
     cf8:	80 81       	ld	r24, Z
     cfa:	8f 7b       	andi	r24, 0xBF	; 191
     cfc:	8c 93       	st	X, r24
     cfe:	1d c0       	rjmp	.+58     	; 0xd3a <ADC_Init+0xc0>
		break;
		case VREF_VCC:
		CLR_BIT(ADMUX,REFS1);
     d00:	a7 e2       	ldi	r26, 0x27	; 39
     d02:	b0 e0       	ldi	r27, 0x00	; 0
     d04:	e7 e2       	ldi	r30, 0x27	; 39
     d06:	f0 e0       	ldi	r31, 0x00	; 0
     d08:	80 81       	ld	r24, Z
     d0a:	8f 77       	andi	r24, 0x7F	; 127
     d0c:	8c 93       	st	X, r24
		SET_BIT(ADMUX,REFS0);
     d0e:	a7 e2       	ldi	r26, 0x27	; 39
     d10:	b0 e0       	ldi	r27, 0x00	; 0
     d12:	e7 e2       	ldi	r30, 0x27	; 39
     d14:	f0 e0       	ldi	r31, 0x00	; 0
     d16:	80 81       	ld	r24, Z
     d18:	80 64       	ori	r24, 0x40	; 64
     d1a:	8c 93       	st	X, r24
     d1c:	0e c0       	rjmp	.+28     	; 0xd3a <ADC_Init+0xc0>
		break;
		case VREF_256:
		SET_BIT(ADMUX,REFS1);
     d1e:	a7 e2       	ldi	r26, 0x27	; 39
     d20:	b0 e0       	ldi	r27, 0x00	; 0
     d22:	e7 e2       	ldi	r30, 0x27	; 39
     d24:	f0 e0       	ldi	r31, 0x00	; 0
     d26:	80 81       	ld	r24, Z
     d28:	80 68       	ori	r24, 0x80	; 128
     d2a:	8c 93       	st	X, r24
		SET_BIT(ADMUX,REFS0);
     d2c:	a7 e2       	ldi	r26, 0x27	; 39
     d2e:	b0 e0       	ldi	r27, 0x00	; 0
     d30:	e7 e2       	ldi	r30, 0x27	; 39
     d32:	f0 e0       	ldi	r31, 0x00	; 0
     d34:	80 81       	ld	r24, Z
     d36:	80 64       	ori	r24, 0x40	; 64
     d38:	8c 93       	st	X, r24
		break;
	}

	/*ADC ENABLE*/
	SET_BIT(ADCSRA,ADEN);
     d3a:	a6 e2       	ldi	r26, 0x26	; 38
     d3c:	b0 e0       	ldi	r27, 0x00	; 0
     d3e:	e6 e2       	ldi	r30, 0x26	; 38
     d40:	f0 e0       	ldi	r31, 0x00	; 0
     d42:	80 81       	ld	r24, Z
     d44:	80 68       	ori	r24, 0x80	; 128
     d46:	8c 93       	st	X, r24
}
     d48:	0f 90       	pop	r0
     d4a:	0f 90       	pop	r0
     d4c:	0f 90       	pop	r0
     d4e:	0f 90       	pop	r0
     d50:	cf 91       	pop	r28
     d52:	df 91       	pop	r29
     d54:	08 95       	ret

00000d56 <ADC_Read>:




u16 ADC_Read(ADC_Channel_type ch)
{
     d56:	df 93       	push	r29
     d58:	cf 93       	push	r28
     d5a:	00 d0       	rcall	.+0      	; 0xd5c <ADC_Read+0x6>
     d5c:	0f 92       	push	r0
     d5e:	cd b7       	in	r28, 0x3d	; 61
     d60:	de b7       	in	r29, 0x3e	; 62
     d62:	8b 83       	std	Y+3, r24	; 0x03
	u16 adc;
	/* select mux */
	 ADMUX=ADMUX&0xE0;  //11100000
     d64:	a7 e2       	ldi	r26, 0x27	; 39
     d66:	b0 e0       	ldi	r27, 0x00	; 0
     d68:	e7 e2       	ldi	r30, 0x27	; 39
     d6a:	f0 e0       	ldi	r31, 0x00	; 0
     d6c:	80 81       	ld	r24, Z
     d6e:	80 7e       	andi	r24, 0xE0	; 224
     d70:	8c 93       	st	X, r24
	 ADMUX=ADMUX|ch;
     d72:	a7 e2       	ldi	r26, 0x27	; 39
     d74:	b0 e0       	ldi	r27, 0x00	; 0
     d76:	e7 e2       	ldi	r30, 0x27	; 39
     d78:	f0 e0       	ldi	r31, 0x00	; 0
     d7a:	90 81       	ld	r25, Z
     d7c:	8b 81       	ldd	r24, Y+3	; 0x03
     d7e:	89 2b       	or	r24, r25
     d80:	8c 93       	st	X, r24


	/* start conversion*/
	SET_BIT(ADCSRA,ADSC);
     d82:	a6 e2       	ldi	r26, 0x26	; 38
     d84:	b0 e0       	ldi	r27, 0x00	; 0
     d86:	e6 e2       	ldi	r30, 0x26	; 38
     d88:	f0 e0       	ldi	r31, 0x00	; 0
     d8a:	80 81       	ld	r24, Z
     d8c:	80 64       	ori	r24, 0x40	; 64
     d8e:	8c 93       	st	X, r24

	/* wait to end */
	while(READ_BIT(ADCSRA,ADSC)); //Busy Wait
     d90:	e6 e2       	ldi	r30, 0x26	; 38
     d92:	f0 e0       	ldi	r31, 0x00	; 0
     d94:	80 81       	ld	r24, Z
     d96:	82 95       	swap	r24
     d98:	86 95       	lsr	r24
     d9a:	86 95       	lsr	r24
     d9c:	83 70       	andi	r24, 0x03	; 3
     d9e:	88 2f       	mov	r24, r24
     da0:	90 e0       	ldi	r25, 0x00	; 0
     da2:	81 70       	andi	r24, 0x01	; 1
     da4:	90 70       	andi	r25, 0x00	; 0
     da6:	88 23       	and	r24, r24
     da8:	99 f7       	brne	.-26     	; 0xd90 <ADC_Read+0x3a>
	/* get read */
	//adc=((u16)ADCH<<8|(u16)ADCL);
	//adc=ADCH<<2;
	adc=ADC;
     daa:	e4 e2       	ldi	r30, 0x24	; 36
     dac:	f0 e0       	ldi	r31, 0x00	; 0
     dae:	80 81       	ld	r24, Z
     db0:	91 81       	ldd	r25, Z+1	; 0x01
     db2:	9a 83       	std	Y+2, r25	; 0x02
     db4:	89 83       	std	Y+1, r24	; 0x01
	return adc;
     db6:	89 81       	ldd	r24, Y+1	; 0x01
     db8:	9a 81       	ldd	r25, Y+2	; 0x02
}
     dba:	0f 90       	pop	r0
     dbc:	0f 90       	pop	r0
     dbe:	0f 90       	pop	r0
     dc0:	cf 91       	pop	r28
     dc2:	df 91       	pop	r29
     dc4:	08 95       	ret

00000dc6 <ADC_StartConversion>:

void ADC_StartConversion(ADC_Channel_type ch)
{
     dc6:	df 93       	push	r29
     dc8:	cf 93       	push	r28
     dca:	0f 92       	push	r0
     dcc:	cd b7       	in	r28, 0x3d	; 61
     dce:	de b7       	in	r29, 0x3e	; 62
     dd0:	89 83       	std	Y+1, r24	; 0x01
	if(ADC_flag==0)
     dd2:	80 91 36 01 	lds	r24, 0x0136
     dd6:	88 23       	and	r24, r24
     dd8:	c9 f4       	brne	.+50     	; 0xe0c <ADC_StartConversion+0x46>
	{
		/* select mux */
		ADMUX=ADMUX&0xE0;  //11100000
     dda:	a7 e2       	ldi	r26, 0x27	; 39
     ddc:	b0 e0       	ldi	r27, 0x00	; 0
     dde:	e7 e2       	ldi	r30, 0x27	; 39
     de0:	f0 e0       	ldi	r31, 0x00	; 0
     de2:	80 81       	ld	r24, Z
     de4:	80 7e       	andi	r24, 0xE0	; 224
     de6:	8c 93       	st	X, r24
		ADMUX=ADMUX|ch;
     de8:	a7 e2       	ldi	r26, 0x27	; 39
     dea:	b0 e0       	ldi	r27, 0x00	; 0
     dec:	e7 e2       	ldi	r30, 0x27	; 39
     dee:	f0 e0       	ldi	r31, 0x00	; 0
     df0:	90 81       	ld	r25, Z
     df2:	89 81       	ldd	r24, Y+1	; 0x01
     df4:	89 2b       	or	r24, r25
     df6:	8c 93       	st	X, r24


		/* start conversion*/
		SET_BIT(ADCSRA,ADSC);
     df8:	a6 e2       	ldi	r26, 0x26	; 38
     dfa:	b0 e0       	ldi	r27, 0x00	; 0
     dfc:	e6 e2       	ldi	r30, 0x26	; 38
     dfe:	f0 e0       	ldi	r31, 0x00	; 0
     e00:	80 81       	ld	r24, Z
     e02:	80 64       	ori	r24, 0x40	; 64
     e04:	8c 93       	st	X, r24

		ADC_flag=1;
     e06:	81 e0       	ldi	r24, 0x01	; 1
     e08:	80 93 36 01 	sts	0x0136, r24
	}

}
     e0c:	0f 90       	pop	r0
     e0e:	cf 91       	pop	r28
     e10:	df 91       	pop	r29
     e12:	08 95       	ret

00000e14 <ADC_GetRead>:

u16 ADC_GetRead(void)
{
     e14:	df 93       	push	r29
     e16:	cf 93       	push	r28
     e18:	00 d0       	rcall	.+0      	; 0xe1a <ADC_GetRead+0x6>
     e1a:	cd b7       	in	r28, 0x3d	; 61
     e1c:	de b7       	in	r29, 0x3e	; 62
	u16 adc;
	/* wait to end */
	while(READ_BIT(ADCSRA,ADSC)); //Busy Wait
     e1e:	e6 e2       	ldi	r30, 0x26	; 38
     e20:	f0 e0       	ldi	r31, 0x00	; 0
     e22:	80 81       	ld	r24, Z
     e24:	82 95       	swap	r24
     e26:	86 95       	lsr	r24
     e28:	86 95       	lsr	r24
     e2a:	83 70       	andi	r24, 0x03	; 3
     e2c:	88 2f       	mov	r24, r24
     e2e:	90 e0       	ldi	r25, 0x00	; 0
     e30:	81 70       	andi	r24, 0x01	; 1
     e32:	90 70       	andi	r25, 0x00	; 0
     e34:	88 23       	and	r24, r24
     e36:	99 f7       	brne	.-26     	; 0xe1e <ADC_GetRead+0xa>
	/* get read */
	//adc=((u16)ADCH<<8|(u16)ADCL);
	//adc=ADCH<<2;
	adc=ADC;
     e38:	e4 e2       	ldi	r30, 0x24	; 36
     e3a:	f0 e0       	ldi	r31, 0x00	; 0
     e3c:	80 81       	ld	r24, Z
     e3e:	91 81       	ldd	r25, Z+1	; 0x01
     e40:	9a 83       	std	Y+2, r25	; 0x02
     e42:	89 83       	std	Y+1, r24	; 0x01
	return adc;
     e44:	89 81       	ldd	r24, Y+1	; 0x01
     e46:	9a 81       	ldd	r25, Y+2	; 0x02
}
     e48:	0f 90       	pop	r0
     e4a:	0f 90       	pop	r0
     e4c:	cf 91       	pop	r28
     e4e:	df 91       	pop	r29
     e50:	08 95       	ret

00000e52 <ADC_GetReadPeriodic>:

u16 ADC_GetReadPeriodic(u16 *Pdata)
{
     e52:	df 93       	push	r29
     e54:	cf 93       	push	r28
     e56:	00 d0       	rcall	.+0      	; 0xe58 <ADC_GetReadPeriodic+0x6>
     e58:	00 d0       	rcall	.+0      	; 0xe5a <ADC_GetReadPeriodic+0x8>
     e5a:	cd b7       	in	r28, 0x3d	; 61
     e5c:	de b7       	in	r29, 0x3e	; 62
     e5e:	9a 83       	std	Y+2, r25	; 0x02
     e60:	89 83       	std	Y+1, r24	; 0x01
	if(!READ_BIT(ADCSRA,ADSC))
     e62:	e6 e2       	ldi	r30, 0x26	; 38
     e64:	f0 e0       	ldi	r31, 0x00	; 0
     e66:	80 81       	ld	r24, Z
     e68:	82 95       	swap	r24
     e6a:	86 95       	lsr	r24
     e6c:	86 95       	lsr	r24
     e6e:	83 70       	andi	r24, 0x03	; 3
     e70:	88 2f       	mov	r24, r24
     e72:	90 e0       	ldi	r25, 0x00	; 0
     e74:	81 70       	andi	r24, 0x01	; 1
     e76:	90 70       	andi	r25, 0x00	; 0
     e78:	00 97       	sbiw	r24, 0x00	; 0
     e7a:	79 f4       	brne	.+30     	; 0xe9a <ADC_GetReadPeriodic+0x48>
	{
		*Pdata=ADC;
     e7c:	e4 e2       	ldi	r30, 0x24	; 36
     e7e:	f0 e0       	ldi	r31, 0x00	; 0
     e80:	80 81       	ld	r24, Z
     e82:	91 81       	ldd	r25, Z+1	; 0x01
     e84:	e9 81       	ldd	r30, Y+1	; 0x01
     e86:	fa 81       	ldd	r31, Y+2	; 0x02
     e88:	91 83       	std	Z+1, r25	; 0x01
     e8a:	80 83       	st	Z, r24
		ADC_flag=0;
     e8c:	10 92 36 01 	sts	0x0136, r1
		return 1;
     e90:	81 e0       	ldi	r24, 0x01	; 1
     e92:	90 e0       	ldi	r25, 0x00	; 0
     e94:	9c 83       	std	Y+4, r25	; 0x04
     e96:	8b 83       	std	Y+3, r24	; 0x03
     e98:	02 c0       	rjmp	.+4      	; 0xe9e <ADC_GetReadPeriodic+0x4c>
	}
	return 0;
     e9a:	1c 82       	std	Y+4, r1	; 0x04
     e9c:	1b 82       	std	Y+3, r1	; 0x03
     e9e:	8b 81       	ldd	r24, Y+3	; 0x03
     ea0:	9c 81       	ldd	r25, Y+4	; 0x04
}
     ea2:	0f 90       	pop	r0
     ea4:	0f 90       	pop	r0
     ea6:	0f 90       	pop	r0
     ea8:	0f 90       	pop	r0
     eaa:	cf 91       	pop	r28
     eac:	df 91       	pop	r29
     eae:	08 95       	ret

00000eb0 <ADC_ReadVolt>:
u16 ADC_ReadVolt(ADC_Channel_type ch)
{
     eb0:	df 93       	push	r29
     eb2:	cf 93       	push	r28
     eb4:	00 d0       	rcall	.+0      	; 0xeb6 <ADC_ReadVolt+0x6>
     eb6:	00 d0       	rcall	.+0      	; 0xeb8 <ADC_ReadVolt+0x8>
     eb8:	0f 92       	push	r0
     eba:	cd b7       	in	r28, 0x3d	; 61
     ebc:	de b7       	in	r29, 0x3e	; 62
     ebe:	8d 83       	std	Y+5, r24	; 0x05
	u16 adc =ADC_Read(ch);
     ec0:	8d 81       	ldd	r24, Y+5	; 0x05
     ec2:	0e 94 ab 06 	call	0xd56	; 0xd56 <ADC_Read>
     ec6:	9c 83       	std	Y+4, r25	; 0x04
     ec8:	8b 83       	std	Y+3, r24	; 0x03
	u16 volt =(ADC_VREF *adc)/1024;
     eca:	8b 81       	ldd	r24, Y+3	; 0x03
     ecc:	9c 81       	ldd	r25, Y+4	; 0x04
     ece:	cc 01       	movw	r24, r24
     ed0:	a0 e0       	ldi	r26, 0x00	; 0
     ed2:	b0 e0       	ldi	r27, 0x00	; 0
     ed4:	28 e8       	ldi	r18, 0x88	; 136
     ed6:	33 e1       	ldi	r19, 0x13	; 19
     ed8:	40 e0       	ldi	r20, 0x00	; 0
     eda:	50 e0       	ldi	r21, 0x00	; 0
     edc:	bc 01       	movw	r22, r24
     ede:	cd 01       	movw	r24, r26
     ee0:	0e 94 40 3c 	call	0x7880	; 0x7880 <__mulsi3>
     ee4:	dc 01       	movw	r26, r24
     ee6:	cb 01       	movw	r24, r22
     ee8:	07 2e       	mov	r0, r23
     eea:	7a e0       	ldi	r23, 0x0A	; 10
     eec:	b6 95       	lsr	r27
     eee:	a7 95       	ror	r26
     ef0:	97 95       	ror	r25
     ef2:	87 95       	ror	r24
     ef4:	7a 95       	dec	r23
     ef6:	d1 f7       	brne	.-12     	; 0xeec <ADC_ReadVolt+0x3c>
     ef8:	70 2d       	mov	r23, r0
     efa:	9a 83       	std	Y+2, r25	; 0x02
     efc:	89 83       	std	Y+1, r24	; 0x01
	return volt;
     efe:	89 81       	ldd	r24, Y+1	; 0x01
     f00:	9a 81       	ldd	r25, Y+2	; 0x02
}
     f02:	0f 90       	pop	r0
     f04:	0f 90       	pop	r0
     f06:	0f 90       	pop	r0
     f08:	0f 90       	pop	r0
     f0a:	0f 90       	pop	r0
     f0c:	cf 91       	pop	r28
     f0e:	df 91       	pop	r29
     f10:	08 95       	ret

00000f12 <DIO_PIN_Init>:

};


void DIO_PIN_Init(DIO_Pin_type pin ,DIO_PinStatus_Type status)
{
     f12:	df 93       	push	r29
     f14:	cf 93       	push	r28
     f16:	cd b7       	in	r28, 0x3d	; 61
     f18:	de b7       	in	r29, 0x3e	; 62
     f1a:	2c 97       	sbiw	r28, 0x0c	; 12
     f1c:	0f b6       	in	r0, 0x3f	; 63
     f1e:	f8 94       	cli
     f20:	de bf       	out	0x3e, r29	; 62
     f22:	0f be       	out	0x3f, r0	; 63
     f24:	cd bf       	out	0x3d, r28	; 61
     f26:	8b 83       	std	Y+3, r24	; 0x03
     f28:	6c 83       	std	Y+4, r22	; 0x04
	   DIO_Port_Type port=pin/8;
     f2a:	8b 81       	ldd	r24, Y+3	; 0x03
     f2c:	86 95       	lsr	r24
     f2e:	86 95       	lsr	r24
     f30:	86 95       	lsr	r24
     f32:	8a 83       	std	Y+2, r24	; 0x02
		u8 pin_num=pin%8;
     f34:	8b 81       	ldd	r24, Y+3	; 0x03
     f36:	87 70       	andi	r24, 0x07	; 7
     f38:	89 83       	std	Y+1, r24	; 0x01

		switch(status)
     f3a:	8c 81       	ldd	r24, Y+4	; 0x04
     f3c:	28 2f       	mov	r18, r24
     f3e:	30 e0       	ldi	r19, 0x00	; 0
     f40:	3c 87       	std	Y+12, r19	; 0x0c
     f42:	2b 87       	std	Y+11, r18	; 0x0b
     f44:	8b 85       	ldd	r24, Y+11	; 0x0b
     f46:	9c 85       	ldd	r25, Y+12	; 0x0c
     f48:	81 30       	cpi	r24, 0x01	; 1
     f4a:	91 05       	cpc	r25, r1
     f4c:	09 f4       	brne	.+2      	; 0xf50 <DIO_PIN_Init+0x3e>
     f4e:	c9 c0       	rjmp	.+402    	; 0x10e2 <DIO_PIN_Init+0x1d0>
     f50:	2b 85       	ldd	r18, Y+11	; 0x0b
     f52:	3c 85       	ldd	r19, Y+12	; 0x0c
     f54:	22 30       	cpi	r18, 0x02	; 2
     f56:	31 05       	cpc	r19, r1
     f58:	09 f4       	brne	.+2      	; 0xf5c <DIO_PIN_Init+0x4a>
     f5a:	85 c1       	rjmp	.+778    	; 0x1266 <DIO_PIN_Init+0x354>
     f5c:	8b 85       	ldd	r24, Y+11	; 0x0b
     f5e:	9c 85       	ldd	r25, Y+12	; 0x0c
     f60:	00 97       	sbiw	r24, 0x00	; 0
     f62:	09 f0       	breq	.+2      	; 0xf66 <DIO_PIN_Init+0x54>
     f64:	3d c2       	rjmp	.+1146   	; 0x13e0 <DIO_PIN_Init+0x4ce>
		{
			case OUTPUT:

			switch(port)
     f66:	8a 81       	ldd	r24, Y+2	; 0x02
     f68:	28 2f       	mov	r18, r24
     f6a:	30 e0       	ldi	r19, 0x00	; 0
     f6c:	3a 87       	std	Y+10, r19	; 0x0a
     f6e:	29 87       	std	Y+9, r18	; 0x09
     f70:	89 85       	ldd	r24, Y+9	; 0x09
     f72:	9a 85       	ldd	r25, Y+10	; 0x0a
     f74:	81 30       	cpi	r24, 0x01	; 1
     f76:	91 05       	cpc	r25, r1
     f78:	09 f4       	brne	.+2      	; 0xf7c <DIO_PIN_Init+0x6a>
     f7a:	3e c0       	rjmp	.+124    	; 0xff8 <DIO_PIN_Init+0xe6>
     f7c:	29 85       	ldd	r18, Y+9	; 0x09
     f7e:	3a 85       	ldd	r19, Y+10	; 0x0a
     f80:	22 30       	cpi	r18, 0x02	; 2
     f82:	31 05       	cpc	r19, r1
     f84:	2c f4       	brge	.+10     	; 0xf90 <DIO_PIN_Init+0x7e>
     f86:	89 85       	ldd	r24, Y+9	; 0x09
     f88:	9a 85       	ldd	r25, Y+10	; 0x0a
     f8a:	00 97       	sbiw	r24, 0x00	; 0
     f8c:	71 f0       	breq	.+28     	; 0xfaa <DIO_PIN_Init+0x98>
     f8e:	28 c2       	rjmp	.+1104   	; 0x13e0 <DIO_PIN_Init+0x4ce>
     f90:	29 85       	ldd	r18, Y+9	; 0x09
     f92:	3a 85       	ldd	r19, Y+10	; 0x0a
     f94:	22 30       	cpi	r18, 0x02	; 2
     f96:	31 05       	cpc	r19, r1
     f98:	09 f4       	brne	.+2      	; 0xf9c <DIO_PIN_Init+0x8a>
     f9a:	55 c0       	rjmp	.+170    	; 0x1046 <DIO_PIN_Init+0x134>
     f9c:	89 85       	ldd	r24, Y+9	; 0x09
     f9e:	9a 85       	ldd	r25, Y+10	; 0x0a
     fa0:	83 30       	cpi	r24, 0x03	; 3
     fa2:	91 05       	cpc	r25, r1
     fa4:	09 f4       	brne	.+2      	; 0xfa8 <DIO_PIN_Init+0x96>
     fa6:	76 c0       	rjmp	.+236    	; 0x1094 <DIO_PIN_Init+0x182>
     fa8:	1b c2       	rjmp	.+1078   	; 0x13e0 <DIO_PIN_Init+0x4ce>
			{
				case PA:
				SET_BIT(DDRA,pin_num);
     faa:	aa e3       	ldi	r26, 0x3A	; 58
     fac:	b0 e0       	ldi	r27, 0x00	; 0
     fae:	ea e3       	ldi	r30, 0x3A	; 58
     fb0:	f0 e0       	ldi	r31, 0x00	; 0
     fb2:	80 81       	ld	r24, Z
     fb4:	48 2f       	mov	r20, r24
     fb6:	89 81       	ldd	r24, Y+1	; 0x01
     fb8:	28 2f       	mov	r18, r24
     fba:	30 e0       	ldi	r19, 0x00	; 0
     fbc:	81 e0       	ldi	r24, 0x01	; 1
     fbe:	90 e0       	ldi	r25, 0x00	; 0
     fc0:	02 c0       	rjmp	.+4      	; 0xfc6 <DIO_PIN_Init+0xb4>
     fc2:	88 0f       	add	r24, r24
     fc4:	99 1f       	adc	r25, r25
     fc6:	2a 95       	dec	r18
     fc8:	e2 f7       	brpl	.-8      	; 0xfc2 <DIO_PIN_Init+0xb0>
     fca:	84 2b       	or	r24, r20
     fcc:	8c 93       	st	X, r24
				CLR_BIT(PORTA,pin_num);
     fce:	ab e3       	ldi	r26, 0x3B	; 59
     fd0:	b0 e0       	ldi	r27, 0x00	; 0
     fd2:	eb e3       	ldi	r30, 0x3B	; 59
     fd4:	f0 e0       	ldi	r31, 0x00	; 0
     fd6:	80 81       	ld	r24, Z
     fd8:	48 2f       	mov	r20, r24
     fda:	89 81       	ldd	r24, Y+1	; 0x01
     fdc:	28 2f       	mov	r18, r24
     fde:	30 e0       	ldi	r19, 0x00	; 0
     fe0:	81 e0       	ldi	r24, 0x01	; 1
     fe2:	90 e0       	ldi	r25, 0x00	; 0
     fe4:	02 2e       	mov	r0, r18
     fe6:	02 c0       	rjmp	.+4      	; 0xfec <DIO_PIN_Init+0xda>
     fe8:	88 0f       	add	r24, r24
     fea:	99 1f       	adc	r25, r25
     fec:	0a 94       	dec	r0
     fee:	e2 f7       	brpl	.-8      	; 0xfe8 <DIO_PIN_Init+0xd6>
     ff0:	80 95       	com	r24
     ff2:	84 23       	and	r24, r20
     ff4:	8c 93       	st	X, r24
     ff6:	f4 c1       	rjmp	.+1000   	; 0x13e0 <DIO_PIN_Init+0x4ce>
				break;

				case PB:
				SET_BIT(DDRB,pin_num);
     ff8:	a7 e3       	ldi	r26, 0x37	; 55
     ffa:	b0 e0       	ldi	r27, 0x00	; 0
     ffc:	e7 e3       	ldi	r30, 0x37	; 55
     ffe:	f0 e0       	ldi	r31, 0x00	; 0
    1000:	80 81       	ld	r24, Z
    1002:	48 2f       	mov	r20, r24
    1004:	89 81       	ldd	r24, Y+1	; 0x01
    1006:	28 2f       	mov	r18, r24
    1008:	30 e0       	ldi	r19, 0x00	; 0
    100a:	81 e0       	ldi	r24, 0x01	; 1
    100c:	90 e0       	ldi	r25, 0x00	; 0
    100e:	02 c0       	rjmp	.+4      	; 0x1014 <DIO_PIN_Init+0x102>
    1010:	88 0f       	add	r24, r24
    1012:	99 1f       	adc	r25, r25
    1014:	2a 95       	dec	r18
    1016:	e2 f7       	brpl	.-8      	; 0x1010 <DIO_PIN_Init+0xfe>
    1018:	84 2b       	or	r24, r20
    101a:	8c 93       	st	X, r24
				CLR_BIT(PORTB,pin_num);
    101c:	a8 e3       	ldi	r26, 0x38	; 56
    101e:	b0 e0       	ldi	r27, 0x00	; 0
    1020:	e8 e3       	ldi	r30, 0x38	; 56
    1022:	f0 e0       	ldi	r31, 0x00	; 0
    1024:	80 81       	ld	r24, Z
    1026:	48 2f       	mov	r20, r24
    1028:	89 81       	ldd	r24, Y+1	; 0x01
    102a:	28 2f       	mov	r18, r24
    102c:	30 e0       	ldi	r19, 0x00	; 0
    102e:	81 e0       	ldi	r24, 0x01	; 1
    1030:	90 e0       	ldi	r25, 0x00	; 0
    1032:	02 2e       	mov	r0, r18
    1034:	02 c0       	rjmp	.+4      	; 0x103a <DIO_PIN_Init+0x128>
    1036:	88 0f       	add	r24, r24
    1038:	99 1f       	adc	r25, r25
    103a:	0a 94       	dec	r0
    103c:	e2 f7       	brpl	.-8      	; 0x1036 <DIO_PIN_Init+0x124>
    103e:	80 95       	com	r24
    1040:	84 23       	and	r24, r20
    1042:	8c 93       	st	X, r24
    1044:	cd c1       	rjmp	.+922    	; 0x13e0 <DIO_PIN_Init+0x4ce>
				break;

				case PC:
				SET_BIT(DDRC,pin_num);
    1046:	a4 e3       	ldi	r26, 0x34	; 52
    1048:	b0 e0       	ldi	r27, 0x00	; 0
    104a:	e4 e3       	ldi	r30, 0x34	; 52
    104c:	f0 e0       	ldi	r31, 0x00	; 0
    104e:	80 81       	ld	r24, Z
    1050:	48 2f       	mov	r20, r24
    1052:	89 81       	ldd	r24, Y+1	; 0x01
    1054:	28 2f       	mov	r18, r24
    1056:	30 e0       	ldi	r19, 0x00	; 0
    1058:	81 e0       	ldi	r24, 0x01	; 1
    105a:	90 e0       	ldi	r25, 0x00	; 0
    105c:	02 c0       	rjmp	.+4      	; 0x1062 <DIO_PIN_Init+0x150>
    105e:	88 0f       	add	r24, r24
    1060:	99 1f       	adc	r25, r25
    1062:	2a 95       	dec	r18
    1064:	e2 f7       	brpl	.-8      	; 0x105e <DIO_PIN_Init+0x14c>
    1066:	84 2b       	or	r24, r20
    1068:	8c 93       	st	X, r24
				CLR_BIT(PORTC,pin_num);
    106a:	a5 e3       	ldi	r26, 0x35	; 53
    106c:	b0 e0       	ldi	r27, 0x00	; 0
    106e:	e5 e3       	ldi	r30, 0x35	; 53
    1070:	f0 e0       	ldi	r31, 0x00	; 0
    1072:	80 81       	ld	r24, Z
    1074:	48 2f       	mov	r20, r24
    1076:	89 81       	ldd	r24, Y+1	; 0x01
    1078:	28 2f       	mov	r18, r24
    107a:	30 e0       	ldi	r19, 0x00	; 0
    107c:	81 e0       	ldi	r24, 0x01	; 1
    107e:	90 e0       	ldi	r25, 0x00	; 0
    1080:	02 2e       	mov	r0, r18
    1082:	02 c0       	rjmp	.+4      	; 0x1088 <DIO_PIN_Init+0x176>
    1084:	88 0f       	add	r24, r24
    1086:	99 1f       	adc	r25, r25
    1088:	0a 94       	dec	r0
    108a:	e2 f7       	brpl	.-8      	; 0x1084 <DIO_PIN_Init+0x172>
    108c:	80 95       	com	r24
    108e:	84 23       	and	r24, r20
    1090:	8c 93       	st	X, r24
    1092:	a6 c1       	rjmp	.+844    	; 0x13e0 <DIO_PIN_Init+0x4ce>
				break;

				case PD:
				SET_BIT(DDRD,pin_num);
    1094:	a1 e3       	ldi	r26, 0x31	; 49
    1096:	b0 e0       	ldi	r27, 0x00	; 0
    1098:	e1 e3       	ldi	r30, 0x31	; 49
    109a:	f0 e0       	ldi	r31, 0x00	; 0
    109c:	80 81       	ld	r24, Z
    109e:	48 2f       	mov	r20, r24
    10a0:	89 81       	ldd	r24, Y+1	; 0x01
    10a2:	28 2f       	mov	r18, r24
    10a4:	30 e0       	ldi	r19, 0x00	; 0
    10a6:	81 e0       	ldi	r24, 0x01	; 1
    10a8:	90 e0       	ldi	r25, 0x00	; 0
    10aa:	02 c0       	rjmp	.+4      	; 0x10b0 <DIO_PIN_Init+0x19e>
    10ac:	88 0f       	add	r24, r24
    10ae:	99 1f       	adc	r25, r25
    10b0:	2a 95       	dec	r18
    10b2:	e2 f7       	brpl	.-8      	; 0x10ac <DIO_PIN_Init+0x19a>
    10b4:	84 2b       	or	r24, r20
    10b6:	8c 93       	st	X, r24
				CLR_BIT(PORTD,pin_num);
    10b8:	a2 e3       	ldi	r26, 0x32	; 50
    10ba:	b0 e0       	ldi	r27, 0x00	; 0
    10bc:	e2 e3       	ldi	r30, 0x32	; 50
    10be:	f0 e0       	ldi	r31, 0x00	; 0
    10c0:	80 81       	ld	r24, Z
    10c2:	48 2f       	mov	r20, r24
    10c4:	89 81       	ldd	r24, Y+1	; 0x01
    10c6:	28 2f       	mov	r18, r24
    10c8:	30 e0       	ldi	r19, 0x00	; 0
    10ca:	81 e0       	ldi	r24, 0x01	; 1
    10cc:	90 e0       	ldi	r25, 0x00	; 0
    10ce:	02 2e       	mov	r0, r18
    10d0:	02 c0       	rjmp	.+4      	; 0x10d6 <DIO_PIN_Init+0x1c4>
    10d2:	88 0f       	add	r24, r24
    10d4:	99 1f       	adc	r25, r25
    10d6:	0a 94       	dec	r0
    10d8:	e2 f7       	brpl	.-8      	; 0x10d2 <DIO_PIN_Init+0x1c0>
    10da:	80 95       	com	r24
    10dc:	84 23       	and	r24, r20
    10de:	8c 93       	st	X, r24
    10e0:	7f c1       	rjmp	.+766    	; 0x13e0 <DIO_PIN_Init+0x4ce>
				break;
			}
			break;

			case INFREE:
			switch(port)
    10e2:	8a 81       	ldd	r24, Y+2	; 0x02
    10e4:	28 2f       	mov	r18, r24
    10e6:	30 e0       	ldi	r19, 0x00	; 0
    10e8:	38 87       	std	Y+8, r19	; 0x08
    10ea:	2f 83       	std	Y+7, r18	; 0x07
    10ec:	8f 81       	ldd	r24, Y+7	; 0x07
    10ee:	98 85       	ldd	r25, Y+8	; 0x08
    10f0:	81 30       	cpi	r24, 0x01	; 1
    10f2:	91 05       	cpc	r25, r1
    10f4:	09 f4       	brne	.+2      	; 0x10f8 <DIO_PIN_Init+0x1e6>
    10f6:	3f c0       	rjmp	.+126    	; 0x1176 <DIO_PIN_Init+0x264>
    10f8:	2f 81       	ldd	r18, Y+7	; 0x07
    10fa:	38 85       	ldd	r19, Y+8	; 0x08
    10fc:	22 30       	cpi	r18, 0x02	; 2
    10fe:	31 05       	cpc	r19, r1
    1100:	2c f4       	brge	.+10     	; 0x110c <DIO_PIN_Init+0x1fa>
    1102:	8f 81       	ldd	r24, Y+7	; 0x07
    1104:	98 85       	ldd	r25, Y+8	; 0x08
    1106:	00 97       	sbiw	r24, 0x00	; 0
    1108:	71 f0       	breq	.+28     	; 0x1126 <DIO_PIN_Init+0x214>
    110a:	6a c1       	rjmp	.+724    	; 0x13e0 <DIO_PIN_Init+0x4ce>
    110c:	2f 81       	ldd	r18, Y+7	; 0x07
    110e:	38 85       	ldd	r19, Y+8	; 0x08
    1110:	22 30       	cpi	r18, 0x02	; 2
    1112:	31 05       	cpc	r19, r1
    1114:	09 f4       	brne	.+2      	; 0x1118 <DIO_PIN_Init+0x206>
    1116:	57 c0       	rjmp	.+174    	; 0x11c6 <DIO_PIN_Init+0x2b4>
    1118:	8f 81       	ldd	r24, Y+7	; 0x07
    111a:	98 85       	ldd	r25, Y+8	; 0x08
    111c:	83 30       	cpi	r24, 0x03	; 3
    111e:	91 05       	cpc	r25, r1
    1120:	09 f4       	brne	.+2      	; 0x1124 <DIO_PIN_Init+0x212>
    1122:	79 c0       	rjmp	.+242    	; 0x1216 <DIO_PIN_Init+0x304>
    1124:	5d c1       	rjmp	.+698    	; 0x13e0 <DIO_PIN_Init+0x4ce>
			{
				case PA:
				CLR_BIT(DDRA,pin_num);
    1126:	aa e3       	ldi	r26, 0x3A	; 58
    1128:	b0 e0       	ldi	r27, 0x00	; 0
    112a:	ea e3       	ldi	r30, 0x3A	; 58
    112c:	f0 e0       	ldi	r31, 0x00	; 0
    112e:	80 81       	ld	r24, Z
    1130:	48 2f       	mov	r20, r24
    1132:	89 81       	ldd	r24, Y+1	; 0x01
    1134:	28 2f       	mov	r18, r24
    1136:	30 e0       	ldi	r19, 0x00	; 0
    1138:	81 e0       	ldi	r24, 0x01	; 1
    113a:	90 e0       	ldi	r25, 0x00	; 0
    113c:	02 c0       	rjmp	.+4      	; 0x1142 <DIO_PIN_Init+0x230>
    113e:	88 0f       	add	r24, r24
    1140:	99 1f       	adc	r25, r25
    1142:	2a 95       	dec	r18
    1144:	e2 f7       	brpl	.-8      	; 0x113e <DIO_PIN_Init+0x22c>
    1146:	80 95       	com	r24
    1148:	84 23       	and	r24, r20
    114a:	8c 93       	st	X, r24
				CLR_BIT(PORTA,pin_num);
    114c:	ab e3       	ldi	r26, 0x3B	; 59
    114e:	b0 e0       	ldi	r27, 0x00	; 0
    1150:	eb e3       	ldi	r30, 0x3B	; 59
    1152:	f0 e0       	ldi	r31, 0x00	; 0
    1154:	80 81       	ld	r24, Z
    1156:	48 2f       	mov	r20, r24
    1158:	89 81       	ldd	r24, Y+1	; 0x01
    115a:	28 2f       	mov	r18, r24
    115c:	30 e0       	ldi	r19, 0x00	; 0
    115e:	81 e0       	ldi	r24, 0x01	; 1
    1160:	90 e0       	ldi	r25, 0x00	; 0
    1162:	02 2e       	mov	r0, r18
    1164:	02 c0       	rjmp	.+4      	; 0x116a <DIO_PIN_Init+0x258>
    1166:	88 0f       	add	r24, r24
    1168:	99 1f       	adc	r25, r25
    116a:	0a 94       	dec	r0
    116c:	e2 f7       	brpl	.-8      	; 0x1166 <DIO_PIN_Init+0x254>
    116e:	80 95       	com	r24
    1170:	84 23       	and	r24, r20
    1172:	8c 93       	st	X, r24
    1174:	35 c1       	rjmp	.+618    	; 0x13e0 <DIO_PIN_Init+0x4ce>
				break;

				case PB:
				CLR_BIT(DDRB,pin_num);
    1176:	a7 e3       	ldi	r26, 0x37	; 55
    1178:	b0 e0       	ldi	r27, 0x00	; 0
    117a:	e7 e3       	ldi	r30, 0x37	; 55
    117c:	f0 e0       	ldi	r31, 0x00	; 0
    117e:	80 81       	ld	r24, Z
    1180:	48 2f       	mov	r20, r24
    1182:	89 81       	ldd	r24, Y+1	; 0x01
    1184:	28 2f       	mov	r18, r24
    1186:	30 e0       	ldi	r19, 0x00	; 0
    1188:	81 e0       	ldi	r24, 0x01	; 1
    118a:	90 e0       	ldi	r25, 0x00	; 0
    118c:	02 c0       	rjmp	.+4      	; 0x1192 <DIO_PIN_Init+0x280>
    118e:	88 0f       	add	r24, r24
    1190:	99 1f       	adc	r25, r25
    1192:	2a 95       	dec	r18
    1194:	e2 f7       	brpl	.-8      	; 0x118e <DIO_PIN_Init+0x27c>
    1196:	80 95       	com	r24
    1198:	84 23       	and	r24, r20
    119a:	8c 93       	st	X, r24
				CLR_BIT(PORTB,pin_num);
    119c:	a8 e3       	ldi	r26, 0x38	; 56
    119e:	b0 e0       	ldi	r27, 0x00	; 0
    11a0:	e8 e3       	ldi	r30, 0x38	; 56
    11a2:	f0 e0       	ldi	r31, 0x00	; 0
    11a4:	80 81       	ld	r24, Z
    11a6:	48 2f       	mov	r20, r24
    11a8:	89 81       	ldd	r24, Y+1	; 0x01
    11aa:	28 2f       	mov	r18, r24
    11ac:	30 e0       	ldi	r19, 0x00	; 0
    11ae:	81 e0       	ldi	r24, 0x01	; 1
    11b0:	90 e0       	ldi	r25, 0x00	; 0
    11b2:	02 2e       	mov	r0, r18
    11b4:	02 c0       	rjmp	.+4      	; 0x11ba <DIO_PIN_Init+0x2a8>
    11b6:	88 0f       	add	r24, r24
    11b8:	99 1f       	adc	r25, r25
    11ba:	0a 94       	dec	r0
    11bc:	e2 f7       	brpl	.-8      	; 0x11b6 <DIO_PIN_Init+0x2a4>
    11be:	80 95       	com	r24
    11c0:	84 23       	and	r24, r20
    11c2:	8c 93       	st	X, r24
    11c4:	0d c1       	rjmp	.+538    	; 0x13e0 <DIO_PIN_Init+0x4ce>
				break;

				case PC:
				CLR_BIT(DDRC,pin_num);
    11c6:	a4 e3       	ldi	r26, 0x34	; 52
    11c8:	b0 e0       	ldi	r27, 0x00	; 0
    11ca:	e4 e3       	ldi	r30, 0x34	; 52
    11cc:	f0 e0       	ldi	r31, 0x00	; 0
    11ce:	80 81       	ld	r24, Z
    11d0:	48 2f       	mov	r20, r24
    11d2:	89 81       	ldd	r24, Y+1	; 0x01
    11d4:	28 2f       	mov	r18, r24
    11d6:	30 e0       	ldi	r19, 0x00	; 0
    11d8:	81 e0       	ldi	r24, 0x01	; 1
    11da:	90 e0       	ldi	r25, 0x00	; 0
    11dc:	02 c0       	rjmp	.+4      	; 0x11e2 <DIO_PIN_Init+0x2d0>
    11de:	88 0f       	add	r24, r24
    11e0:	99 1f       	adc	r25, r25
    11e2:	2a 95       	dec	r18
    11e4:	e2 f7       	brpl	.-8      	; 0x11de <DIO_PIN_Init+0x2cc>
    11e6:	80 95       	com	r24
    11e8:	84 23       	and	r24, r20
    11ea:	8c 93       	st	X, r24
				CLR_BIT(PORTC,pin_num);
    11ec:	a5 e3       	ldi	r26, 0x35	; 53
    11ee:	b0 e0       	ldi	r27, 0x00	; 0
    11f0:	e5 e3       	ldi	r30, 0x35	; 53
    11f2:	f0 e0       	ldi	r31, 0x00	; 0
    11f4:	80 81       	ld	r24, Z
    11f6:	48 2f       	mov	r20, r24
    11f8:	89 81       	ldd	r24, Y+1	; 0x01
    11fa:	28 2f       	mov	r18, r24
    11fc:	30 e0       	ldi	r19, 0x00	; 0
    11fe:	81 e0       	ldi	r24, 0x01	; 1
    1200:	90 e0       	ldi	r25, 0x00	; 0
    1202:	02 2e       	mov	r0, r18
    1204:	02 c0       	rjmp	.+4      	; 0x120a <DIO_PIN_Init+0x2f8>
    1206:	88 0f       	add	r24, r24
    1208:	99 1f       	adc	r25, r25
    120a:	0a 94       	dec	r0
    120c:	e2 f7       	brpl	.-8      	; 0x1206 <DIO_PIN_Init+0x2f4>
    120e:	80 95       	com	r24
    1210:	84 23       	and	r24, r20
    1212:	8c 93       	st	X, r24
    1214:	e5 c0       	rjmp	.+458    	; 0x13e0 <DIO_PIN_Init+0x4ce>
				break;

				case PD:
				CLR_BIT(DDRD,pin_num);
    1216:	a1 e3       	ldi	r26, 0x31	; 49
    1218:	b0 e0       	ldi	r27, 0x00	; 0
    121a:	e1 e3       	ldi	r30, 0x31	; 49
    121c:	f0 e0       	ldi	r31, 0x00	; 0
    121e:	80 81       	ld	r24, Z
    1220:	48 2f       	mov	r20, r24
    1222:	89 81       	ldd	r24, Y+1	; 0x01
    1224:	28 2f       	mov	r18, r24
    1226:	30 e0       	ldi	r19, 0x00	; 0
    1228:	81 e0       	ldi	r24, 0x01	; 1
    122a:	90 e0       	ldi	r25, 0x00	; 0
    122c:	02 c0       	rjmp	.+4      	; 0x1232 <DIO_PIN_Init+0x320>
    122e:	88 0f       	add	r24, r24
    1230:	99 1f       	adc	r25, r25
    1232:	2a 95       	dec	r18
    1234:	e2 f7       	brpl	.-8      	; 0x122e <DIO_PIN_Init+0x31c>
    1236:	80 95       	com	r24
    1238:	84 23       	and	r24, r20
    123a:	8c 93       	st	X, r24
				CLR_BIT(PORTD,pin_num);
    123c:	a2 e3       	ldi	r26, 0x32	; 50
    123e:	b0 e0       	ldi	r27, 0x00	; 0
    1240:	e2 e3       	ldi	r30, 0x32	; 50
    1242:	f0 e0       	ldi	r31, 0x00	; 0
    1244:	80 81       	ld	r24, Z
    1246:	48 2f       	mov	r20, r24
    1248:	89 81       	ldd	r24, Y+1	; 0x01
    124a:	28 2f       	mov	r18, r24
    124c:	30 e0       	ldi	r19, 0x00	; 0
    124e:	81 e0       	ldi	r24, 0x01	; 1
    1250:	90 e0       	ldi	r25, 0x00	; 0
    1252:	02 2e       	mov	r0, r18
    1254:	02 c0       	rjmp	.+4      	; 0x125a <DIO_PIN_Init+0x348>
    1256:	88 0f       	add	r24, r24
    1258:	99 1f       	adc	r25, r25
    125a:	0a 94       	dec	r0
    125c:	e2 f7       	brpl	.-8      	; 0x1256 <DIO_PIN_Init+0x344>
    125e:	80 95       	com	r24
    1260:	84 23       	and	r24, r20
    1262:	8c 93       	st	X, r24
    1264:	bd c0       	rjmp	.+378    	; 0x13e0 <DIO_PIN_Init+0x4ce>
				break;
			}
			break;

			case INPULL:
			switch(port)
    1266:	8a 81       	ldd	r24, Y+2	; 0x02
    1268:	28 2f       	mov	r18, r24
    126a:	30 e0       	ldi	r19, 0x00	; 0
    126c:	3e 83       	std	Y+6, r19	; 0x06
    126e:	2d 83       	std	Y+5, r18	; 0x05
    1270:	8d 81       	ldd	r24, Y+5	; 0x05
    1272:	9e 81       	ldd	r25, Y+6	; 0x06
    1274:	81 30       	cpi	r24, 0x01	; 1
    1276:	91 05       	cpc	r25, r1
    1278:	09 f4       	brne	.+2      	; 0x127c <DIO_PIN_Init+0x36a>
    127a:	3e c0       	rjmp	.+124    	; 0x12f8 <DIO_PIN_Init+0x3e6>
    127c:	2d 81       	ldd	r18, Y+5	; 0x05
    127e:	3e 81       	ldd	r19, Y+6	; 0x06
    1280:	22 30       	cpi	r18, 0x02	; 2
    1282:	31 05       	cpc	r19, r1
    1284:	2c f4       	brge	.+10     	; 0x1290 <DIO_PIN_Init+0x37e>
    1286:	8d 81       	ldd	r24, Y+5	; 0x05
    1288:	9e 81       	ldd	r25, Y+6	; 0x06
    128a:	00 97       	sbiw	r24, 0x00	; 0
    128c:	71 f0       	breq	.+28     	; 0x12aa <DIO_PIN_Init+0x398>
    128e:	a8 c0       	rjmp	.+336    	; 0x13e0 <DIO_PIN_Init+0x4ce>
    1290:	2d 81       	ldd	r18, Y+5	; 0x05
    1292:	3e 81       	ldd	r19, Y+6	; 0x06
    1294:	22 30       	cpi	r18, 0x02	; 2
    1296:	31 05       	cpc	r19, r1
    1298:	09 f4       	brne	.+2      	; 0x129c <DIO_PIN_Init+0x38a>
    129a:	55 c0       	rjmp	.+170    	; 0x1346 <DIO_PIN_Init+0x434>
    129c:	8d 81       	ldd	r24, Y+5	; 0x05
    129e:	9e 81       	ldd	r25, Y+6	; 0x06
    12a0:	83 30       	cpi	r24, 0x03	; 3
    12a2:	91 05       	cpc	r25, r1
    12a4:	09 f4       	brne	.+2      	; 0x12a8 <DIO_PIN_Init+0x396>
    12a6:	76 c0       	rjmp	.+236    	; 0x1394 <DIO_PIN_Init+0x482>
    12a8:	9b c0       	rjmp	.+310    	; 0x13e0 <DIO_PIN_Init+0x4ce>
			{
				case PA:
				CLR_BIT(DDRA,pin_num);
    12aa:	aa e3       	ldi	r26, 0x3A	; 58
    12ac:	b0 e0       	ldi	r27, 0x00	; 0
    12ae:	ea e3       	ldi	r30, 0x3A	; 58
    12b0:	f0 e0       	ldi	r31, 0x00	; 0
    12b2:	80 81       	ld	r24, Z
    12b4:	48 2f       	mov	r20, r24
    12b6:	89 81       	ldd	r24, Y+1	; 0x01
    12b8:	28 2f       	mov	r18, r24
    12ba:	30 e0       	ldi	r19, 0x00	; 0
    12bc:	81 e0       	ldi	r24, 0x01	; 1
    12be:	90 e0       	ldi	r25, 0x00	; 0
    12c0:	02 c0       	rjmp	.+4      	; 0x12c6 <DIO_PIN_Init+0x3b4>
    12c2:	88 0f       	add	r24, r24
    12c4:	99 1f       	adc	r25, r25
    12c6:	2a 95       	dec	r18
    12c8:	e2 f7       	brpl	.-8      	; 0x12c2 <DIO_PIN_Init+0x3b0>
    12ca:	80 95       	com	r24
    12cc:	84 23       	and	r24, r20
    12ce:	8c 93       	st	X, r24
				SET_BIT(PORTA,pin_num);
    12d0:	ab e3       	ldi	r26, 0x3B	; 59
    12d2:	b0 e0       	ldi	r27, 0x00	; 0
    12d4:	eb e3       	ldi	r30, 0x3B	; 59
    12d6:	f0 e0       	ldi	r31, 0x00	; 0
    12d8:	80 81       	ld	r24, Z
    12da:	48 2f       	mov	r20, r24
    12dc:	89 81       	ldd	r24, Y+1	; 0x01
    12de:	28 2f       	mov	r18, r24
    12e0:	30 e0       	ldi	r19, 0x00	; 0
    12e2:	81 e0       	ldi	r24, 0x01	; 1
    12e4:	90 e0       	ldi	r25, 0x00	; 0
    12e6:	02 2e       	mov	r0, r18
    12e8:	02 c0       	rjmp	.+4      	; 0x12ee <DIO_PIN_Init+0x3dc>
    12ea:	88 0f       	add	r24, r24
    12ec:	99 1f       	adc	r25, r25
    12ee:	0a 94       	dec	r0
    12f0:	e2 f7       	brpl	.-8      	; 0x12ea <DIO_PIN_Init+0x3d8>
    12f2:	84 2b       	or	r24, r20
    12f4:	8c 93       	st	X, r24
    12f6:	74 c0       	rjmp	.+232    	; 0x13e0 <DIO_PIN_Init+0x4ce>
				break;

				case PB:
				CLR_BIT(DDRB,pin_num);
    12f8:	a7 e3       	ldi	r26, 0x37	; 55
    12fa:	b0 e0       	ldi	r27, 0x00	; 0
    12fc:	e7 e3       	ldi	r30, 0x37	; 55
    12fe:	f0 e0       	ldi	r31, 0x00	; 0
    1300:	80 81       	ld	r24, Z
    1302:	48 2f       	mov	r20, r24
    1304:	89 81       	ldd	r24, Y+1	; 0x01
    1306:	28 2f       	mov	r18, r24
    1308:	30 e0       	ldi	r19, 0x00	; 0
    130a:	81 e0       	ldi	r24, 0x01	; 1
    130c:	90 e0       	ldi	r25, 0x00	; 0
    130e:	02 c0       	rjmp	.+4      	; 0x1314 <DIO_PIN_Init+0x402>
    1310:	88 0f       	add	r24, r24
    1312:	99 1f       	adc	r25, r25
    1314:	2a 95       	dec	r18
    1316:	e2 f7       	brpl	.-8      	; 0x1310 <DIO_PIN_Init+0x3fe>
    1318:	80 95       	com	r24
    131a:	84 23       	and	r24, r20
    131c:	8c 93       	st	X, r24
				SET_BIT(PORTB,pin_num);
    131e:	a8 e3       	ldi	r26, 0x38	; 56
    1320:	b0 e0       	ldi	r27, 0x00	; 0
    1322:	e8 e3       	ldi	r30, 0x38	; 56
    1324:	f0 e0       	ldi	r31, 0x00	; 0
    1326:	80 81       	ld	r24, Z
    1328:	48 2f       	mov	r20, r24
    132a:	89 81       	ldd	r24, Y+1	; 0x01
    132c:	28 2f       	mov	r18, r24
    132e:	30 e0       	ldi	r19, 0x00	; 0
    1330:	81 e0       	ldi	r24, 0x01	; 1
    1332:	90 e0       	ldi	r25, 0x00	; 0
    1334:	02 2e       	mov	r0, r18
    1336:	02 c0       	rjmp	.+4      	; 0x133c <DIO_PIN_Init+0x42a>
    1338:	88 0f       	add	r24, r24
    133a:	99 1f       	adc	r25, r25
    133c:	0a 94       	dec	r0
    133e:	e2 f7       	brpl	.-8      	; 0x1338 <DIO_PIN_Init+0x426>
    1340:	84 2b       	or	r24, r20
    1342:	8c 93       	st	X, r24
    1344:	4d c0       	rjmp	.+154    	; 0x13e0 <DIO_PIN_Init+0x4ce>
				break;

				case PC:
				CLR_BIT(DDRC,pin_num);
    1346:	a4 e3       	ldi	r26, 0x34	; 52
    1348:	b0 e0       	ldi	r27, 0x00	; 0
    134a:	e4 e3       	ldi	r30, 0x34	; 52
    134c:	f0 e0       	ldi	r31, 0x00	; 0
    134e:	80 81       	ld	r24, Z
    1350:	48 2f       	mov	r20, r24
    1352:	89 81       	ldd	r24, Y+1	; 0x01
    1354:	28 2f       	mov	r18, r24
    1356:	30 e0       	ldi	r19, 0x00	; 0
    1358:	81 e0       	ldi	r24, 0x01	; 1
    135a:	90 e0       	ldi	r25, 0x00	; 0
    135c:	02 c0       	rjmp	.+4      	; 0x1362 <DIO_PIN_Init+0x450>
    135e:	88 0f       	add	r24, r24
    1360:	99 1f       	adc	r25, r25
    1362:	2a 95       	dec	r18
    1364:	e2 f7       	brpl	.-8      	; 0x135e <DIO_PIN_Init+0x44c>
    1366:	80 95       	com	r24
    1368:	84 23       	and	r24, r20
    136a:	8c 93       	st	X, r24
				SET_BIT(PORTC,pin_num);
    136c:	a5 e3       	ldi	r26, 0x35	; 53
    136e:	b0 e0       	ldi	r27, 0x00	; 0
    1370:	e5 e3       	ldi	r30, 0x35	; 53
    1372:	f0 e0       	ldi	r31, 0x00	; 0
    1374:	80 81       	ld	r24, Z
    1376:	48 2f       	mov	r20, r24
    1378:	89 81       	ldd	r24, Y+1	; 0x01
    137a:	28 2f       	mov	r18, r24
    137c:	30 e0       	ldi	r19, 0x00	; 0
    137e:	81 e0       	ldi	r24, 0x01	; 1
    1380:	90 e0       	ldi	r25, 0x00	; 0
    1382:	02 2e       	mov	r0, r18
    1384:	02 c0       	rjmp	.+4      	; 0x138a <DIO_PIN_Init+0x478>
    1386:	88 0f       	add	r24, r24
    1388:	99 1f       	adc	r25, r25
    138a:	0a 94       	dec	r0
    138c:	e2 f7       	brpl	.-8      	; 0x1386 <DIO_PIN_Init+0x474>
    138e:	84 2b       	or	r24, r20
    1390:	8c 93       	st	X, r24
    1392:	26 c0       	rjmp	.+76     	; 0x13e0 <DIO_PIN_Init+0x4ce>
				break;

				case PD:
				CLR_BIT(DDRD,pin_num);
    1394:	a1 e3       	ldi	r26, 0x31	; 49
    1396:	b0 e0       	ldi	r27, 0x00	; 0
    1398:	e1 e3       	ldi	r30, 0x31	; 49
    139a:	f0 e0       	ldi	r31, 0x00	; 0
    139c:	80 81       	ld	r24, Z
    139e:	48 2f       	mov	r20, r24
    13a0:	89 81       	ldd	r24, Y+1	; 0x01
    13a2:	28 2f       	mov	r18, r24
    13a4:	30 e0       	ldi	r19, 0x00	; 0
    13a6:	81 e0       	ldi	r24, 0x01	; 1
    13a8:	90 e0       	ldi	r25, 0x00	; 0
    13aa:	02 c0       	rjmp	.+4      	; 0x13b0 <DIO_PIN_Init+0x49e>
    13ac:	88 0f       	add	r24, r24
    13ae:	99 1f       	adc	r25, r25
    13b0:	2a 95       	dec	r18
    13b2:	e2 f7       	brpl	.-8      	; 0x13ac <DIO_PIN_Init+0x49a>
    13b4:	80 95       	com	r24
    13b6:	84 23       	and	r24, r20
    13b8:	8c 93       	st	X, r24
				SET_BIT(PORTD,pin_num);
    13ba:	a2 e3       	ldi	r26, 0x32	; 50
    13bc:	b0 e0       	ldi	r27, 0x00	; 0
    13be:	e2 e3       	ldi	r30, 0x32	; 50
    13c0:	f0 e0       	ldi	r31, 0x00	; 0
    13c2:	80 81       	ld	r24, Z
    13c4:	48 2f       	mov	r20, r24
    13c6:	89 81       	ldd	r24, Y+1	; 0x01
    13c8:	28 2f       	mov	r18, r24
    13ca:	30 e0       	ldi	r19, 0x00	; 0
    13cc:	81 e0       	ldi	r24, 0x01	; 1
    13ce:	90 e0       	ldi	r25, 0x00	; 0
    13d0:	02 2e       	mov	r0, r18
    13d2:	02 c0       	rjmp	.+4      	; 0x13d8 <DIO_PIN_Init+0x4c6>
    13d4:	88 0f       	add	r24, r24
    13d6:	99 1f       	adc	r25, r25
    13d8:	0a 94       	dec	r0
    13da:	e2 f7       	brpl	.-8      	; 0x13d4 <DIO_PIN_Init+0x4c2>
    13dc:	84 2b       	or	r24, r20
    13de:	8c 93       	st	X, r24
				break;
			}
			break;
		}
}
    13e0:	2c 96       	adiw	r28, 0x0c	; 12
    13e2:	0f b6       	in	r0, 0x3f	; 63
    13e4:	f8 94       	cli
    13e6:	de bf       	out	0x3e, r29	; 62
    13e8:	0f be       	out	0x3f, r0	; 63
    13ea:	cd bf       	out	0x3d, r28	; 61
    13ec:	cf 91       	pop	r28
    13ee:	df 91       	pop	r29
    13f0:	08 95       	ret

000013f2 <DIO_WritePin>:




void DIO_WritePin(DIO_Pin_type pin  ,DIO_PinVoltage_Type volt  )
{
    13f2:	df 93       	push	r29
    13f4:	cf 93       	push	r28
    13f6:	cd b7       	in	r28, 0x3d	; 61
    13f8:	de b7       	in	r29, 0x3e	; 62
    13fa:	28 97       	sbiw	r28, 0x08	; 8
    13fc:	0f b6       	in	r0, 0x3f	; 63
    13fe:	f8 94       	cli
    1400:	de bf       	out	0x3e, r29	; 62
    1402:	0f be       	out	0x3f, r0	; 63
    1404:	cd bf       	out	0x3d, r28	; 61
    1406:	8b 83       	std	Y+3, r24	; 0x03
    1408:	6c 83       	std	Y+4, r22	; 0x04
	    DIO_Port_Type port=pin/8;
    140a:	8b 81       	ldd	r24, Y+3	; 0x03
    140c:	86 95       	lsr	r24
    140e:	86 95       	lsr	r24
    1410:	86 95       	lsr	r24
    1412:	8a 83       	std	Y+2, r24	; 0x02
		u8 pin_num=pin%8;
    1414:	8b 81       	ldd	r24, Y+3	; 0x03
    1416:	87 70       	andi	r24, 0x07	; 7
    1418:	89 83       	std	Y+1, r24	; 0x01
	if(volt==HIGH)
    141a:	8c 81       	ldd	r24, Y+4	; 0x04
    141c:	81 30       	cpi	r24, 0x01	; 1
    141e:	09 f0       	breq	.+2      	; 0x1422 <DIO_WritePin+0x30>
    1420:	6e c0       	rjmp	.+220    	; 0x14fe <DIO_WritePin+0x10c>
	{
		switch(port)
    1422:	8a 81       	ldd	r24, Y+2	; 0x02
    1424:	28 2f       	mov	r18, r24
    1426:	30 e0       	ldi	r19, 0x00	; 0
    1428:	38 87       	std	Y+8, r19	; 0x08
    142a:	2f 83       	std	Y+7, r18	; 0x07
    142c:	8f 81       	ldd	r24, Y+7	; 0x07
    142e:	98 85       	ldd	r25, Y+8	; 0x08
    1430:	81 30       	cpi	r24, 0x01	; 1
    1432:	91 05       	cpc	r25, r1
    1434:	49 f1       	breq	.+82     	; 0x1488 <DIO_WritePin+0x96>
    1436:	2f 81       	ldd	r18, Y+7	; 0x07
    1438:	38 85       	ldd	r19, Y+8	; 0x08
    143a:	22 30       	cpi	r18, 0x02	; 2
    143c:	31 05       	cpc	r19, r1
    143e:	2c f4       	brge	.+10     	; 0x144a <DIO_WritePin+0x58>
    1440:	8f 81       	ldd	r24, Y+7	; 0x07
    1442:	98 85       	ldd	r25, Y+8	; 0x08
    1444:	00 97       	sbiw	r24, 0x00	; 0
    1446:	61 f0       	breq	.+24     	; 0x1460 <DIO_WritePin+0x6e>
    1448:	5a c0       	rjmp	.+180    	; 0x14fe <DIO_WritePin+0x10c>
    144a:	2f 81       	ldd	r18, Y+7	; 0x07
    144c:	38 85       	ldd	r19, Y+8	; 0x08
    144e:	22 30       	cpi	r18, 0x02	; 2
    1450:	31 05       	cpc	r19, r1
    1452:	71 f1       	breq	.+92     	; 0x14b0 <DIO_WritePin+0xbe>
    1454:	8f 81       	ldd	r24, Y+7	; 0x07
    1456:	98 85       	ldd	r25, Y+8	; 0x08
    1458:	83 30       	cpi	r24, 0x03	; 3
    145a:	91 05       	cpc	r25, r1
    145c:	e9 f1       	breq	.+122    	; 0x14d8 <DIO_WritePin+0xe6>
    145e:	4f c0       	rjmp	.+158    	; 0x14fe <DIO_WritePin+0x10c>
		{
			case PA:
			SET_BIT(PORTA,pin_num);
    1460:	ab e3       	ldi	r26, 0x3B	; 59
    1462:	b0 e0       	ldi	r27, 0x00	; 0
    1464:	eb e3       	ldi	r30, 0x3B	; 59
    1466:	f0 e0       	ldi	r31, 0x00	; 0
    1468:	80 81       	ld	r24, Z
    146a:	48 2f       	mov	r20, r24
    146c:	89 81       	ldd	r24, Y+1	; 0x01
    146e:	28 2f       	mov	r18, r24
    1470:	30 e0       	ldi	r19, 0x00	; 0
    1472:	81 e0       	ldi	r24, 0x01	; 1
    1474:	90 e0       	ldi	r25, 0x00	; 0
    1476:	02 2e       	mov	r0, r18
    1478:	02 c0       	rjmp	.+4      	; 0x147e <DIO_WritePin+0x8c>
    147a:	88 0f       	add	r24, r24
    147c:	99 1f       	adc	r25, r25
    147e:	0a 94       	dec	r0
    1480:	e2 f7       	brpl	.-8      	; 0x147a <DIO_WritePin+0x88>
    1482:	84 2b       	or	r24, r20
    1484:	8c 93       	st	X, r24
    1486:	3b c0       	rjmp	.+118    	; 0x14fe <DIO_WritePin+0x10c>
			break;
			case PB:
			SET_BIT(PORTB,pin_num);
    1488:	a8 e3       	ldi	r26, 0x38	; 56
    148a:	b0 e0       	ldi	r27, 0x00	; 0
    148c:	e8 e3       	ldi	r30, 0x38	; 56
    148e:	f0 e0       	ldi	r31, 0x00	; 0
    1490:	80 81       	ld	r24, Z
    1492:	48 2f       	mov	r20, r24
    1494:	89 81       	ldd	r24, Y+1	; 0x01
    1496:	28 2f       	mov	r18, r24
    1498:	30 e0       	ldi	r19, 0x00	; 0
    149a:	81 e0       	ldi	r24, 0x01	; 1
    149c:	90 e0       	ldi	r25, 0x00	; 0
    149e:	02 2e       	mov	r0, r18
    14a0:	02 c0       	rjmp	.+4      	; 0x14a6 <DIO_WritePin+0xb4>
    14a2:	88 0f       	add	r24, r24
    14a4:	99 1f       	adc	r25, r25
    14a6:	0a 94       	dec	r0
    14a8:	e2 f7       	brpl	.-8      	; 0x14a2 <DIO_WritePin+0xb0>
    14aa:	84 2b       	or	r24, r20
    14ac:	8c 93       	st	X, r24
    14ae:	27 c0       	rjmp	.+78     	; 0x14fe <DIO_WritePin+0x10c>
			break;
			case PC:
			SET_BIT(PORTC,pin_num);
    14b0:	a5 e3       	ldi	r26, 0x35	; 53
    14b2:	b0 e0       	ldi	r27, 0x00	; 0
    14b4:	e5 e3       	ldi	r30, 0x35	; 53
    14b6:	f0 e0       	ldi	r31, 0x00	; 0
    14b8:	80 81       	ld	r24, Z
    14ba:	48 2f       	mov	r20, r24
    14bc:	89 81       	ldd	r24, Y+1	; 0x01
    14be:	28 2f       	mov	r18, r24
    14c0:	30 e0       	ldi	r19, 0x00	; 0
    14c2:	81 e0       	ldi	r24, 0x01	; 1
    14c4:	90 e0       	ldi	r25, 0x00	; 0
    14c6:	02 2e       	mov	r0, r18
    14c8:	02 c0       	rjmp	.+4      	; 0x14ce <DIO_WritePin+0xdc>
    14ca:	88 0f       	add	r24, r24
    14cc:	99 1f       	adc	r25, r25
    14ce:	0a 94       	dec	r0
    14d0:	e2 f7       	brpl	.-8      	; 0x14ca <DIO_WritePin+0xd8>
    14d2:	84 2b       	or	r24, r20
    14d4:	8c 93       	st	X, r24
    14d6:	13 c0       	rjmp	.+38     	; 0x14fe <DIO_WritePin+0x10c>
			break;
			case PD:
			SET_BIT(PORTD,pin_num);
    14d8:	a2 e3       	ldi	r26, 0x32	; 50
    14da:	b0 e0       	ldi	r27, 0x00	; 0
    14dc:	e2 e3       	ldi	r30, 0x32	; 50
    14de:	f0 e0       	ldi	r31, 0x00	; 0
    14e0:	80 81       	ld	r24, Z
    14e2:	48 2f       	mov	r20, r24
    14e4:	89 81       	ldd	r24, Y+1	; 0x01
    14e6:	28 2f       	mov	r18, r24
    14e8:	30 e0       	ldi	r19, 0x00	; 0
    14ea:	81 e0       	ldi	r24, 0x01	; 1
    14ec:	90 e0       	ldi	r25, 0x00	; 0
    14ee:	02 2e       	mov	r0, r18
    14f0:	02 c0       	rjmp	.+4      	; 0x14f6 <DIO_WritePin+0x104>
    14f2:	88 0f       	add	r24, r24
    14f4:	99 1f       	adc	r25, r25
    14f6:	0a 94       	dec	r0
    14f8:	e2 f7       	brpl	.-8      	; 0x14f2 <DIO_WritePin+0x100>
    14fa:	84 2b       	or	r24, r20
    14fc:	8c 93       	st	X, r24
			break;
		}

	}
	if(volt==LOW)
    14fe:	8c 81       	ldd	r24, Y+4	; 0x04
    1500:	88 23       	and	r24, r24
    1502:	09 f0       	breq	.+2      	; 0x1506 <DIO_WritePin+0x114>
    1504:	73 c0       	rjmp	.+230    	; 0x15ec <DIO_WritePin+0x1fa>
	{
		switch(port)
    1506:	8a 81       	ldd	r24, Y+2	; 0x02
    1508:	28 2f       	mov	r18, r24
    150a:	30 e0       	ldi	r19, 0x00	; 0
    150c:	3e 83       	std	Y+6, r19	; 0x06
    150e:	2d 83       	std	Y+5, r18	; 0x05
    1510:	8d 81       	ldd	r24, Y+5	; 0x05
    1512:	9e 81       	ldd	r25, Y+6	; 0x06
    1514:	81 30       	cpi	r24, 0x01	; 1
    1516:	91 05       	cpc	r25, r1
    1518:	59 f1       	breq	.+86     	; 0x1570 <DIO_WritePin+0x17e>
    151a:	2d 81       	ldd	r18, Y+5	; 0x05
    151c:	3e 81       	ldd	r19, Y+6	; 0x06
    151e:	22 30       	cpi	r18, 0x02	; 2
    1520:	31 05       	cpc	r19, r1
    1522:	2c f4       	brge	.+10     	; 0x152e <DIO_WritePin+0x13c>
    1524:	8d 81       	ldd	r24, Y+5	; 0x05
    1526:	9e 81       	ldd	r25, Y+6	; 0x06
    1528:	00 97       	sbiw	r24, 0x00	; 0
    152a:	69 f0       	breq	.+26     	; 0x1546 <DIO_WritePin+0x154>
    152c:	5f c0       	rjmp	.+190    	; 0x15ec <DIO_WritePin+0x1fa>
    152e:	2d 81       	ldd	r18, Y+5	; 0x05
    1530:	3e 81       	ldd	r19, Y+6	; 0x06
    1532:	22 30       	cpi	r18, 0x02	; 2
    1534:	31 05       	cpc	r19, r1
    1536:	89 f1       	breq	.+98     	; 0x159a <DIO_WritePin+0x1a8>
    1538:	8d 81       	ldd	r24, Y+5	; 0x05
    153a:	9e 81       	ldd	r25, Y+6	; 0x06
    153c:	83 30       	cpi	r24, 0x03	; 3
    153e:	91 05       	cpc	r25, r1
    1540:	09 f4       	brne	.+2      	; 0x1544 <DIO_WritePin+0x152>
    1542:	40 c0       	rjmp	.+128    	; 0x15c4 <DIO_WritePin+0x1d2>
    1544:	53 c0       	rjmp	.+166    	; 0x15ec <DIO_WritePin+0x1fa>
		{
			case PA:
			CLR_BIT(PORTA,pin_num);
    1546:	ab e3       	ldi	r26, 0x3B	; 59
    1548:	b0 e0       	ldi	r27, 0x00	; 0
    154a:	eb e3       	ldi	r30, 0x3B	; 59
    154c:	f0 e0       	ldi	r31, 0x00	; 0
    154e:	80 81       	ld	r24, Z
    1550:	48 2f       	mov	r20, r24
    1552:	89 81       	ldd	r24, Y+1	; 0x01
    1554:	28 2f       	mov	r18, r24
    1556:	30 e0       	ldi	r19, 0x00	; 0
    1558:	81 e0       	ldi	r24, 0x01	; 1
    155a:	90 e0       	ldi	r25, 0x00	; 0
    155c:	02 2e       	mov	r0, r18
    155e:	02 c0       	rjmp	.+4      	; 0x1564 <DIO_WritePin+0x172>
    1560:	88 0f       	add	r24, r24
    1562:	99 1f       	adc	r25, r25
    1564:	0a 94       	dec	r0
    1566:	e2 f7       	brpl	.-8      	; 0x1560 <DIO_WritePin+0x16e>
    1568:	80 95       	com	r24
    156a:	84 23       	and	r24, r20
    156c:	8c 93       	st	X, r24
    156e:	3e c0       	rjmp	.+124    	; 0x15ec <DIO_WritePin+0x1fa>
			break;
			case PB:
			CLR_BIT(PORTB,pin_num);
    1570:	a8 e3       	ldi	r26, 0x38	; 56
    1572:	b0 e0       	ldi	r27, 0x00	; 0
    1574:	e8 e3       	ldi	r30, 0x38	; 56
    1576:	f0 e0       	ldi	r31, 0x00	; 0
    1578:	80 81       	ld	r24, Z
    157a:	48 2f       	mov	r20, r24
    157c:	89 81       	ldd	r24, Y+1	; 0x01
    157e:	28 2f       	mov	r18, r24
    1580:	30 e0       	ldi	r19, 0x00	; 0
    1582:	81 e0       	ldi	r24, 0x01	; 1
    1584:	90 e0       	ldi	r25, 0x00	; 0
    1586:	02 2e       	mov	r0, r18
    1588:	02 c0       	rjmp	.+4      	; 0x158e <DIO_WritePin+0x19c>
    158a:	88 0f       	add	r24, r24
    158c:	99 1f       	adc	r25, r25
    158e:	0a 94       	dec	r0
    1590:	e2 f7       	brpl	.-8      	; 0x158a <DIO_WritePin+0x198>
    1592:	80 95       	com	r24
    1594:	84 23       	and	r24, r20
    1596:	8c 93       	st	X, r24
    1598:	29 c0       	rjmp	.+82     	; 0x15ec <DIO_WritePin+0x1fa>
			break;
			case PC:
			CLR_BIT(PORTC,pin_num);
    159a:	a5 e3       	ldi	r26, 0x35	; 53
    159c:	b0 e0       	ldi	r27, 0x00	; 0
    159e:	e5 e3       	ldi	r30, 0x35	; 53
    15a0:	f0 e0       	ldi	r31, 0x00	; 0
    15a2:	80 81       	ld	r24, Z
    15a4:	48 2f       	mov	r20, r24
    15a6:	89 81       	ldd	r24, Y+1	; 0x01
    15a8:	28 2f       	mov	r18, r24
    15aa:	30 e0       	ldi	r19, 0x00	; 0
    15ac:	81 e0       	ldi	r24, 0x01	; 1
    15ae:	90 e0       	ldi	r25, 0x00	; 0
    15b0:	02 2e       	mov	r0, r18
    15b2:	02 c0       	rjmp	.+4      	; 0x15b8 <DIO_WritePin+0x1c6>
    15b4:	88 0f       	add	r24, r24
    15b6:	99 1f       	adc	r25, r25
    15b8:	0a 94       	dec	r0
    15ba:	e2 f7       	brpl	.-8      	; 0x15b4 <DIO_WritePin+0x1c2>
    15bc:	80 95       	com	r24
    15be:	84 23       	and	r24, r20
    15c0:	8c 93       	st	X, r24
    15c2:	14 c0       	rjmp	.+40     	; 0x15ec <DIO_WritePin+0x1fa>
			break;
			case PD:
			CLR_BIT(PORTD,pin_num);
    15c4:	a2 e3       	ldi	r26, 0x32	; 50
    15c6:	b0 e0       	ldi	r27, 0x00	; 0
    15c8:	e2 e3       	ldi	r30, 0x32	; 50
    15ca:	f0 e0       	ldi	r31, 0x00	; 0
    15cc:	80 81       	ld	r24, Z
    15ce:	48 2f       	mov	r20, r24
    15d0:	89 81       	ldd	r24, Y+1	; 0x01
    15d2:	28 2f       	mov	r18, r24
    15d4:	30 e0       	ldi	r19, 0x00	; 0
    15d6:	81 e0       	ldi	r24, 0x01	; 1
    15d8:	90 e0       	ldi	r25, 0x00	; 0
    15da:	02 2e       	mov	r0, r18
    15dc:	02 c0       	rjmp	.+4      	; 0x15e2 <DIO_WritePin+0x1f0>
    15de:	88 0f       	add	r24, r24
    15e0:	99 1f       	adc	r25, r25
    15e2:	0a 94       	dec	r0
    15e4:	e2 f7       	brpl	.-8      	; 0x15de <DIO_WritePin+0x1ec>
    15e6:	80 95       	com	r24
    15e8:	84 23       	and	r24, r20
    15ea:	8c 93       	st	X, r24
			break;
		}

	}

}
    15ec:	28 96       	adiw	r28, 0x08	; 8
    15ee:	0f b6       	in	r0, 0x3f	; 63
    15f0:	f8 94       	cli
    15f2:	de bf       	out	0x3e, r29	; 62
    15f4:	0f be       	out	0x3f, r0	; 63
    15f6:	cd bf       	out	0x3d, r28	; 61
    15f8:	cf 91       	pop	r28
    15fa:	df 91       	pop	r29
    15fc:	08 95       	ret

000015fe <DIO_ReadPin>:

DIO_PinVoltage_Type DIO_ReadPin(DIO_Pin_type pin )
{
    15fe:	df 93       	push	r29
    1600:	cf 93       	push	r28
    1602:	00 d0       	rcall	.+0      	; 0x1604 <DIO_ReadPin+0x6>
    1604:	00 d0       	rcall	.+0      	; 0x1606 <DIO_ReadPin+0x8>
    1606:	00 d0       	rcall	.+0      	; 0x1608 <DIO_ReadPin+0xa>
    1608:	cd b7       	in	r28, 0x3d	; 61
    160a:	de b7       	in	r29, 0x3e	; 62
    160c:	8c 83       	std	Y+4, r24	; 0x04

	  DIO_Port_Type port=pin/8;
    160e:	8c 81       	ldd	r24, Y+4	; 0x04
    1610:	86 95       	lsr	r24
    1612:	86 95       	lsr	r24
    1614:	86 95       	lsr	r24
    1616:	8b 83       	std	Y+3, r24	; 0x03
	  u8 pin_num=pin%8;
    1618:	8c 81       	ldd	r24, Y+4	; 0x04
    161a:	87 70       	andi	r24, 0x07	; 7
    161c:	8a 83       	std	Y+2, r24	; 0x02
	  DIO_PinVoltage_Type volt=LOW;
    161e:	19 82       	std	Y+1, r1	; 0x01

		switch(port)
    1620:	8b 81       	ldd	r24, Y+3	; 0x03
    1622:	28 2f       	mov	r18, r24
    1624:	30 e0       	ldi	r19, 0x00	; 0
    1626:	3e 83       	std	Y+6, r19	; 0x06
    1628:	2d 83       	std	Y+5, r18	; 0x05
    162a:	4d 81       	ldd	r20, Y+5	; 0x05
    162c:	5e 81       	ldd	r21, Y+6	; 0x06
    162e:	41 30       	cpi	r20, 0x01	; 1
    1630:	51 05       	cpc	r21, r1
    1632:	41 f1       	breq	.+80     	; 0x1684 <DIO_ReadPin+0x86>
    1634:	8d 81       	ldd	r24, Y+5	; 0x05
    1636:	9e 81       	ldd	r25, Y+6	; 0x06
    1638:	82 30       	cpi	r24, 0x02	; 2
    163a:	91 05       	cpc	r25, r1
    163c:	34 f4       	brge	.+12     	; 0x164a <DIO_ReadPin+0x4c>
    163e:	2d 81       	ldd	r18, Y+5	; 0x05
    1640:	3e 81       	ldd	r19, Y+6	; 0x06
    1642:	21 15       	cp	r18, r1
    1644:	31 05       	cpc	r19, r1
    1646:	61 f0       	breq	.+24     	; 0x1660 <DIO_ReadPin+0x62>
    1648:	52 c0       	rjmp	.+164    	; 0x16ee <DIO_ReadPin+0xf0>
    164a:	4d 81       	ldd	r20, Y+5	; 0x05
    164c:	5e 81       	ldd	r21, Y+6	; 0x06
    164e:	42 30       	cpi	r20, 0x02	; 2
    1650:	51 05       	cpc	r21, r1
    1652:	51 f1       	breq	.+84     	; 0x16a8 <DIO_ReadPin+0xaa>
    1654:	8d 81       	ldd	r24, Y+5	; 0x05
    1656:	9e 81       	ldd	r25, Y+6	; 0x06
    1658:	83 30       	cpi	r24, 0x03	; 3
    165a:	91 05       	cpc	r25, r1
    165c:	b9 f1       	breq	.+110    	; 0x16cc <DIO_ReadPin+0xce>
    165e:	47 c0       	rjmp	.+142    	; 0x16ee <DIO_ReadPin+0xf0>
		{
			case PA:
			volt=(DIO_PinVoltage_Type)READ_BIT(PINA,pin_num);
    1660:	e9 e3       	ldi	r30, 0x39	; 57
    1662:	f0 e0       	ldi	r31, 0x00	; 0
    1664:	80 81       	ld	r24, Z
    1666:	28 2f       	mov	r18, r24
    1668:	30 e0       	ldi	r19, 0x00	; 0
    166a:	8a 81       	ldd	r24, Y+2	; 0x02
    166c:	88 2f       	mov	r24, r24
    166e:	90 e0       	ldi	r25, 0x00	; 0
    1670:	a9 01       	movw	r20, r18
    1672:	02 c0       	rjmp	.+4      	; 0x1678 <DIO_ReadPin+0x7a>
    1674:	55 95       	asr	r21
    1676:	47 95       	ror	r20
    1678:	8a 95       	dec	r24
    167a:	e2 f7       	brpl	.-8      	; 0x1674 <DIO_ReadPin+0x76>
    167c:	ca 01       	movw	r24, r20
    167e:	81 70       	andi	r24, 0x01	; 1
    1680:	89 83       	std	Y+1, r24	; 0x01
    1682:	35 c0       	rjmp	.+106    	; 0x16ee <DIO_ReadPin+0xf0>
			break;
			case PB:
			volt=(DIO_PinVoltage_Type)READ_BIT(PINB,pin_num);
    1684:	e6 e3       	ldi	r30, 0x36	; 54
    1686:	f0 e0       	ldi	r31, 0x00	; 0
    1688:	80 81       	ld	r24, Z
    168a:	28 2f       	mov	r18, r24
    168c:	30 e0       	ldi	r19, 0x00	; 0
    168e:	8a 81       	ldd	r24, Y+2	; 0x02
    1690:	88 2f       	mov	r24, r24
    1692:	90 e0       	ldi	r25, 0x00	; 0
    1694:	a9 01       	movw	r20, r18
    1696:	02 c0       	rjmp	.+4      	; 0x169c <DIO_ReadPin+0x9e>
    1698:	55 95       	asr	r21
    169a:	47 95       	ror	r20
    169c:	8a 95       	dec	r24
    169e:	e2 f7       	brpl	.-8      	; 0x1698 <DIO_ReadPin+0x9a>
    16a0:	ca 01       	movw	r24, r20
    16a2:	81 70       	andi	r24, 0x01	; 1
    16a4:	89 83       	std	Y+1, r24	; 0x01
    16a6:	23 c0       	rjmp	.+70     	; 0x16ee <DIO_ReadPin+0xf0>
			break;
			case PC:
			volt=(DIO_PinVoltage_Type)READ_BIT(PINC,pin_num);
    16a8:	e3 e3       	ldi	r30, 0x33	; 51
    16aa:	f0 e0       	ldi	r31, 0x00	; 0
    16ac:	80 81       	ld	r24, Z
    16ae:	28 2f       	mov	r18, r24
    16b0:	30 e0       	ldi	r19, 0x00	; 0
    16b2:	8a 81       	ldd	r24, Y+2	; 0x02
    16b4:	88 2f       	mov	r24, r24
    16b6:	90 e0       	ldi	r25, 0x00	; 0
    16b8:	a9 01       	movw	r20, r18
    16ba:	02 c0       	rjmp	.+4      	; 0x16c0 <DIO_ReadPin+0xc2>
    16bc:	55 95       	asr	r21
    16be:	47 95       	ror	r20
    16c0:	8a 95       	dec	r24
    16c2:	e2 f7       	brpl	.-8      	; 0x16bc <DIO_ReadPin+0xbe>
    16c4:	ca 01       	movw	r24, r20
    16c6:	81 70       	andi	r24, 0x01	; 1
    16c8:	89 83       	std	Y+1, r24	; 0x01
    16ca:	11 c0       	rjmp	.+34     	; 0x16ee <DIO_ReadPin+0xf0>
			break;
			case PD:
			volt=(DIO_PinVoltage_Type)READ_BIT(PIND,pin_num);
    16cc:	e0 e3       	ldi	r30, 0x30	; 48
    16ce:	f0 e0       	ldi	r31, 0x00	; 0
    16d0:	80 81       	ld	r24, Z
    16d2:	28 2f       	mov	r18, r24
    16d4:	30 e0       	ldi	r19, 0x00	; 0
    16d6:	8a 81       	ldd	r24, Y+2	; 0x02
    16d8:	88 2f       	mov	r24, r24
    16da:	90 e0       	ldi	r25, 0x00	; 0
    16dc:	a9 01       	movw	r20, r18
    16de:	02 c0       	rjmp	.+4      	; 0x16e4 <DIO_ReadPin+0xe6>
    16e0:	55 95       	asr	r21
    16e2:	47 95       	ror	r20
    16e4:	8a 95       	dec	r24
    16e6:	e2 f7       	brpl	.-8      	; 0x16e0 <DIO_ReadPin+0xe2>
    16e8:	ca 01       	movw	r24, r20
    16ea:	81 70       	andi	r24, 0x01	; 1
    16ec:	89 83       	std	Y+1, r24	; 0x01
			break;
		}

		return volt;
    16ee:	89 81       	ldd	r24, Y+1	; 0x01
}
    16f0:	26 96       	adiw	r28, 0x06	; 6
    16f2:	0f b6       	in	r0, 0x3f	; 63
    16f4:	f8 94       	cli
    16f6:	de bf       	out	0x3e, r29	; 62
    16f8:	0f be       	out	0x3f, r0	; 63
    16fa:	cd bf       	out	0x3d, r28	; 61
    16fc:	cf 91       	pop	r28
    16fe:	df 91       	pop	r29
    1700:	08 95       	ret

00001702 <DIO_TogglePin>:

void DIO_TogglePin(DIO_Pin_type pin)
{
    1702:	df 93       	push	r29
    1704:	cf 93       	push	r28
    1706:	00 d0       	rcall	.+0      	; 0x1708 <DIO_TogglePin+0x6>
    1708:	00 d0       	rcall	.+0      	; 0x170a <DIO_TogglePin+0x8>
    170a:	0f 92       	push	r0
    170c:	cd b7       	in	r28, 0x3d	; 61
    170e:	de b7       	in	r29, 0x3e	; 62
    1710:	8b 83       	std	Y+3, r24	; 0x03
	DIO_Port_Type port=pin/8;
    1712:	8b 81       	ldd	r24, Y+3	; 0x03
    1714:	86 95       	lsr	r24
    1716:	86 95       	lsr	r24
    1718:	86 95       	lsr	r24
    171a:	8a 83       	std	Y+2, r24	; 0x02
	u8 pin_num=pin%8;
    171c:	8b 81       	ldd	r24, Y+3	; 0x03
    171e:	87 70       	andi	r24, 0x07	; 7
    1720:	89 83       	std	Y+1, r24	; 0x01

	switch(port)
    1722:	8a 81       	ldd	r24, Y+2	; 0x02
    1724:	28 2f       	mov	r18, r24
    1726:	30 e0       	ldi	r19, 0x00	; 0
    1728:	3d 83       	std	Y+5, r19	; 0x05
    172a:	2c 83       	std	Y+4, r18	; 0x04
    172c:	8c 81       	ldd	r24, Y+4	; 0x04
    172e:	9d 81       	ldd	r25, Y+5	; 0x05
    1730:	81 30       	cpi	r24, 0x01	; 1
    1732:	91 05       	cpc	r25, r1
    1734:	49 f1       	breq	.+82     	; 0x1788 <DIO_TogglePin+0x86>
    1736:	2c 81       	ldd	r18, Y+4	; 0x04
    1738:	3d 81       	ldd	r19, Y+5	; 0x05
    173a:	22 30       	cpi	r18, 0x02	; 2
    173c:	31 05       	cpc	r19, r1
    173e:	2c f4       	brge	.+10     	; 0x174a <DIO_TogglePin+0x48>
    1740:	8c 81       	ldd	r24, Y+4	; 0x04
    1742:	9d 81       	ldd	r25, Y+5	; 0x05
    1744:	00 97       	sbiw	r24, 0x00	; 0
    1746:	61 f0       	breq	.+24     	; 0x1760 <DIO_TogglePin+0x5e>
    1748:	5a c0       	rjmp	.+180    	; 0x17fe <DIO_TogglePin+0xfc>
    174a:	2c 81       	ldd	r18, Y+4	; 0x04
    174c:	3d 81       	ldd	r19, Y+5	; 0x05
    174e:	22 30       	cpi	r18, 0x02	; 2
    1750:	31 05       	cpc	r19, r1
    1752:	71 f1       	breq	.+92     	; 0x17b0 <DIO_TogglePin+0xae>
    1754:	8c 81       	ldd	r24, Y+4	; 0x04
    1756:	9d 81       	ldd	r25, Y+5	; 0x05
    1758:	83 30       	cpi	r24, 0x03	; 3
    175a:	91 05       	cpc	r25, r1
    175c:	e9 f1       	breq	.+122    	; 0x17d8 <DIO_TogglePin+0xd6>
    175e:	4f c0       	rjmp	.+158    	; 0x17fe <DIO_TogglePin+0xfc>
	{
		case PA:
		TGL_BIT(PORTA,pin_num);
    1760:	ab e3       	ldi	r26, 0x3B	; 59
    1762:	b0 e0       	ldi	r27, 0x00	; 0
    1764:	eb e3       	ldi	r30, 0x3B	; 59
    1766:	f0 e0       	ldi	r31, 0x00	; 0
    1768:	80 81       	ld	r24, Z
    176a:	48 2f       	mov	r20, r24
    176c:	89 81       	ldd	r24, Y+1	; 0x01
    176e:	28 2f       	mov	r18, r24
    1770:	30 e0       	ldi	r19, 0x00	; 0
    1772:	81 e0       	ldi	r24, 0x01	; 1
    1774:	90 e0       	ldi	r25, 0x00	; 0
    1776:	02 2e       	mov	r0, r18
    1778:	02 c0       	rjmp	.+4      	; 0x177e <DIO_TogglePin+0x7c>
    177a:	88 0f       	add	r24, r24
    177c:	99 1f       	adc	r25, r25
    177e:	0a 94       	dec	r0
    1780:	e2 f7       	brpl	.-8      	; 0x177a <DIO_TogglePin+0x78>
    1782:	84 27       	eor	r24, r20
    1784:	8c 93       	st	X, r24
    1786:	3b c0       	rjmp	.+118    	; 0x17fe <DIO_TogglePin+0xfc>
		break;
		case PB:
		TGL_BIT(PORTB,pin_num);
    1788:	a8 e3       	ldi	r26, 0x38	; 56
    178a:	b0 e0       	ldi	r27, 0x00	; 0
    178c:	e8 e3       	ldi	r30, 0x38	; 56
    178e:	f0 e0       	ldi	r31, 0x00	; 0
    1790:	80 81       	ld	r24, Z
    1792:	48 2f       	mov	r20, r24
    1794:	89 81       	ldd	r24, Y+1	; 0x01
    1796:	28 2f       	mov	r18, r24
    1798:	30 e0       	ldi	r19, 0x00	; 0
    179a:	81 e0       	ldi	r24, 0x01	; 1
    179c:	90 e0       	ldi	r25, 0x00	; 0
    179e:	02 2e       	mov	r0, r18
    17a0:	02 c0       	rjmp	.+4      	; 0x17a6 <DIO_TogglePin+0xa4>
    17a2:	88 0f       	add	r24, r24
    17a4:	99 1f       	adc	r25, r25
    17a6:	0a 94       	dec	r0
    17a8:	e2 f7       	brpl	.-8      	; 0x17a2 <DIO_TogglePin+0xa0>
    17aa:	84 27       	eor	r24, r20
    17ac:	8c 93       	st	X, r24
    17ae:	27 c0       	rjmp	.+78     	; 0x17fe <DIO_TogglePin+0xfc>
		break;
		case PC:
		TGL_BIT(PORTC,pin_num);
    17b0:	a5 e3       	ldi	r26, 0x35	; 53
    17b2:	b0 e0       	ldi	r27, 0x00	; 0
    17b4:	e5 e3       	ldi	r30, 0x35	; 53
    17b6:	f0 e0       	ldi	r31, 0x00	; 0
    17b8:	80 81       	ld	r24, Z
    17ba:	48 2f       	mov	r20, r24
    17bc:	89 81       	ldd	r24, Y+1	; 0x01
    17be:	28 2f       	mov	r18, r24
    17c0:	30 e0       	ldi	r19, 0x00	; 0
    17c2:	81 e0       	ldi	r24, 0x01	; 1
    17c4:	90 e0       	ldi	r25, 0x00	; 0
    17c6:	02 2e       	mov	r0, r18
    17c8:	02 c0       	rjmp	.+4      	; 0x17ce <DIO_TogglePin+0xcc>
    17ca:	88 0f       	add	r24, r24
    17cc:	99 1f       	adc	r25, r25
    17ce:	0a 94       	dec	r0
    17d0:	e2 f7       	brpl	.-8      	; 0x17ca <DIO_TogglePin+0xc8>
    17d2:	84 27       	eor	r24, r20
    17d4:	8c 93       	st	X, r24
    17d6:	13 c0       	rjmp	.+38     	; 0x17fe <DIO_TogglePin+0xfc>
		break;
		case PD:
		TGL_BIT(PORTD,pin_num);
    17d8:	a2 e3       	ldi	r26, 0x32	; 50
    17da:	b0 e0       	ldi	r27, 0x00	; 0
    17dc:	e2 e3       	ldi	r30, 0x32	; 50
    17de:	f0 e0       	ldi	r31, 0x00	; 0
    17e0:	80 81       	ld	r24, Z
    17e2:	48 2f       	mov	r20, r24
    17e4:	89 81       	ldd	r24, Y+1	; 0x01
    17e6:	28 2f       	mov	r18, r24
    17e8:	30 e0       	ldi	r19, 0x00	; 0
    17ea:	81 e0       	ldi	r24, 0x01	; 1
    17ec:	90 e0       	ldi	r25, 0x00	; 0
    17ee:	02 2e       	mov	r0, r18
    17f0:	02 c0       	rjmp	.+4      	; 0x17f6 <DIO_TogglePin+0xf4>
    17f2:	88 0f       	add	r24, r24
    17f4:	99 1f       	adc	r25, r25
    17f6:	0a 94       	dec	r0
    17f8:	e2 f7       	brpl	.-8      	; 0x17f2 <DIO_TogglePin+0xf0>
    17fa:	84 27       	eor	r24, r20
    17fc:	8c 93       	st	X, r24
		break;
	}
}
    17fe:	0f 90       	pop	r0
    1800:	0f 90       	pop	r0
    1802:	0f 90       	pop	r0
    1804:	0f 90       	pop	r0
    1806:	0f 90       	pop	r0
    1808:	cf 91       	pop	r28
    180a:	df 91       	pop	r29
    180c:	08 95       	ret

0000180e <DIO_Init>:

void DIO_Init(void)
{
    180e:	df 93       	push	r29
    1810:	cf 93       	push	r28
    1812:	0f 92       	push	r0
    1814:	cd b7       	in	r28, 0x3d	; 61
    1816:	de b7       	in	r29, 0x3e	; 62

	DIO_Pin_type i;
	for(i=0;i<TOTAL_PINS;i++)
    1818:	19 82       	std	Y+1, r1	; 0x01
    181a:	0e c0       	rjmp	.+28     	; 0x1838 <DIO_Init+0x2a>
	{
		DIO_PIN_Init(i,PinsStatusArray[i]);
    181c:	89 81       	ldd	r24, Y+1	; 0x01
    181e:	88 2f       	mov	r24, r24
    1820:	90 e0       	ldi	r25, 0x00	; 0
    1822:	fc 01       	movw	r30, r24
    1824:	e9 51       	subi	r30, 0x19	; 25
    1826:	ff 4f       	sbci	r31, 0xFF	; 255
    1828:	90 81       	ld	r25, Z
    182a:	89 81       	ldd	r24, Y+1	; 0x01
    182c:	69 2f       	mov	r22, r25
    182e:	0e 94 89 07 	call	0xf12	; 0xf12 <DIO_PIN_Init>

void DIO_Init(void)
{

	DIO_Pin_type i;
	for(i=0;i<TOTAL_PINS;i++)
    1832:	89 81       	ldd	r24, Y+1	; 0x01
    1834:	8f 5f       	subi	r24, 0xFF	; 255
    1836:	89 83       	std	Y+1, r24	; 0x01
    1838:	89 81       	ldd	r24, Y+1	; 0x01
    183a:	80 32       	cpi	r24, 0x20	; 32
    183c:	78 f3       	brcs	.-34     	; 0x181c <DIO_Init+0xe>
	{
		DIO_PIN_Init(i,PinsStatusArray[i]);
	}

}
    183e:	0f 90       	pop	r0
    1840:	cf 91       	pop	r28
    1842:	df 91       	pop	r29
    1844:	08 95       	ret

00001846 <DIO_WritePort>:


void DIO_WritePort(DIO_Port_Type port,u8 data)
{
    1846:	df 93       	push	r29
    1848:	cf 93       	push	r28
    184a:	00 d0       	rcall	.+0      	; 0x184c <DIO_WritePort+0x6>
    184c:	00 d0       	rcall	.+0      	; 0x184e <DIO_WritePort+0x8>
    184e:	cd b7       	in	r28, 0x3d	; 61
    1850:	de b7       	in	r29, 0x3e	; 62
    1852:	89 83       	std	Y+1, r24	; 0x01
    1854:	6a 83       	std	Y+2, r22	; 0x02
	switch(port)
    1856:	89 81       	ldd	r24, Y+1	; 0x01
    1858:	28 2f       	mov	r18, r24
    185a:	30 e0       	ldi	r19, 0x00	; 0
    185c:	3c 83       	std	Y+4, r19	; 0x04
    185e:	2b 83       	std	Y+3, r18	; 0x03
    1860:	8b 81       	ldd	r24, Y+3	; 0x03
    1862:	9c 81       	ldd	r25, Y+4	; 0x04
    1864:	81 30       	cpi	r24, 0x01	; 1
    1866:	91 05       	cpc	r25, r1
    1868:	d1 f0       	breq	.+52     	; 0x189e <DIO_WritePort+0x58>
    186a:	2b 81       	ldd	r18, Y+3	; 0x03
    186c:	3c 81       	ldd	r19, Y+4	; 0x04
    186e:	22 30       	cpi	r18, 0x02	; 2
    1870:	31 05       	cpc	r19, r1
    1872:	2c f4       	brge	.+10     	; 0x187e <DIO_WritePort+0x38>
    1874:	8b 81       	ldd	r24, Y+3	; 0x03
    1876:	9c 81       	ldd	r25, Y+4	; 0x04
    1878:	00 97       	sbiw	r24, 0x00	; 0
    187a:	61 f0       	breq	.+24     	; 0x1894 <DIO_WritePort+0x4e>
    187c:	1e c0       	rjmp	.+60     	; 0x18ba <DIO_WritePort+0x74>
    187e:	2b 81       	ldd	r18, Y+3	; 0x03
    1880:	3c 81       	ldd	r19, Y+4	; 0x04
    1882:	22 30       	cpi	r18, 0x02	; 2
    1884:	31 05       	cpc	r19, r1
    1886:	81 f0       	breq	.+32     	; 0x18a8 <DIO_WritePort+0x62>
    1888:	8b 81       	ldd	r24, Y+3	; 0x03
    188a:	9c 81       	ldd	r25, Y+4	; 0x04
    188c:	83 30       	cpi	r24, 0x03	; 3
    188e:	91 05       	cpc	r25, r1
    1890:	81 f0       	breq	.+32     	; 0x18b2 <DIO_WritePort+0x6c>
    1892:	13 c0       	rjmp	.+38     	; 0x18ba <DIO_WritePort+0x74>
	{
		case PA:
		PORTA=data;
    1894:	eb e3       	ldi	r30, 0x3B	; 59
    1896:	f0 e0       	ldi	r31, 0x00	; 0
    1898:	8a 81       	ldd	r24, Y+2	; 0x02
    189a:	80 83       	st	Z, r24
    189c:	0e c0       	rjmp	.+28     	; 0x18ba <DIO_WritePort+0x74>
		break;
		case PB:
		PORTB=data;
    189e:	e8 e3       	ldi	r30, 0x38	; 56
    18a0:	f0 e0       	ldi	r31, 0x00	; 0
    18a2:	8a 81       	ldd	r24, Y+2	; 0x02
    18a4:	80 83       	st	Z, r24
    18a6:	09 c0       	rjmp	.+18     	; 0x18ba <DIO_WritePort+0x74>
		break;
		case PC:
		PORTC=data;
    18a8:	e5 e3       	ldi	r30, 0x35	; 53
    18aa:	f0 e0       	ldi	r31, 0x00	; 0
    18ac:	8a 81       	ldd	r24, Y+2	; 0x02
    18ae:	80 83       	st	Z, r24
    18b0:	04 c0       	rjmp	.+8      	; 0x18ba <DIO_WritePort+0x74>
		break;
		case PD:
		PORTD=data;
    18b2:	e2 e3       	ldi	r30, 0x32	; 50
    18b4:	f0 e0       	ldi	r31, 0x00	; 0
    18b6:	8a 81       	ldd	r24, Y+2	; 0x02
    18b8:	80 83       	st	Z, r24
		break;
	}

}
    18ba:	0f 90       	pop	r0
    18bc:	0f 90       	pop	r0
    18be:	0f 90       	pop	r0
    18c0:	0f 90       	pop	r0
    18c2:	cf 91       	pop	r28
    18c4:	df 91       	pop	r29
    18c6:	08 95       	ret

000018c8 <EXI_Enable>:

#include "EX_Interrupt.h"



void EXI_Enable(ExInterruptSource_type Interrupt){
    18c8:	df 93       	push	r29
    18ca:	cf 93       	push	r28
    18cc:	0f 92       	push	r0
    18ce:	cd b7       	in	r28, 0x3d	; 61
    18d0:	de b7       	in	r29, 0x3e	; 62
    18d2:	89 83       	std	Y+1, r24	; 0x01

	if(Interrupt==0){
    18d4:	89 81       	ldd	r24, Y+1	; 0x01
    18d6:	88 23       	and	r24, r24
    18d8:	41 f4       	brne	.+16     	; 0x18ea <EXI_Enable+0x22>
		SET_BIT(GICR,INT0);
    18da:	ab e5       	ldi	r26, 0x5B	; 91
    18dc:	b0 e0       	ldi	r27, 0x00	; 0
    18de:	eb e5       	ldi	r30, 0x5B	; 91
    18e0:	f0 e0       	ldi	r31, 0x00	; 0
    18e2:	80 81       	ld	r24, Z
    18e4:	80 64       	ori	r24, 0x40	; 64
    18e6:	8c 93       	st	X, r24
    18e8:	15 c0       	rjmp	.+42     	; 0x1914 <EXI_Enable+0x4c>
	}
	else if(Interrupt==1){
    18ea:	89 81       	ldd	r24, Y+1	; 0x01
    18ec:	81 30       	cpi	r24, 0x01	; 1
    18ee:	41 f4       	brne	.+16     	; 0x1900 <EXI_Enable+0x38>
		SET_BIT(GICR,INT1);
    18f0:	ab e5       	ldi	r26, 0x5B	; 91
    18f2:	b0 e0       	ldi	r27, 0x00	; 0
    18f4:	eb e5       	ldi	r30, 0x5B	; 91
    18f6:	f0 e0       	ldi	r31, 0x00	; 0
    18f8:	80 81       	ld	r24, Z
    18fa:	80 68       	ori	r24, 0x80	; 128
    18fc:	8c 93       	st	X, r24
    18fe:	0a c0       	rjmp	.+20     	; 0x1914 <EXI_Enable+0x4c>
	}
	else if(Interrupt==2){
    1900:	89 81       	ldd	r24, Y+1	; 0x01
    1902:	82 30       	cpi	r24, 0x02	; 2
    1904:	39 f4       	brne	.+14     	; 0x1914 <EXI_Enable+0x4c>
		SET_BIT(GICR,INT2);
    1906:	ab e5       	ldi	r26, 0x5B	; 91
    1908:	b0 e0       	ldi	r27, 0x00	; 0
    190a:	eb e5       	ldi	r30, 0x5B	; 91
    190c:	f0 e0       	ldi	r31, 0x00	; 0
    190e:	80 81       	ld	r24, Z
    1910:	80 62       	ori	r24, 0x20	; 32
    1912:	8c 93       	st	X, r24
	}

}
    1914:	0f 90       	pop	r0
    1916:	cf 91       	pop	r28
    1918:	df 91       	pop	r29
    191a:	08 95       	ret

0000191c <EXI_Disable>:
void EXI_Disable(ExInterruptSource_type Interrupt){
    191c:	df 93       	push	r29
    191e:	cf 93       	push	r28
    1920:	0f 92       	push	r0
    1922:	cd b7       	in	r28, 0x3d	; 61
    1924:	de b7       	in	r29, 0x3e	; 62
    1926:	89 83       	std	Y+1, r24	; 0x01

	if(Interrupt==0){
    1928:	89 81       	ldd	r24, Y+1	; 0x01
    192a:	88 23       	and	r24, r24
    192c:	41 f4       	brne	.+16     	; 0x193e <EXI_Disable+0x22>
		CLR_BIT(GICR,INT0);
    192e:	ab e5       	ldi	r26, 0x5B	; 91
    1930:	b0 e0       	ldi	r27, 0x00	; 0
    1932:	eb e5       	ldi	r30, 0x5B	; 91
    1934:	f0 e0       	ldi	r31, 0x00	; 0
    1936:	80 81       	ld	r24, Z
    1938:	8f 7b       	andi	r24, 0xBF	; 191
    193a:	8c 93       	st	X, r24
    193c:	15 c0       	rjmp	.+42     	; 0x1968 <EXI_Disable+0x4c>
	}
	else if(Interrupt==1){
    193e:	89 81       	ldd	r24, Y+1	; 0x01
    1940:	81 30       	cpi	r24, 0x01	; 1
    1942:	41 f4       	brne	.+16     	; 0x1954 <EXI_Disable+0x38>
		CLR_BIT(GICR,INT1);
    1944:	ab e5       	ldi	r26, 0x5B	; 91
    1946:	b0 e0       	ldi	r27, 0x00	; 0
    1948:	eb e5       	ldi	r30, 0x5B	; 91
    194a:	f0 e0       	ldi	r31, 0x00	; 0
    194c:	80 81       	ld	r24, Z
    194e:	8f 77       	andi	r24, 0x7F	; 127
    1950:	8c 93       	st	X, r24
    1952:	0a c0       	rjmp	.+20     	; 0x1968 <EXI_Disable+0x4c>
	}
	else if(Interrupt==2){
    1954:	89 81       	ldd	r24, Y+1	; 0x01
    1956:	82 30       	cpi	r24, 0x02	; 2
    1958:	39 f4       	brne	.+14     	; 0x1968 <EXI_Disable+0x4c>
		CLR_BIT(GICR,INT2);
    195a:	ab e5       	ldi	r26, 0x5B	; 91
    195c:	b0 e0       	ldi	r27, 0x00	; 0
    195e:	eb e5       	ldi	r30, 0x5B	; 91
    1960:	f0 e0       	ldi	r31, 0x00	; 0
    1962:	80 81       	ld	r24, Z
    1964:	8f 7d       	andi	r24, 0xDF	; 223
    1966:	8c 93       	st	X, r24
	}

}
    1968:	0f 90       	pop	r0
    196a:	cf 91       	pop	r28
    196c:	df 91       	pop	r29
    196e:	08 95       	ret

00001970 <EXI_TriggerEdge>:
void EXI_TriggerEdge(ExInterruptSource_type Interrupt,TriggerEdge_type Edge){
    1970:	df 93       	push	r29
    1972:	cf 93       	push	r28
    1974:	00 d0       	rcall	.+0      	; 0x1976 <EXI_TriggerEdge+0x6>
    1976:	cd b7       	in	r28, 0x3d	; 61
    1978:	de b7       	in	r29, 0x3e	; 62
    197a:	89 83       	std	Y+1, r24	; 0x01
    197c:	6a 83       	std	Y+2, r22	; 0x02
	if(Interrupt==0){
    197e:	89 81       	ldd	r24, Y+1	; 0x01
    1980:	88 23       	and	r24, r24
    1982:	09 f0       	breq	.+2      	; 0x1986 <EXI_TriggerEdge+0x16>
    1984:	49 c0       	rjmp	.+146    	; 0x1a18 <EXI_TriggerEdge+0xa8>
		if(Edge==0){
    1986:	8a 81       	ldd	r24, Y+2	; 0x02
    1988:	88 23       	and	r24, r24
    198a:	79 f4       	brne	.+30     	; 0x19aa <EXI_TriggerEdge+0x3a>
			CLR_BIT(MCUCR,0);
    198c:	a5 e5       	ldi	r26, 0x55	; 85
    198e:	b0 e0       	ldi	r27, 0x00	; 0
    1990:	e5 e5       	ldi	r30, 0x55	; 85
    1992:	f0 e0       	ldi	r31, 0x00	; 0
    1994:	80 81       	ld	r24, Z
    1996:	8e 7f       	andi	r24, 0xFE	; 254
    1998:	8c 93       	st	X, r24
			CLR_BIT(MCUCR,1);
    199a:	a5 e5       	ldi	r26, 0x55	; 85
    199c:	b0 e0       	ldi	r27, 0x00	; 0
    199e:	e5 e5       	ldi	r30, 0x55	; 85
    19a0:	f0 e0       	ldi	r31, 0x00	; 0
    19a2:	80 81       	ld	r24, Z
    19a4:	8d 7f       	andi	r24, 0xFD	; 253
    19a6:	8c 93       	st	X, r24
    19a8:	b1 c0       	rjmp	.+354    	; 0x1b0c <EXI_TriggerEdge+0x19c>
		}
		else if(Edge==1){
    19aa:	8a 81       	ldd	r24, Y+2	; 0x02
    19ac:	81 30       	cpi	r24, 0x01	; 1
    19ae:	79 f4       	brne	.+30     	; 0x19ce <EXI_TriggerEdge+0x5e>
			SET_BIT(MCUCR,0);
    19b0:	a5 e5       	ldi	r26, 0x55	; 85
    19b2:	b0 e0       	ldi	r27, 0x00	; 0
    19b4:	e5 e5       	ldi	r30, 0x55	; 85
    19b6:	f0 e0       	ldi	r31, 0x00	; 0
    19b8:	80 81       	ld	r24, Z
    19ba:	81 60       	ori	r24, 0x01	; 1
    19bc:	8c 93       	st	X, r24
			CLR_BIT(MCUCR,1);
    19be:	a5 e5       	ldi	r26, 0x55	; 85
    19c0:	b0 e0       	ldi	r27, 0x00	; 0
    19c2:	e5 e5       	ldi	r30, 0x55	; 85
    19c4:	f0 e0       	ldi	r31, 0x00	; 0
    19c6:	80 81       	ld	r24, Z
    19c8:	8d 7f       	andi	r24, 0xFD	; 253
    19ca:	8c 93       	st	X, r24
    19cc:	9f c0       	rjmp	.+318    	; 0x1b0c <EXI_TriggerEdge+0x19c>
		}
		else if(Edge==2){
    19ce:	8a 81       	ldd	r24, Y+2	; 0x02
    19d0:	82 30       	cpi	r24, 0x02	; 2
    19d2:	79 f4       	brne	.+30     	; 0x19f2 <EXI_TriggerEdge+0x82>
			CLR_BIT(MCUCR,0);
    19d4:	a5 e5       	ldi	r26, 0x55	; 85
    19d6:	b0 e0       	ldi	r27, 0x00	; 0
    19d8:	e5 e5       	ldi	r30, 0x55	; 85
    19da:	f0 e0       	ldi	r31, 0x00	; 0
    19dc:	80 81       	ld	r24, Z
    19de:	8e 7f       	andi	r24, 0xFE	; 254
    19e0:	8c 93       	st	X, r24
			SET_BIT(MCUCR,1);
    19e2:	a5 e5       	ldi	r26, 0x55	; 85
    19e4:	b0 e0       	ldi	r27, 0x00	; 0
    19e6:	e5 e5       	ldi	r30, 0x55	; 85
    19e8:	f0 e0       	ldi	r31, 0x00	; 0
    19ea:	80 81       	ld	r24, Z
    19ec:	82 60       	ori	r24, 0x02	; 2
    19ee:	8c 93       	st	X, r24
    19f0:	8d c0       	rjmp	.+282    	; 0x1b0c <EXI_TriggerEdge+0x19c>
		}
		else if(Edge==3){
    19f2:	8a 81       	ldd	r24, Y+2	; 0x02
    19f4:	83 30       	cpi	r24, 0x03	; 3
    19f6:	09 f0       	breq	.+2      	; 0x19fa <EXI_TriggerEdge+0x8a>
    19f8:	89 c0       	rjmp	.+274    	; 0x1b0c <EXI_TriggerEdge+0x19c>
			SET_BIT(MCUCR,0);
    19fa:	a5 e5       	ldi	r26, 0x55	; 85
    19fc:	b0 e0       	ldi	r27, 0x00	; 0
    19fe:	e5 e5       	ldi	r30, 0x55	; 85
    1a00:	f0 e0       	ldi	r31, 0x00	; 0
    1a02:	80 81       	ld	r24, Z
    1a04:	81 60       	ori	r24, 0x01	; 1
    1a06:	8c 93       	st	X, r24
			SET_BIT(MCUCR,1);
    1a08:	a5 e5       	ldi	r26, 0x55	; 85
    1a0a:	b0 e0       	ldi	r27, 0x00	; 0
    1a0c:	e5 e5       	ldi	r30, 0x55	; 85
    1a0e:	f0 e0       	ldi	r31, 0x00	; 0
    1a10:	80 81       	ld	r24, Z
    1a12:	82 60       	ori	r24, 0x02	; 2
    1a14:	8c 93       	st	X, r24
    1a16:	7a c0       	rjmp	.+244    	; 0x1b0c <EXI_TriggerEdge+0x19c>
		}
	}



	else if(Interrupt==1){
    1a18:	89 81       	ldd	r24, Y+1	; 0x01
    1a1a:	81 30       	cpi	r24, 0x01	; 1
    1a1c:	09 f0       	breq	.+2      	; 0x1a20 <EXI_TriggerEdge+0xb0>
    1a1e:	48 c0       	rjmp	.+144    	; 0x1ab0 <EXI_TriggerEdge+0x140>
		if(Edge==0){
    1a20:	8a 81       	ldd	r24, Y+2	; 0x02
    1a22:	88 23       	and	r24, r24
    1a24:	79 f4       	brne	.+30     	; 0x1a44 <EXI_TriggerEdge+0xd4>
			CLR_BIT(MCUCR,2);
    1a26:	a5 e5       	ldi	r26, 0x55	; 85
    1a28:	b0 e0       	ldi	r27, 0x00	; 0
    1a2a:	e5 e5       	ldi	r30, 0x55	; 85
    1a2c:	f0 e0       	ldi	r31, 0x00	; 0
    1a2e:	80 81       	ld	r24, Z
    1a30:	8b 7f       	andi	r24, 0xFB	; 251
    1a32:	8c 93       	st	X, r24
			CLR_BIT(MCUCR,3);
    1a34:	a5 e5       	ldi	r26, 0x55	; 85
    1a36:	b0 e0       	ldi	r27, 0x00	; 0
    1a38:	e5 e5       	ldi	r30, 0x55	; 85
    1a3a:	f0 e0       	ldi	r31, 0x00	; 0
    1a3c:	80 81       	ld	r24, Z
    1a3e:	87 7f       	andi	r24, 0xF7	; 247
    1a40:	8c 93       	st	X, r24
    1a42:	64 c0       	rjmp	.+200    	; 0x1b0c <EXI_TriggerEdge+0x19c>
		}
		else if(Edge==1){
    1a44:	8a 81       	ldd	r24, Y+2	; 0x02
    1a46:	81 30       	cpi	r24, 0x01	; 1
    1a48:	79 f4       	brne	.+30     	; 0x1a68 <EXI_TriggerEdge+0xf8>
			SET_BIT(MCUCR,2);
    1a4a:	a5 e5       	ldi	r26, 0x55	; 85
    1a4c:	b0 e0       	ldi	r27, 0x00	; 0
    1a4e:	e5 e5       	ldi	r30, 0x55	; 85
    1a50:	f0 e0       	ldi	r31, 0x00	; 0
    1a52:	80 81       	ld	r24, Z
    1a54:	84 60       	ori	r24, 0x04	; 4
    1a56:	8c 93       	st	X, r24
			CLR_BIT(MCUCR,3);
    1a58:	a5 e5       	ldi	r26, 0x55	; 85
    1a5a:	b0 e0       	ldi	r27, 0x00	; 0
    1a5c:	e5 e5       	ldi	r30, 0x55	; 85
    1a5e:	f0 e0       	ldi	r31, 0x00	; 0
    1a60:	80 81       	ld	r24, Z
    1a62:	87 7f       	andi	r24, 0xF7	; 247
    1a64:	8c 93       	st	X, r24
    1a66:	52 c0       	rjmp	.+164    	; 0x1b0c <EXI_TriggerEdge+0x19c>
		}
		else if(Edge==2){
    1a68:	8a 81       	ldd	r24, Y+2	; 0x02
    1a6a:	82 30       	cpi	r24, 0x02	; 2
    1a6c:	79 f4       	brne	.+30     	; 0x1a8c <EXI_TriggerEdge+0x11c>
			CLR_BIT(MCUCR,2);
    1a6e:	a5 e5       	ldi	r26, 0x55	; 85
    1a70:	b0 e0       	ldi	r27, 0x00	; 0
    1a72:	e5 e5       	ldi	r30, 0x55	; 85
    1a74:	f0 e0       	ldi	r31, 0x00	; 0
    1a76:	80 81       	ld	r24, Z
    1a78:	8b 7f       	andi	r24, 0xFB	; 251
    1a7a:	8c 93       	st	X, r24
			SET_BIT(MCUCR,3);
    1a7c:	a5 e5       	ldi	r26, 0x55	; 85
    1a7e:	b0 e0       	ldi	r27, 0x00	; 0
    1a80:	e5 e5       	ldi	r30, 0x55	; 85
    1a82:	f0 e0       	ldi	r31, 0x00	; 0
    1a84:	80 81       	ld	r24, Z
    1a86:	88 60       	ori	r24, 0x08	; 8
    1a88:	8c 93       	st	X, r24
    1a8a:	40 c0       	rjmp	.+128    	; 0x1b0c <EXI_TriggerEdge+0x19c>
		}
		else if(Edge==3){
    1a8c:	8a 81       	ldd	r24, Y+2	; 0x02
    1a8e:	83 30       	cpi	r24, 0x03	; 3
    1a90:	e9 f5       	brne	.+122    	; 0x1b0c <EXI_TriggerEdge+0x19c>
			SET_BIT(MCUCR,2);
    1a92:	a5 e5       	ldi	r26, 0x55	; 85
    1a94:	b0 e0       	ldi	r27, 0x00	; 0
    1a96:	e5 e5       	ldi	r30, 0x55	; 85
    1a98:	f0 e0       	ldi	r31, 0x00	; 0
    1a9a:	80 81       	ld	r24, Z
    1a9c:	84 60       	ori	r24, 0x04	; 4
    1a9e:	8c 93       	st	X, r24
			SET_BIT(MCUCR,3);
    1aa0:	a5 e5       	ldi	r26, 0x55	; 85
    1aa2:	b0 e0       	ldi	r27, 0x00	; 0
    1aa4:	e5 e5       	ldi	r30, 0x55	; 85
    1aa6:	f0 e0       	ldi	r31, 0x00	; 0
    1aa8:	80 81       	ld	r24, Z
    1aaa:	88 60       	ori	r24, 0x08	; 8
    1aac:	8c 93       	st	X, r24
    1aae:	2e c0       	rjmp	.+92     	; 0x1b0c <EXI_TriggerEdge+0x19c>
		}
	}
	else if(Interrupt==2){
    1ab0:	89 81       	ldd	r24, Y+1	; 0x01
    1ab2:	82 30       	cpi	r24, 0x02	; 2
    1ab4:	59 f5       	brne	.+86     	; 0x1b0c <EXI_TriggerEdge+0x19c>

		// first 2 cases just for the sake of it
		if(Edge==0){
    1ab6:	8a 81       	ldd	r24, Y+2	; 0x02
    1ab8:	88 23       	and	r24, r24
    1aba:	41 f4       	brne	.+16     	; 0x1acc <EXI_TriggerEdge+0x15c>
			CLR_BIT(MCUCSR,ISC2);
    1abc:	a4 e5       	ldi	r26, 0x54	; 84
    1abe:	b0 e0       	ldi	r27, 0x00	; 0
    1ac0:	e4 e5       	ldi	r30, 0x54	; 84
    1ac2:	f0 e0       	ldi	r31, 0x00	; 0
    1ac4:	80 81       	ld	r24, Z
    1ac6:	8f 7b       	andi	r24, 0xBF	; 191
    1ac8:	8c 93       	st	X, r24
    1aca:	20 c0       	rjmp	.+64     	; 0x1b0c <EXI_TriggerEdge+0x19c>
		}
		else if(Edge==1){
    1acc:	8a 81       	ldd	r24, Y+2	; 0x02
    1ace:	81 30       	cpi	r24, 0x01	; 1
    1ad0:	41 f4       	brne	.+16     	; 0x1ae2 <EXI_TriggerEdge+0x172>
			CLR_BIT(MCUCSR,ISC2);
    1ad2:	a4 e5       	ldi	r26, 0x54	; 84
    1ad4:	b0 e0       	ldi	r27, 0x00	; 0
    1ad6:	e4 e5       	ldi	r30, 0x54	; 84
    1ad8:	f0 e0       	ldi	r31, 0x00	; 0
    1ada:	80 81       	ld	r24, Z
    1adc:	8f 7b       	andi	r24, 0xBF	; 191
    1ade:	8c 93       	st	X, r24
    1ae0:	15 c0       	rjmp	.+42     	; 0x1b0c <EXI_TriggerEdge+0x19c>
		}
		else if(Edge==2){
    1ae2:	8a 81       	ldd	r24, Y+2	; 0x02
    1ae4:	82 30       	cpi	r24, 0x02	; 2
    1ae6:	41 f4       	brne	.+16     	; 0x1af8 <EXI_TriggerEdge+0x188>
			CLR_BIT(MCUCSR,ISC2);
    1ae8:	a4 e5       	ldi	r26, 0x54	; 84
    1aea:	b0 e0       	ldi	r27, 0x00	; 0
    1aec:	e4 e5       	ldi	r30, 0x54	; 84
    1aee:	f0 e0       	ldi	r31, 0x00	; 0
    1af0:	80 81       	ld	r24, Z
    1af2:	8f 7b       	andi	r24, 0xBF	; 191
    1af4:	8c 93       	st	X, r24
    1af6:	0a c0       	rjmp	.+20     	; 0x1b0c <EXI_TriggerEdge+0x19c>
		}
		else if(Edge==3){
    1af8:	8a 81       	ldd	r24, Y+2	; 0x02
    1afa:	83 30       	cpi	r24, 0x03	; 3
    1afc:	39 f4       	brne	.+14     	; 0x1b0c <EXI_TriggerEdge+0x19c>
			SET_BIT(MCUCSR,ISC2);
    1afe:	a4 e5       	ldi	r26, 0x54	; 84
    1b00:	b0 e0       	ldi	r27, 0x00	; 0
    1b02:	e4 e5       	ldi	r30, 0x54	; 84
    1b04:	f0 e0       	ldi	r31, 0x00	; 0
    1b06:	80 81       	ld	r24, Z
    1b08:	80 64       	ori	r24, 0x40	; 64
    1b0a:	8c 93       	st	X, r24
		}


	}

}
    1b0c:	0f 90       	pop	r0
    1b0e:	0f 90       	pop	r0
    1b10:	cf 91       	pop	r28
    1b12:	df 91       	pop	r29
    1b14:	08 95       	ret

00001b16 <SPI_Init>:
 */

#include "SPI.h"


void SPI_Init(void){
    1b16:	df 93       	push	r29
    1b18:	cf 93       	push	r28
    1b1a:	cd b7       	in	r28, 0x3d	; 61
    1b1c:	de b7       	in	r29, 0x3e	; 62


	if(SPI_MODE==MASTER){
		SET_BIT(SPCR,MSTR);
    1b1e:	ad e2       	ldi	r26, 0x2D	; 45
    1b20:	b0 e0       	ldi	r27, 0x00	; 0
    1b22:	ed e2       	ldi	r30, 0x2D	; 45
    1b24:	f0 e0       	ldi	r31, 0x00	; 0
    1b26:	80 81       	ld	r24, Z
    1b28:	80 61       	ori	r24, 0x10	; 16
    1b2a:	8c 93       	st	X, r24
	else {
		CLR_BIT(SPCR,MSTR);
	}


	SET_BIT(SPCR,SPE);
    1b2c:	ad e2       	ldi	r26, 0x2D	; 45
    1b2e:	b0 e0       	ldi	r27, 0x00	; 0
    1b30:	ed e2       	ldi	r30, 0x2D	; 45
    1b32:	f0 e0       	ldi	r31, 0x00	; 0
    1b34:	80 81       	ld	r24, Z
    1b36:	80 64       	ori	r24, 0x40	; 64
    1b38:	8c 93       	st	X, r24

}
    1b3a:	cf 91       	pop	r28
    1b3c:	df 91       	pop	r29
    1b3e:	08 95       	ret

00001b40 <SPI_SendReceive>:


u8 SPI_SendReceive(u8 data){
    1b40:	df 93       	push	r29
    1b42:	cf 93       	push	r28
    1b44:	0f 92       	push	r0
    1b46:	cd b7       	in	r28, 0x3d	; 61
    1b48:	de b7       	in	r29, 0x3e	; 62
    1b4a:	89 83       	std	Y+1, r24	; 0x01

	SPDR=data;
    1b4c:	ef e2       	ldi	r30, 0x2F	; 47
    1b4e:	f0 e0       	ldi	r31, 0x00	; 0
    1b50:	89 81       	ldd	r24, Y+1	; 0x01
    1b52:	80 83       	st	Z, r24
	while(READ_BIT(SPSR,SPIF)==0);
    1b54:	ee e2       	ldi	r30, 0x2E	; 46
    1b56:	f0 e0       	ldi	r31, 0x00	; 0
    1b58:	80 81       	ld	r24, Z
    1b5a:	88 23       	and	r24, r24
    1b5c:	dc f7       	brge	.-10     	; 0x1b54 <SPI_SendReceive+0x14>
	return SPDR;
    1b5e:	ef e2       	ldi	r30, 0x2F	; 47
    1b60:	f0 e0       	ldi	r31, 0x00	; 0
    1b62:	80 81       	ld	r24, Z
}
    1b64:	0f 90       	pop	r0
    1b66:	cf 91       	pop	r28
    1b68:	df 91       	pop	r29
    1b6a:	08 95       	ret

00001b6c <TIMER0_Init>:
 *  Created on: Aug 25, 2023
 *      Author: F1
 */
#include "TIMER.h"

void TIMER0_Init(TIMER0_MODE_TYPE mode,TIMER0_PRESCALAR prescalar,OC0_MODE_TYPE oc){
    1b6c:	df 93       	push	r29
    1b6e:	cf 93       	push	r28
    1b70:	cd b7       	in	r28, 0x3d	; 61
    1b72:	de b7       	in	r29, 0x3e	; 62
    1b74:	27 97       	sbiw	r28, 0x07	; 7
    1b76:	0f b6       	in	r0, 0x3f	; 63
    1b78:	f8 94       	cli
    1b7a:	de bf       	out	0x3e, r29	; 62
    1b7c:	0f be       	out	0x3f, r0	; 63
    1b7e:	cd bf       	out	0x3d, r28	; 61
    1b80:	89 83       	std	Y+1, r24	; 0x01
    1b82:	6a 83       	std	Y+2, r22	; 0x02
    1b84:	4b 83       	std	Y+3, r20	; 0x03
	TCCR0=0x00;
    1b86:	e3 e5       	ldi	r30, 0x53	; 83
    1b88:	f0 e0       	ldi	r31, 0x00	; 0
    1b8a:	10 82       	st	Z, r1
	switch(mode){
    1b8c:	89 81       	ldd	r24, Y+1	; 0x01
    1b8e:	28 2f       	mov	r18, r24
    1b90:	30 e0       	ldi	r19, 0x00	; 0
    1b92:	3f 83       	std	Y+7, r19	; 0x07
    1b94:	2e 83       	std	Y+6, r18	; 0x06
    1b96:	8e 81       	ldd	r24, Y+6	; 0x06
    1b98:	9f 81       	ldd	r25, Y+7	; 0x07
    1b9a:	81 30       	cpi	r24, 0x01	; 1
    1b9c:	91 05       	cpc	r25, r1
    1b9e:	21 f1       	breq	.+72     	; 0x1be8 <TIMER0_Init+0x7c>
    1ba0:	2e 81       	ldd	r18, Y+6	; 0x06
    1ba2:	3f 81       	ldd	r19, Y+7	; 0x07
    1ba4:	22 30       	cpi	r18, 0x02	; 2
    1ba6:	31 05       	cpc	r19, r1
    1ba8:	2c f4       	brge	.+10     	; 0x1bb4 <TIMER0_Init+0x48>
    1baa:	8e 81       	ldd	r24, Y+6	; 0x06
    1bac:	9f 81       	ldd	r25, Y+7	; 0x07
    1bae:	00 97       	sbiw	r24, 0x00	; 0
    1bb0:	61 f0       	breq	.+24     	; 0x1bca <TIMER0_Init+0x5e>
    1bb2:	46 c0       	rjmp	.+140    	; 0x1c40 <TIMER0_Init+0xd4>
    1bb4:	2e 81       	ldd	r18, Y+6	; 0x06
    1bb6:	3f 81       	ldd	r19, Y+7	; 0x07
    1bb8:	22 30       	cpi	r18, 0x02	; 2
    1bba:	31 05       	cpc	r19, r1
    1bbc:	21 f1       	breq	.+72     	; 0x1c06 <TIMER0_Init+0x9a>
    1bbe:	8e 81       	ldd	r24, Y+6	; 0x06
    1bc0:	9f 81       	ldd	r25, Y+7	; 0x07
    1bc2:	83 30       	cpi	r24, 0x03	; 3
    1bc4:	91 05       	cpc	r25, r1
    1bc6:	71 f1       	breq	.+92     	; 0x1c24 <TIMER0_Init+0xb8>
    1bc8:	3b c0       	rjmp	.+118    	; 0x1c40 <TIMER0_Init+0xd4>
	case NORMAL:
		CLR_BIT(TCCR0,WGM00);
    1bca:	a3 e5       	ldi	r26, 0x53	; 83
    1bcc:	b0 e0       	ldi	r27, 0x00	; 0
    1bce:	e3 e5       	ldi	r30, 0x53	; 83
    1bd0:	f0 e0       	ldi	r31, 0x00	; 0
    1bd2:	80 81       	ld	r24, Z
    1bd4:	8f 7b       	andi	r24, 0xBF	; 191
    1bd6:	8c 93       	st	X, r24
		CLR_BIT(TCCR0,WGM01);
    1bd8:	a3 e5       	ldi	r26, 0x53	; 83
    1bda:	b0 e0       	ldi	r27, 0x00	; 0
    1bdc:	e3 e5       	ldi	r30, 0x53	; 83
    1bde:	f0 e0       	ldi	r31, 0x00	; 0
    1be0:	80 81       	ld	r24, Z
    1be2:	87 7f       	andi	r24, 0xF7	; 247
    1be4:	8c 93       	st	X, r24
    1be6:	2c c0       	rjmp	.+88     	; 0x1c40 <TIMER0_Init+0xd4>
		break;
	case PHASE_CORRECT:
		SET_BIT(TCCR0,WGM00);
    1be8:	a3 e5       	ldi	r26, 0x53	; 83
    1bea:	b0 e0       	ldi	r27, 0x00	; 0
    1bec:	e3 e5       	ldi	r30, 0x53	; 83
    1bee:	f0 e0       	ldi	r31, 0x00	; 0
    1bf0:	80 81       	ld	r24, Z
    1bf2:	80 64       	ori	r24, 0x40	; 64
    1bf4:	8c 93       	st	X, r24
		CLR_BIT(TCCR0,WGM01);
    1bf6:	a3 e5       	ldi	r26, 0x53	; 83
    1bf8:	b0 e0       	ldi	r27, 0x00	; 0
    1bfa:	e3 e5       	ldi	r30, 0x53	; 83
    1bfc:	f0 e0       	ldi	r31, 0x00	; 0
    1bfe:	80 81       	ld	r24, Z
    1c00:	87 7f       	andi	r24, 0xF7	; 247
    1c02:	8c 93       	st	X, r24
    1c04:	1d c0       	rjmp	.+58     	; 0x1c40 <TIMER0_Init+0xd4>
		break;
	case CTC:
		CLR_BIT(TCCR0,WGM00);
    1c06:	a3 e5       	ldi	r26, 0x53	; 83
    1c08:	b0 e0       	ldi	r27, 0x00	; 0
    1c0a:	e3 e5       	ldi	r30, 0x53	; 83
    1c0c:	f0 e0       	ldi	r31, 0x00	; 0
    1c0e:	80 81       	ld	r24, Z
    1c10:	8f 7b       	andi	r24, 0xBF	; 191
    1c12:	8c 93       	st	X, r24
		SET_BIT(TCCR0,WGM01);
    1c14:	a3 e5       	ldi	r26, 0x53	; 83
    1c16:	b0 e0       	ldi	r27, 0x00	; 0
    1c18:	e3 e5       	ldi	r30, 0x53	; 83
    1c1a:	f0 e0       	ldi	r31, 0x00	; 0
    1c1c:	80 81       	ld	r24, Z
    1c1e:	88 60       	ori	r24, 0x08	; 8
    1c20:	8c 93       	st	X, r24
    1c22:	0e c0       	rjmp	.+28     	; 0x1c40 <TIMER0_Init+0xd4>
		break;
	case FAST_PWM:
		SET_BIT(TCCR0,WGM00);
    1c24:	a3 e5       	ldi	r26, 0x53	; 83
    1c26:	b0 e0       	ldi	r27, 0x00	; 0
    1c28:	e3 e5       	ldi	r30, 0x53	; 83
    1c2a:	f0 e0       	ldi	r31, 0x00	; 0
    1c2c:	80 81       	ld	r24, Z
    1c2e:	80 64       	ori	r24, 0x40	; 64
    1c30:	8c 93       	st	X, r24
		SET_BIT(TCCR0,WGM01);
    1c32:	a3 e5       	ldi	r26, 0x53	; 83
    1c34:	b0 e0       	ldi	r27, 0x00	; 0
    1c36:	e3 e5       	ldi	r30, 0x53	; 83
    1c38:	f0 e0       	ldi	r31, 0x00	; 0
    1c3a:	80 81       	ld	r24, Z
    1c3c:	88 60       	ori	r24, 0x08	; 8
    1c3e:	8c 93       	st	X, r24
		break;
	}

	switch(oc){
    1c40:	8b 81       	ldd	r24, Y+3	; 0x03
    1c42:	28 2f       	mov	r18, r24
    1c44:	30 e0       	ldi	r19, 0x00	; 0
    1c46:	3d 83       	std	Y+5, r19	; 0x05
    1c48:	2c 83       	std	Y+4, r18	; 0x04
    1c4a:	8c 81       	ldd	r24, Y+4	; 0x04
    1c4c:	9d 81       	ldd	r25, Y+5	; 0x05
    1c4e:	81 30       	cpi	r24, 0x01	; 1
    1c50:	91 05       	cpc	r25, r1
    1c52:	21 f1       	breq	.+72     	; 0x1c9c <TIMER0_Init+0x130>
    1c54:	2c 81       	ldd	r18, Y+4	; 0x04
    1c56:	3d 81       	ldd	r19, Y+5	; 0x05
    1c58:	22 30       	cpi	r18, 0x02	; 2
    1c5a:	31 05       	cpc	r19, r1
    1c5c:	2c f4       	brge	.+10     	; 0x1c68 <TIMER0_Init+0xfc>
    1c5e:	8c 81       	ldd	r24, Y+4	; 0x04
    1c60:	9d 81       	ldd	r25, Y+5	; 0x05
    1c62:	00 97       	sbiw	r24, 0x00	; 0
    1c64:	61 f0       	breq	.+24     	; 0x1c7e <TIMER0_Init+0x112>
    1c66:	46 c0       	rjmp	.+140    	; 0x1cf4 <TIMER0_Init+0x188>
    1c68:	2c 81       	ldd	r18, Y+4	; 0x04
    1c6a:	3d 81       	ldd	r19, Y+5	; 0x05
    1c6c:	22 30       	cpi	r18, 0x02	; 2
    1c6e:	31 05       	cpc	r19, r1
    1c70:	21 f1       	breq	.+72     	; 0x1cba <TIMER0_Init+0x14e>
    1c72:	8c 81       	ldd	r24, Y+4	; 0x04
    1c74:	9d 81       	ldd	r25, Y+5	; 0x05
    1c76:	83 30       	cpi	r24, 0x03	; 3
    1c78:	91 05       	cpc	r25, r1
    1c7a:	71 f1       	breq	.+92     	; 0x1cd8 <TIMER0_Init+0x16c>
    1c7c:	3b c0       	rjmp	.+118    	; 0x1cf4 <TIMER0_Init+0x188>
	case OC0_NOT_CONNECTED:
		CLR_BIT(TCCR0,COM00);
    1c7e:	a3 e5       	ldi	r26, 0x53	; 83
    1c80:	b0 e0       	ldi	r27, 0x00	; 0
    1c82:	e3 e5       	ldi	r30, 0x53	; 83
    1c84:	f0 e0       	ldi	r31, 0x00	; 0
    1c86:	80 81       	ld	r24, Z
    1c88:	8f 7e       	andi	r24, 0xEF	; 239
    1c8a:	8c 93       	st	X, r24
		CLR_BIT(TCCR0,COM01);
    1c8c:	a3 e5       	ldi	r26, 0x53	; 83
    1c8e:	b0 e0       	ldi	r27, 0x00	; 0
    1c90:	e3 e5       	ldi	r30, 0x53	; 83
    1c92:	f0 e0       	ldi	r31, 0x00	; 0
    1c94:	80 81       	ld	r24, Z
    1c96:	8f 7d       	andi	r24, 0xDF	; 223
    1c98:	8c 93       	st	X, r24
    1c9a:	2c c0       	rjmp	.+88     	; 0x1cf4 <TIMER0_Init+0x188>
		break;
	case OC0_TOOGLE:
		SET_BIT(TCCR0,COM00);
    1c9c:	a3 e5       	ldi	r26, 0x53	; 83
    1c9e:	b0 e0       	ldi	r27, 0x00	; 0
    1ca0:	e3 e5       	ldi	r30, 0x53	; 83
    1ca2:	f0 e0       	ldi	r31, 0x00	; 0
    1ca4:	80 81       	ld	r24, Z
    1ca6:	80 61       	ori	r24, 0x10	; 16
    1ca8:	8c 93       	st	X, r24
		CLR_BIT(TCCR0,COM01);
    1caa:	a3 e5       	ldi	r26, 0x53	; 83
    1cac:	b0 e0       	ldi	r27, 0x00	; 0
    1cae:	e3 e5       	ldi	r30, 0x53	; 83
    1cb0:	f0 e0       	ldi	r31, 0x00	; 0
    1cb2:	80 81       	ld	r24, Z
    1cb4:	8f 7d       	andi	r24, 0xDF	; 223
    1cb6:	8c 93       	st	X, r24
    1cb8:	1d c0       	rjmp	.+58     	; 0x1cf4 <TIMER0_Init+0x188>
		break;
	case OC0_NON_INVERTING:
		CLR_BIT(TCCR0,COM00);
    1cba:	a3 e5       	ldi	r26, 0x53	; 83
    1cbc:	b0 e0       	ldi	r27, 0x00	; 0
    1cbe:	e3 e5       	ldi	r30, 0x53	; 83
    1cc0:	f0 e0       	ldi	r31, 0x00	; 0
    1cc2:	80 81       	ld	r24, Z
    1cc4:	8f 7e       	andi	r24, 0xEF	; 239
    1cc6:	8c 93       	st	X, r24
		SET_BIT(TCCR0,COM01);
    1cc8:	a3 e5       	ldi	r26, 0x53	; 83
    1cca:	b0 e0       	ldi	r27, 0x00	; 0
    1ccc:	e3 e5       	ldi	r30, 0x53	; 83
    1cce:	f0 e0       	ldi	r31, 0x00	; 0
    1cd0:	80 81       	ld	r24, Z
    1cd2:	80 62       	ori	r24, 0x20	; 32
    1cd4:	8c 93       	st	X, r24
    1cd6:	0e c0       	rjmp	.+28     	; 0x1cf4 <TIMER0_Init+0x188>
		break;
	case OC0_INVERTING:
		SET_BIT(TCCR0,COM00);
    1cd8:	a3 e5       	ldi	r26, 0x53	; 83
    1cda:	b0 e0       	ldi	r27, 0x00	; 0
    1cdc:	e3 e5       	ldi	r30, 0x53	; 83
    1cde:	f0 e0       	ldi	r31, 0x00	; 0
    1ce0:	80 81       	ld	r24, Z
    1ce2:	80 61       	ori	r24, 0x10	; 16
    1ce4:	8c 93       	st	X, r24
		SET_BIT(TCCR0,COM01);
    1ce6:	a3 e5       	ldi	r26, 0x53	; 83
    1ce8:	b0 e0       	ldi	r27, 0x00	; 0
    1cea:	e3 e5       	ldi	r30, 0x53	; 83
    1cec:	f0 e0       	ldi	r31, 0x00	; 0
    1cee:	80 81       	ld	r24, Z
    1cf0:	80 62       	ori	r24, 0x20	; 32
    1cf2:	8c 93       	st	X, r24
		break;
	}
	TCCR0|=prescalar;
    1cf4:	a3 e5       	ldi	r26, 0x53	; 83
    1cf6:	b0 e0       	ldi	r27, 0x00	; 0
    1cf8:	e3 e5       	ldi	r30, 0x53	; 83
    1cfa:	f0 e0       	ldi	r31, 0x00	; 0
    1cfc:	90 81       	ld	r25, Z
    1cfe:	8a 81       	ldd	r24, Y+2	; 0x02
    1d00:	89 2b       	or	r24, r25
    1d02:	8c 93       	st	X, r24
		break;
	case EX_RISING:
		TCCR0|=0x07;
		break;
	}*/
}
    1d04:	27 96       	adiw	r28, 0x07	; 7
    1d06:	0f b6       	in	r0, 0x3f	; 63
    1d08:	f8 94       	cli
    1d0a:	de bf       	out	0x3e, r29	; 62
    1d0c:	0f be       	out	0x3f, r0	; 63
    1d0e:	cd bf       	out	0x3d, r28	; 61
    1d10:	cf 91       	pop	r28
    1d12:	df 91       	pop	r29
    1d14:	08 95       	ret

00001d16 <TIMER0_InterruptEnable>:


void TIMER0_InterruptEnable(){
    1d16:	df 93       	push	r29
    1d18:	cf 93       	push	r28
    1d1a:	cd b7       	in	r28, 0x3d	; 61
    1d1c:	de b7       	in	r29, 0x3e	; 62
	SET_BIT(TIMSK,TOIE0);
    1d1e:	a9 e5       	ldi	r26, 0x59	; 89
    1d20:	b0 e0       	ldi	r27, 0x00	; 0
    1d22:	e9 e5       	ldi	r30, 0x59	; 89
    1d24:	f0 e0       	ldi	r31, 0x00	; 0
    1d26:	80 81       	ld	r24, Z
    1d28:	81 60       	ori	r24, 0x01	; 1
    1d2a:	8c 93       	st	X, r24
}
    1d2c:	cf 91       	pop	r28
    1d2e:	df 91       	pop	r29
    1d30:	08 95       	ret

00001d32 <TIMER0_InterruptDisable>:
void TIMER0_InterruptDisable(){
    1d32:	df 93       	push	r29
    1d34:	cf 93       	push	r28
    1d36:	cd b7       	in	r28, 0x3d	; 61
    1d38:	de b7       	in	r29, 0x3e	; 62
	CLR_BIT(TIMSK,TOIE0);
    1d3a:	a9 e5       	ldi	r26, 0x59	; 89
    1d3c:	b0 e0       	ldi	r27, 0x00	; 0
    1d3e:	e9 e5       	ldi	r30, 0x59	; 89
    1d40:	f0 e0       	ldi	r31, 0x00	; 0
    1d42:	80 81       	ld	r24, Z
    1d44:	8e 7f       	andi	r24, 0xFE	; 254
    1d46:	8c 93       	st	X, r24
}
    1d48:	cf 91       	pop	r28
    1d4a:	df 91       	pop	r29
    1d4c:	08 95       	ret

00001d4e <OC0_InterruptEnable>:

void OC0_InterruptEnable(){
    1d4e:	df 93       	push	r29
    1d50:	cf 93       	push	r28
    1d52:	cd b7       	in	r28, 0x3d	; 61
    1d54:	de b7       	in	r29, 0x3e	; 62
	SET_BIT(TIMSK,OCIE0);
    1d56:	a9 e5       	ldi	r26, 0x59	; 89
    1d58:	b0 e0       	ldi	r27, 0x00	; 0
    1d5a:	e9 e5       	ldi	r30, 0x59	; 89
    1d5c:	f0 e0       	ldi	r31, 0x00	; 0
    1d5e:	80 81       	ld	r24, Z
    1d60:	82 60       	ori	r24, 0x02	; 2
    1d62:	8c 93       	st	X, r24
}
    1d64:	cf 91       	pop	r28
    1d66:	df 91       	pop	r29
    1d68:	08 95       	ret

00001d6a <OC0_InterruptDisable>:
void OC0_InterruptDisable(){
    1d6a:	df 93       	push	r29
    1d6c:	cf 93       	push	r28
    1d6e:	cd b7       	in	r28, 0x3d	; 61
    1d70:	de b7       	in	r29, 0x3e	; 62
	CLR_BIT(TIMSK,OCIE0);
    1d72:	a9 e5       	ldi	r26, 0x59	; 89
    1d74:	b0 e0       	ldi	r27, 0x00	; 0
    1d76:	e9 e5       	ldi	r30, 0x59	; 89
    1d78:	f0 e0       	ldi	r31, 0x00	; 0
    1d7a:	80 81       	ld	r24, Z
    1d7c:	8d 7f       	andi	r24, 0xFD	; 253
    1d7e:	8c 93       	st	X, r24
}
    1d80:	cf 91       	pop	r28
    1d82:	df 91       	pop	r29
    1d84:	08 95       	ret

00001d86 <UART_Init>:
#include"../STD_TYPES.h"
#include"../Utils.h"
#include "UART.h"

void UART_Init(void)
{
    1d86:	df 93       	push	r29
    1d88:	cf 93       	push	r28
    1d8a:	cd b7       	in	r28, 0x3d	; 61
    1d8c:	de b7       	in	r29, 0x3e	; 62
	// baud rate
	UBRRL=51;
    1d8e:	e9 e2       	ldi	r30, 0x29	; 41
    1d90:	f0 e0       	ldi	r31, 0x00	; 0
    1d92:	83 e3       	ldi	r24, 0x33	; 51
    1d94:	80 83       	st	Z, r24
	
	// NORMAL SPEED
	CLR_BIT(UCSRA,U2X);
    1d96:	ab e2       	ldi	r26, 0x2B	; 43
    1d98:	b0 e0       	ldi	r27, 0x00	; 0
    1d9a:	eb e2       	ldi	r30, 0x2B	; 43
    1d9c:	f0 e0       	ldi	r31, 0x00	; 0
    1d9e:	80 81       	ld	r24, Z
    1da0:	8d 7f       	andi	r24, 0xFD	; 253
    1da2:	8c 93       	st	X, r24
	// frame data bit , parity , stop
	// 8 DATA , NO PARITY 1 STOP
	
	
	//enable
	SET_BIT(UCSRB,TXEN);
    1da4:	aa e2       	ldi	r26, 0x2A	; 42
    1da6:	b0 e0       	ldi	r27, 0x00	; 0
    1da8:	ea e2       	ldi	r30, 0x2A	; 42
    1daa:	f0 e0       	ldi	r31, 0x00	; 0
    1dac:	80 81       	ld	r24, Z
    1dae:	88 60       	ori	r24, 0x08	; 8
    1db0:	8c 93       	st	X, r24
	SET_BIT(UCSRB,RXEN);
    1db2:	aa e2       	ldi	r26, 0x2A	; 42
    1db4:	b0 e0       	ldi	r27, 0x00	; 0
    1db6:	ea e2       	ldi	r30, 0x2A	; 42
    1db8:	f0 e0       	ldi	r31, 0x00	; 0
    1dba:	80 81       	ld	r24, Z
    1dbc:	80 61       	ori	r24, 0x10	; 16
    1dbe:	8c 93       	st	X, r24
	
}
    1dc0:	cf 91       	pop	r28
    1dc2:	df 91       	pop	r29
    1dc4:	08 95       	ret

00001dc6 <UART_Send>:

void UART_Send(u8 data)
{
    1dc6:	df 93       	push	r29
    1dc8:	cf 93       	push	r28
    1dca:	0f 92       	push	r0
    1dcc:	cd b7       	in	r28, 0x3d	; 61
    1dce:	de b7       	in	r29, 0x3e	; 62
    1dd0:	89 83       	std	Y+1, r24	; 0x01
	while(!READ_BIT(UCSRA,UDRE));
    1dd2:	eb e2       	ldi	r30, 0x2B	; 43
    1dd4:	f0 e0       	ldi	r31, 0x00	; 0
    1dd6:	80 81       	ld	r24, Z
    1dd8:	82 95       	swap	r24
    1dda:	86 95       	lsr	r24
    1ddc:	87 70       	andi	r24, 0x07	; 7
    1dde:	88 2f       	mov	r24, r24
    1de0:	90 e0       	ldi	r25, 0x00	; 0
    1de2:	81 70       	andi	r24, 0x01	; 1
    1de4:	90 70       	andi	r25, 0x00	; 0
    1de6:	00 97       	sbiw	r24, 0x00	; 0
    1de8:	a1 f3       	breq	.-24     	; 0x1dd2 <UART_Send+0xc>
	UDR=data;	
    1dea:	ec e2       	ldi	r30, 0x2C	; 44
    1dec:	f0 e0       	ldi	r31, 0x00	; 0
    1dee:	89 81       	ldd	r24, Y+1	; 0x01
    1df0:	80 83       	st	Z, r24
}
    1df2:	0f 90       	pop	r0
    1df4:	cf 91       	pop	r28
    1df6:	df 91       	pop	r29
    1df8:	08 95       	ret

00001dfa <UART_Recieve>:

u8 UART_Recieve(void)
{
    1dfa:	df 93       	push	r29
    1dfc:	cf 93       	push	r28
    1dfe:	cd b7       	in	r28, 0x3d	; 61
    1e00:	de b7       	in	r29, 0x3e	; 62
	while(!READ_BIT(UCSRA,RXC));
    1e02:	eb e2       	ldi	r30, 0x2B	; 43
    1e04:	f0 e0       	ldi	r31, 0x00	; 0
    1e06:	80 81       	ld	r24, Z
    1e08:	88 23       	and	r24, r24
    1e0a:	dc f7       	brge	.-10     	; 0x1e02 <UART_Recieve+0x8>
	return UDR;
    1e0c:	ec e2       	ldi	r30, 0x2C	; 44
    1e0e:	f0 e0       	ldi	r31, 0x00	; 0
    1e10:	80 81       	ld	r24, Z
}
    1e12:	cf 91       	pop	r28
    1e14:	df 91       	pop	r29
    1e16:	08 95       	ret

00001e18 <UART_Receive>:




u8 UART_Receive(void)
{
    1e18:	df 93       	push	r29
    1e1a:	cf 93       	push	r28
    1e1c:	cd b7       	in	r28, 0x3d	; 61
    1e1e:	de b7       	in	r29, 0x3e	; 62
	while(!READ_BIT(UCSRA,RXC));
    1e20:	eb e2       	ldi	r30, 0x2B	; 43
    1e22:	f0 e0       	ldi	r31, 0x00	; 0
    1e24:	80 81       	ld	r24, Z
    1e26:	88 23       	and	r24, r24
    1e28:	dc f7       	brge	.-10     	; 0x1e20 <UART_Receive+0x8>
	return UDR;
    1e2a:	ec e2       	ldi	r30, 0x2C	; 44
    1e2c:	f0 e0       	ldi	r31, 0x00	; 0
    1e2e:	80 81       	ld	r24, Z
}
    1e30:	cf 91       	pop	r28
    1e32:	df 91       	pop	r29
    1e34:	08 95       	ret

00001e36 <UART_ReceivePerodic>:

u8 UART_ReceivePerodic(u8*pdata)
{
    1e36:	df 93       	push	r29
    1e38:	cf 93       	push	r28
    1e3a:	00 d0       	rcall	.+0      	; 0x1e3c <UART_ReceivePerodic+0x6>
    1e3c:	0f 92       	push	r0
    1e3e:	cd b7       	in	r28, 0x3d	; 61
    1e40:	de b7       	in	r29, 0x3e	; 62
    1e42:	9a 83       	std	Y+2, r25	; 0x02
    1e44:	89 83       	std	Y+1, r24	; 0x01
	if (READ_BIT(UCSRA,RXC))
    1e46:	eb e2       	ldi	r30, 0x2B	; 43
    1e48:	f0 e0       	ldi	r31, 0x00	; 0
    1e4a:	80 81       	ld	r24, Z
    1e4c:	88 23       	and	r24, r24
    1e4e:	4c f4       	brge	.+18     	; 0x1e62 <UART_ReceivePerodic+0x2c>
	{
		*pdata=UDR;
    1e50:	ec e2       	ldi	r30, 0x2C	; 44
    1e52:	f0 e0       	ldi	r31, 0x00	; 0
    1e54:	80 81       	ld	r24, Z
    1e56:	e9 81       	ldd	r30, Y+1	; 0x01
    1e58:	fa 81       	ldd	r31, Y+2	; 0x02
    1e5a:	80 83       	st	Z, r24
		return 1 ;
    1e5c:	81 e0       	ldi	r24, 0x01	; 1
    1e5e:	8b 83       	std	Y+3, r24	; 0x03
    1e60:	01 c0       	rjmp	.+2      	; 0x1e64 <UART_ReceivePerodic+0x2e>
	}
	return 0;
    1e62:	1b 82       	std	Y+3, r1	; 0x03
    1e64:	8b 81       	ldd	r24, Y+3	; 0x03
	
}
    1e66:	0f 90       	pop	r0
    1e68:	0f 90       	pop	r0
    1e6a:	0f 90       	pop	r0
    1e6c:	cf 91       	pop	r28
    1e6e:	df 91       	pop	r29
    1e70:	08 95       	ret

00001e72 <UART_SendString>:

/* synch function */
void UART_SendString(u8*str)
{
    1e72:	df 93       	push	r29
    1e74:	cf 93       	push	r28
    1e76:	00 d0       	rcall	.+0      	; 0x1e78 <UART_SendString+0x6>
    1e78:	0f 92       	push	r0
    1e7a:	cd b7       	in	r28, 0x3d	; 61
    1e7c:	de b7       	in	r29, 0x3e	; 62
    1e7e:	9b 83       	std	Y+3, r25	; 0x03
    1e80:	8a 83       	std	Y+2, r24	; 0x02
	u8 i;
	for (i=0;str[i];i++)
    1e82:	19 82       	std	Y+1, r1	; 0x01
    1e84:	0e c0       	rjmp	.+28     	; 0x1ea2 <UART_SendString+0x30>
	{
		UART_Send(str[i]);
    1e86:	89 81       	ldd	r24, Y+1	; 0x01
    1e88:	28 2f       	mov	r18, r24
    1e8a:	30 e0       	ldi	r19, 0x00	; 0
    1e8c:	8a 81       	ldd	r24, Y+2	; 0x02
    1e8e:	9b 81       	ldd	r25, Y+3	; 0x03
    1e90:	fc 01       	movw	r30, r24
    1e92:	e2 0f       	add	r30, r18
    1e94:	f3 1f       	adc	r31, r19
    1e96:	80 81       	ld	r24, Z
    1e98:	0e 94 e3 0e 	call	0x1dc6	; 0x1dc6 <UART_Send>

/* synch function */
void UART_SendString(u8*str)
{
	u8 i;
	for (i=0;str[i];i++)
    1e9c:	89 81       	ldd	r24, Y+1	; 0x01
    1e9e:	8f 5f       	subi	r24, 0xFF	; 255
    1ea0:	89 83       	std	Y+1, r24	; 0x01
    1ea2:	89 81       	ldd	r24, Y+1	; 0x01
    1ea4:	28 2f       	mov	r18, r24
    1ea6:	30 e0       	ldi	r19, 0x00	; 0
    1ea8:	8a 81       	ldd	r24, Y+2	; 0x02
    1eaa:	9b 81       	ldd	r25, Y+3	; 0x03
    1eac:	fc 01       	movw	r30, r24
    1eae:	e2 0f       	add	r30, r18
    1eb0:	f3 1f       	adc	r31, r19
    1eb2:	80 81       	ld	r24, Z
    1eb4:	88 23       	and	r24, r24
    1eb6:	39 f7       	brne	.-50     	; 0x1e86 <UART_SendString+0x14>
	{
		UART_Send(str[i]);
		
	}
}
    1eb8:	0f 90       	pop	r0
    1eba:	0f 90       	pop	r0
    1ebc:	0f 90       	pop	r0
    1ebe:	cf 91       	pop	r28
    1ec0:	df 91       	pop	r29
    1ec2:	08 95       	ret

00001ec4 <UART_ReceiveString>:

void UART_ReceiveString(u8*str)
{
    1ec4:	0f 93       	push	r16
    1ec6:	1f 93       	push	r17
    1ec8:	df 93       	push	r29
    1eca:	cf 93       	push	r28
    1ecc:	00 d0       	rcall	.+0      	; 0x1ece <UART_ReceiveString+0xa>
    1ece:	0f 92       	push	r0
    1ed0:	cd b7       	in	r28, 0x3d	; 61
    1ed2:	de b7       	in	r29, 0x3e	; 62
    1ed4:	9b 83       	std	Y+3, r25	; 0x03
    1ed6:	8a 83       	std	Y+2, r24	; 0x02
	u8 i=0;
    1ed8:	19 82       	std	Y+1, r1	; 0x01
	str[i]=UART_Receive();
    1eda:	89 81       	ldd	r24, Y+1	; 0x01
    1edc:	28 2f       	mov	r18, r24
    1ede:	30 e0       	ldi	r19, 0x00	; 0
    1ee0:	8a 81       	ldd	r24, Y+2	; 0x02
    1ee2:	9b 81       	ldd	r25, Y+3	; 0x03
    1ee4:	8c 01       	movw	r16, r24
    1ee6:	02 0f       	add	r16, r18
    1ee8:	13 1f       	adc	r17, r19
    1eea:	0e 94 0c 0f 	call	0x1e18	; 0x1e18 <UART_Receive>
    1eee:	f8 01       	movw	r30, r16
    1ef0:	80 83       	st	Z, r24
    1ef2:	0f c0       	rjmp	.+30     	; 0x1f12 <UART_ReceiveString+0x4e>
	for (;str[i]!=0x0d;)
	{
		i++;
    1ef4:	89 81       	ldd	r24, Y+1	; 0x01
    1ef6:	8f 5f       	subi	r24, 0xFF	; 255
    1ef8:	89 83       	std	Y+1, r24	; 0x01
		str[i]=UART_Receive();
    1efa:	89 81       	ldd	r24, Y+1	; 0x01
    1efc:	28 2f       	mov	r18, r24
    1efe:	30 e0       	ldi	r19, 0x00	; 0
    1f00:	8a 81       	ldd	r24, Y+2	; 0x02
    1f02:	9b 81       	ldd	r25, Y+3	; 0x03
    1f04:	8c 01       	movw	r16, r24
    1f06:	02 0f       	add	r16, r18
    1f08:	13 1f       	adc	r17, r19
    1f0a:	0e 94 0c 0f 	call	0x1e18	; 0x1e18 <UART_Receive>
    1f0e:	f8 01       	movw	r30, r16
    1f10:	80 83       	st	Z, r24

void UART_ReceiveString(u8*str)
{
	u8 i=0;
	str[i]=UART_Receive();
	for (;str[i]!=0x0d;)
    1f12:	89 81       	ldd	r24, Y+1	; 0x01
    1f14:	28 2f       	mov	r18, r24
    1f16:	30 e0       	ldi	r19, 0x00	; 0
    1f18:	8a 81       	ldd	r24, Y+2	; 0x02
    1f1a:	9b 81       	ldd	r25, Y+3	; 0x03
    1f1c:	fc 01       	movw	r30, r24
    1f1e:	e2 0f       	add	r30, r18
    1f20:	f3 1f       	adc	r31, r19
    1f22:	80 81       	ld	r24, Z
    1f24:	8d 30       	cpi	r24, 0x0D	; 13
    1f26:	31 f7       	brne	.-52     	; 0x1ef4 <UART_ReceiveString+0x30>
	{
		i++;
		str[i]=UART_Receive();
	}
	str[i]=0;
    1f28:	89 81       	ldd	r24, Y+1	; 0x01
    1f2a:	28 2f       	mov	r18, r24
    1f2c:	30 e0       	ldi	r19, 0x00	; 0
    1f2e:	8a 81       	ldd	r24, Y+2	; 0x02
    1f30:	9b 81       	ldd	r25, Y+3	; 0x03
    1f32:	fc 01       	movw	r30, r24
    1f34:	e2 0f       	add	r30, r18
    1f36:	f3 1f       	adc	r31, r19
    1f38:	10 82       	st	Z, r1

}
    1f3a:	0f 90       	pop	r0
    1f3c:	0f 90       	pop	r0
    1f3e:	0f 90       	pop	r0
    1f40:	cf 91       	pop	r28
    1f42:	df 91       	pop	r29
    1f44:	1f 91       	pop	r17
    1f46:	0f 91       	pop	r16
    1f48:	08 95       	ret

00001f4a <WDT_set>:
#include <avr/io.h>
#include"../STD_TYPES.h"
#include"../Utils.h"

void WDT_set(TimeOut_type time)
{
    1f4a:	df 93       	push	r29
    1f4c:	cf 93       	push	r28
    1f4e:	00 d0       	rcall	.+0      	; 0x1f50 <WDT_set+0x6>
    1f50:	cd b7       	in	r28, 0x3d	; 61
    1f52:	de b7       	in	r29, 0x3e	; 62
    1f54:	8a 83       	std	Y+2, r24	; 0x02
	u8 wdt_value=0x08;              //WDE SET && WDTOE CLEAR 0000 1000
    1f56:	88 e0       	ldi	r24, 0x08	; 8
    1f58:	89 83       	std	Y+1, r24	; 0x01
	wdt_value|=time;               // 0000 1011
    1f5a:	99 81       	ldd	r25, Y+1	; 0x01
    1f5c:	8a 81       	ldd	r24, Y+2	; 0x02
    1f5e:	89 2b       	or	r24, r25
    1f60:	89 83       	std	Y+1, r24	; 0x01
	WDTCR=wdt_value;
    1f62:	e1 e4       	ldi	r30, 0x41	; 65
    1f64:	f0 e0       	ldi	r31, 0x00	; 0
    1f66:	89 81       	ldd	r24, Y+1	; 0x01
    1f68:	80 83       	st	Z, r24
}
    1f6a:	0f 90       	pop	r0
    1f6c:	0f 90       	pop	r0
    1f6e:	cf 91       	pop	r28
    1f70:	df 91       	pop	r29
    1f72:	08 95       	ret

00001f74 <WDT_stop>:


void WDT_stop(void)
{
    1f74:	df 93       	push	r29
    1f76:	cf 93       	push	r28
    1f78:	cd b7       	in	r28, 0x3d	; 61
    1f7a:	de b7       	in	r29, 0x3e	; 62
	WDTCR|=(1<<WDE)|(1<<WDTOE);
    1f7c:	a1 e4       	ldi	r26, 0x41	; 65
    1f7e:	b0 e0       	ldi	r27, 0x00	; 0
    1f80:	e1 e4       	ldi	r30, 0x41	; 65
    1f82:	f0 e0       	ldi	r31, 0x00	; 0
    1f84:	80 81       	ld	r24, Z
    1f86:	88 61       	ori	r24, 0x18	; 24
    1f88:	8c 93       	st	X, r24
	WDTCR=0;
    1f8a:	e1 e4       	ldi	r30, 0x41	; 65
    1f8c:	f0 e0       	ldi	r31, 0x00	; 0
    1f8e:	10 82       	st	Z, r1

}
    1f90:	cf 91       	pop	r28
    1f92:	df 91       	pop	r29
    1f94:	08 95       	ret

00001f96 <Keypad_Init>:

#define KEYPAD_PROG
#include "Keypad.h"

void Keypad_Init(void)
{
    1f96:	df 93       	push	r29
    1f98:	cf 93       	push	r28
    1f9a:	cd b7       	in	r28, 0x3d	; 61
    1f9c:	de b7       	in	r29, 0x3e	; 62
	DIO_WritePin(FRIST_OUTPUT,HIGH);
    1f9e:	8b e0       	ldi	r24, 0x0B	; 11
    1fa0:	61 e0       	ldi	r22, 0x01	; 1
    1fa2:	0e 94 f9 09 	call	0x13f2	; 0x13f2 <DIO_WritePin>
	DIO_WritePin(FRIST_OUTPUT+1,HIGH);
    1fa6:	8c e0       	ldi	r24, 0x0C	; 12
    1fa8:	61 e0       	ldi	r22, 0x01	; 1
    1faa:	0e 94 f9 09 	call	0x13f2	; 0x13f2 <DIO_WritePin>
	DIO_WritePin(FRIST_OUTPUT+2,HIGH);
    1fae:	8d e0       	ldi	r24, 0x0D	; 13
    1fb0:	61 e0       	ldi	r22, 0x01	; 1
    1fb2:	0e 94 f9 09 	call	0x13f2	; 0x13f2 <DIO_WritePin>
	DIO_WritePin(FRIST_OUTPUT+3,HIGH);
    1fb6:	8e e0       	ldi	r24, 0x0E	; 14
    1fb8:	61 e0       	ldi	r22, 0x01	; 1
    1fba:	0e 94 f9 09 	call	0x13f2	; 0x13f2 <DIO_WritePin>
}
    1fbe:	cf 91       	pop	r28
    1fc0:	df 91       	pop	r29
    1fc2:	08 95       	ret

00001fc4 <Keypad_Getkey>:



u8 Keypad_Getkey(void)
{
    1fc4:	df 93       	push	r29
    1fc6:	cf 93       	push	r28
    1fc8:	00 d0       	rcall	.+0      	; 0x1fca <Keypad_Getkey+0x6>
    1fca:	0f 92       	push	r0
    1fcc:	cd b7       	in	r28, 0x3d	; 61
    1fce:	de b7       	in	r29, 0x3e	; 62
	u8 r,c,key=NO_KEY;
    1fd0:	81 e4       	ldi	r24, 0x41	; 65
    1fd2:	89 83       	std	Y+1, r24	; 0x01
   for(r=0;r<ROW;r++)
    1fd4:	1b 82       	std	Y+3, r1	; 0x03
    1fd6:	33 c0       	rjmp	.+102    	; 0x203e <Keypad_Getkey+0x7a>
   {
	   DIO_WritePin(FRIST_OUTPUT+r,LOW);
    1fd8:	8b 81       	ldd	r24, Y+3	; 0x03
    1fda:	85 5f       	subi	r24, 0xF5	; 245
    1fdc:	60 e0       	ldi	r22, 0x00	; 0
    1fde:	0e 94 f9 09 	call	0x13f2	; 0x13f2 <DIO_WritePin>

	   for(c=0;c<COL;c++)
    1fe2:	1a 82       	std	Y+2, r1	; 0x02
    1fe4:	21 c0       	rjmp	.+66     	; 0x2028 <Keypad_Getkey+0x64>
	   {
		   if(DIO_ReadPin(FRIST_INPUT+c)==LOW)
    1fe6:	8a 81       	ldd	r24, Y+2	; 0x02
    1fe8:	84 5e       	subi	r24, 0xE4	; 228
    1fea:	0e 94 ff 0a 	call	0x15fe	; 0x15fe <DIO_ReadPin>
    1fee:	88 23       	and	r24, r24
    1ff0:	c1 f4       	brne	.+48     	; 0x2022 <Keypad_Getkey+0x5e>
		   {
			   key=sss[r][c];
    1ff2:	8b 81       	ldd	r24, Y+3	; 0x03
    1ff4:	48 2f       	mov	r20, r24
    1ff6:	50 e0       	ldi	r21, 0x00	; 0
    1ff8:	8a 81       	ldd	r24, Y+2	; 0x02
    1ffa:	28 2f       	mov	r18, r24
    1ffc:	30 e0       	ldi	r19, 0x00	; 0
    1ffe:	ca 01       	movw	r24, r20
    2000:	88 0f       	add	r24, r24
    2002:	99 1f       	adc	r25, r25
    2004:	88 0f       	add	r24, r24
    2006:	99 1f       	adc	r25, r25
    2008:	82 0f       	add	r24, r18
    200a:	93 1f       	adc	r25, r19
    200c:	fc 01       	movw	r30, r24
    200e:	ec 5e       	subi	r30, 0xEC	; 236
    2010:	fe 4f       	sbci	r31, 0xFE	; 254
    2012:	80 81       	ld	r24, Z
    2014:	89 83       	std	Y+1, r24	; 0x01
			   while(DIO_ReadPin(FRIST_INPUT+c)==LOW);
    2016:	8a 81       	ldd	r24, Y+2	; 0x02
    2018:	84 5e       	subi	r24, 0xE4	; 228
    201a:	0e 94 ff 0a 	call	0x15fe	; 0x15fe <DIO_ReadPin>
    201e:	88 23       	and	r24, r24
    2020:	d1 f3       	breq	.-12     	; 0x2016 <Keypad_Getkey+0x52>
	u8 r,c,key=NO_KEY;
   for(r=0;r<ROW;r++)
   {
	   DIO_WritePin(FRIST_OUTPUT+r,LOW);

	   for(c=0;c<COL;c++)
    2022:	8a 81       	ldd	r24, Y+2	; 0x02
    2024:	8f 5f       	subi	r24, 0xFF	; 255
    2026:	8a 83       	std	Y+2, r24	; 0x02
    2028:	8a 81       	ldd	r24, Y+2	; 0x02
    202a:	84 30       	cpi	r24, 0x04	; 4
    202c:	e0 f2       	brcs	.-72     	; 0x1fe6 <Keypad_Getkey+0x22>
		   {
			   key=sss[r][c];
			   while(DIO_ReadPin(FRIST_INPUT+c)==LOW);
		   }
	   }
	   DIO_WritePin(FRIST_OUTPUT+r,HIGH);
    202e:	8b 81       	ldd	r24, Y+3	; 0x03
    2030:	85 5f       	subi	r24, 0xF5	; 245
    2032:	61 e0       	ldi	r22, 0x01	; 1
    2034:	0e 94 f9 09 	call	0x13f2	; 0x13f2 <DIO_WritePin>


u8 Keypad_Getkey(void)
{
	u8 r,c,key=NO_KEY;
   for(r=0;r<ROW;r++)
    2038:	8b 81       	ldd	r24, Y+3	; 0x03
    203a:	8f 5f       	subi	r24, 0xFF	; 255
    203c:	8b 83       	std	Y+3, r24	; 0x03
    203e:	8b 81       	ldd	r24, Y+3	; 0x03
    2040:	84 30       	cpi	r24, 0x04	; 4
    2042:	50 f2       	brcs	.-108    	; 0x1fd8 <Keypad_Getkey+0x14>
		   }
	   }
	   DIO_WritePin(FRIST_OUTPUT+r,HIGH);
   }

   return key;
    2044:	89 81       	ldd	r24, Y+1	; 0x01

}
    2046:	0f 90       	pop	r0
    2048:	0f 90       	pop	r0
    204a:	0f 90       	pop	r0
    204c:	cf 91       	pop	r28
    204e:	df 91       	pop	r29
    2050:	08 95       	ret

00002052 <LCD_WriteInstruction>:
#include "LCD.h"




static void LCD_WriteInstruction(u8 cmd){
    2052:	df 93       	push	r29
    2054:	cf 93       	push	r28
    2056:	cd b7       	in	r28, 0x3d	; 61
    2058:	de b7       	in	r29, 0x3e	; 62
    205a:	ab 97       	sbiw	r28, 0x2b	; 43
    205c:	0f b6       	in	r0, 0x3f	; 63
    205e:	f8 94       	cli
    2060:	de bf       	out	0x3e, r29	; 62
    2062:	0f be       	out	0x3f, r0	; 63
    2064:	cd bf       	out	0x3d, r28	; 61
    2066:	8b a7       	std	Y+43, r24	; 0x2b
	DIO_WritePin(RS,LOW);
    2068:	88 e0       	ldi	r24, 0x08	; 8
    206a:	60 e0       	ldi	r22, 0x00	; 0
    206c:	0e 94 f9 09 	call	0x13f2	; 0x13f2 <DIO_WritePin>
	DIO_WritePort(PA,cmd);
    2070:	80 e0       	ldi	r24, 0x00	; 0
    2072:	6b a5       	ldd	r22, Y+43	; 0x2b
    2074:	0e 94 23 0c 	call	0x1846	; 0x1846 <DIO_WritePort>
    2078:	80 e0       	ldi	r24, 0x00	; 0
    207a:	90 e0       	ldi	r25, 0x00	; 0
    207c:	a0 e8       	ldi	r26, 0x80	; 128
    207e:	bf e3       	ldi	r27, 0x3F	; 63
    2080:	8f a3       	std	Y+39, r24	; 0x27
    2082:	98 a7       	std	Y+40, r25	; 0x28
    2084:	a9 a7       	std	Y+41, r26	; 0x29
    2086:	ba a7       	std	Y+42, r27	; 0x2a
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    2088:	6f a1       	ldd	r22, Y+39	; 0x27
    208a:	78 a5       	ldd	r23, Y+40	; 0x28
    208c:	89 a5       	ldd	r24, Y+41	; 0x29
    208e:	9a a5       	ldd	r25, Y+42	; 0x2a
    2090:	20 e0       	ldi	r18, 0x00	; 0
    2092:	30 e0       	ldi	r19, 0x00	; 0
    2094:	4a ef       	ldi	r20, 0xFA	; 250
    2096:	54 e4       	ldi	r21, 0x44	; 68
    2098:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    209c:	dc 01       	movw	r26, r24
    209e:	cb 01       	movw	r24, r22
    20a0:	8b a3       	std	Y+35, r24	; 0x23
    20a2:	9c a3       	std	Y+36, r25	; 0x24
    20a4:	ad a3       	std	Y+37, r26	; 0x25
    20a6:	be a3       	std	Y+38, r27	; 0x26
	if (__tmp < 1.0)
    20a8:	6b a1       	ldd	r22, Y+35	; 0x23
    20aa:	7c a1       	ldd	r23, Y+36	; 0x24
    20ac:	8d a1       	ldd	r24, Y+37	; 0x25
    20ae:	9e a1       	ldd	r25, Y+38	; 0x26
    20b0:	20 e0       	ldi	r18, 0x00	; 0
    20b2:	30 e0       	ldi	r19, 0x00	; 0
    20b4:	40 e8       	ldi	r20, 0x80	; 128
    20b6:	5f e3       	ldi	r21, 0x3F	; 63
    20b8:	0e 94 79 03 	call	0x6f2	; 0x6f2 <__ltsf2>
    20bc:	88 23       	and	r24, r24
    20be:	2c f4       	brge	.+10     	; 0x20ca <LCD_WriteInstruction+0x78>
		__ticks = 1;
    20c0:	81 e0       	ldi	r24, 0x01	; 1
    20c2:	90 e0       	ldi	r25, 0x00	; 0
    20c4:	9a a3       	std	Y+34, r25	; 0x22
    20c6:	89 a3       	std	Y+33, r24	; 0x21
    20c8:	3f c0       	rjmp	.+126    	; 0x2148 <LCD_WriteInstruction+0xf6>
	else if (__tmp > 65535)
    20ca:	6b a1       	ldd	r22, Y+35	; 0x23
    20cc:	7c a1       	ldd	r23, Y+36	; 0x24
    20ce:	8d a1       	ldd	r24, Y+37	; 0x25
    20d0:	9e a1       	ldd	r25, Y+38	; 0x26
    20d2:	20 e0       	ldi	r18, 0x00	; 0
    20d4:	3f ef       	ldi	r19, 0xFF	; 255
    20d6:	4f e7       	ldi	r20, 0x7F	; 127
    20d8:	57 e4       	ldi	r21, 0x47	; 71
    20da:	0e 94 19 03 	call	0x632	; 0x632 <__gtsf2>
    20de:	18 16       	cp	r1, r24
    20e0:	4c f5       	brge	.+82     	; 0x2134 <LCD_WriteInstruction+0xe2>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    20e2:	6f a1       	ldd	r22, Y+39	; 0x27
    20e4:	78 a5       	ldd	r23, Y+40	; 0x28
    20e6:	89 a5       	ldd	r24, Y+41	; 0x29
    20e8:	9a a5       	ldd	r25, Y+42	; 0x2a
    20ea:	20 e0       	ldi	r18, 0x00	; 0
    20ec:	30 e0       	ldi	r19, 0x00	; 0
    20ee:	40 e2       	ldi	r20, 0x20	; 32
    20f0:	51 e4       	ldi	r21, 0x41	; 65
    20f2:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    20f6:	dc 01       	movw	r26, r24
    20f8:	cb 01       	movw	r24, r22
    20fa:	bc 01       	movw	r22, r24
    20fc:	cd 01       	movw	r24, r26
    20fe:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    2102:	dc 01       	movw	r26, r24
    2104:	cb 01       	movw	r24, r22
    2106:	9a a3       	std	Y+34, r25	; 0x22
    2108:	89 a3       	std	Y+33, r24	; 0x21
    210a:	0f c0       	rjmp	.+30     	; 0x212a <LCD_WriteInstruction+0xd8>
    210c:	88 ec       	ldi	r24, 0xC8	; 200
    210e:	90 e0       	ldi	r25, 0x00	; 0
    2110:	98 a3       	std	Y+32, r25	; 0x20
    2112:	8f 8f       	std	Y+31, r24	; 0x1f
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    2114:	8f 8d       	ldd	r24, Y+31	; 0x1f
    2116:	98 a1       	ldd	r25, Y+32	; 0x20
    2118:	01 97       	sbiw	r24, 0x01	; 1
    211a:	f1 f7       	brne	.-4      	; 0x2118 <LCD_WriteInstruction+0xc6>
    211c:	98 a3       	std	Y+32, r25	; 0x20
    211e:	8f 8f       	std	Y+31, r24	; 0x1f
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    2120:	89 a1       	ldd	r24, Y+33	; 0x21
    2122:	9a a1       	ldd	r25, Y+34	; 0x22
    2124:	01 97       	sbiw	r24, 0x01	; 1
    2126:	9a a3       	std	Y+34, r25	; 0x22
    2128:	89 a3       	std	Y+33, r24	; 0x21
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    212a:	89 a1       	ldd	r24, Y+33	; 0x21
    212c:	9a a1       	ldd	r25, Y+34	; 0x22
    212e:	00 97       	sbiw	r24, 0x00	; 0
    2130:	69 f7       	brne	.-38     	; 0x210c <LCD_WriteInstruction+0xba>
    2132:	14 c0       	rjmp	.+40     	; 0x215c <LCD_WriteInstruction+0x10a>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    2134:	6b a1       	ldd	r22, Y+35	; 0x23
    2136:	7c a1       	ldd	r23, Y+36	; 0x24
    2138:	8d a1       	ldd	r24, Y+37	; 0x25
    213a:	9e a1       	ldd	r25, Y+38	; 0x26
    213c:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    2140:	dc 01       	movw	r26, r24
    2142:	cb 01       	movw	r24, r22
    2144:	9a a3       	std	Y+34, r25	; 0x22
    2146:	89 a3       	std	Y+33, r24	; 0x21
    2148:	89 a1       	ldd	r24, Y+33	; 0x21
    214a:	9a a1       	ldd	r25, Y+34	; 0x22
    214c:	9e 8f       	std	Y+30, r25	; 0x1e
    214e:	8d 8f       	std	Y+29, r24	; 0x1d
    2150:	8d 8d       	ldd	r24, Y+29	; 0x1d
    2152:	9e 8d       	ldd	r25, Y+30	; 0x1e
    2154:	01 97       	sbiw	r24, 0x01	; 1
    2156:	f1 f7       	brne	.-4      	; 0x2154 <LCD_WriteInstruction+0x102>
    2158:	9e 8f       	std	Y+30, r25	; 0x1e
    215a:	8d 8f       	std	Y+29, r24	; 0x1d
	_delay_ms(1);
	DIO_WritePin(EN,HIGH);
    215c:	89 e0       	ldi	r24, 0x09	; 9
    215e:	61 e0       	ldi	r22, 0x01	; 1
    2160:	0e 94 f9 09 	call	0x13f2	; 0x13f2 <DIO_WritePin>
    2164:	80 e0       	ldi	r24, 0x00	; 0
    2166:	90 e0       	ldi	r25, 0x00	; 0
    2168:	a0 e8       	ldi	r26, 0x80	; 128
    216a:	bf e3       	ldi	r27, 0x3F	; 63
    216c:	89 8f       	std	Y+25, r24	; 0x19
    216e:	9a 8f       	std	Y+26, r25	; 0x1a
    2170:	ab 8f       	std	Y+27, r26	; 0x1b
    2172:	bc 8f       	std	Y+28, r27	; 0x1c
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    2174:	69 8d       	ldd	r22, Y+25	; 0x19
    2176:	7a 8d       	ldd	r23, Y+26	; 0x1a
    2178:	8b 8d       	ldd	r24, Y+27	; 0x1b
    217a:	9c 8d       	ldd	r25, Y+28	; 0x1c
    217c:	20 e0       	ldi	r18, 0x00	; 0
    217e:	30 e0       	ldi	r19, 0x00	; 0
    2180:	4a ef       	ldi	r20, 0xFA	; 250
    2182:	54 e4       	ldi	r21, 0x44	; 68
    2184:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    2188:	dc 01       	movw	r26, r24
    218a:	cb 01       	movw	r24, r22
    218c:	8d 8b       	std	Y+21, r24	; 0x15
    218e:	9e 8b       	std	Y+22, r25	; 0x16
    2190:	af 8b       	std	Y+23, r26	; 0x17
    2192:	b8 8f       	std	Y+24, r27	; 0x18
	if (__tmp < 1.0)
    2194:	6d 89       	ldd	r22, Y+21	; 0x15
    2196:	7e 89       	ldd	r23, Y+22	; 0x16
    2198:	8f 89       	ldd	r24, Y+23	; 0x17
    219a:	98 8d       	ldd	r25, Y+24	; 0x18
    219c:	20 e0       	ldi	r18, 0x00	; 0
    219e:	30 e0       	ldi	r19, 0x00	; 0
    21a0:	40 e8       	ldi	r20, 0x80	; 128
    21a2:	5f e3       	ldi	r21, 0x3F	; 63
    21a4:	0e 94 79 03 	call	0x6f2	; 0x6f2 <__ltsf2>
    21a8:	88 23       	and	r24, r24
    21aa:	2c f4       	brge	.+10     	; 0x21b6 <LCD_WriteInstruction+0x164>
		__ticks = 1;
    21ac:	81 e0       	ldi	r24, 0x01	; 1
    21ae:	90 e0       	ldi	r25, 0x00	; 0
    21b0:	9c 8b       	std	Y+20, r25	; 0x14
    21b2:	8b 8b       	std	Y+19, r24	; 0x13
    21b4:	3f c0       	rjmp	.+126    	; 0x2234 <LCD_WriteInstruction+0x1e2>
	else if (__tmp > 65535)
    21b6:	6d 89       	ldd	r22, Y+21	; 0x15
    21b8:	7e 89       	ldd	r23, Y+22	; 0x16
    21ba:	8f 89       	ldd	r24, Y+23	; 0x17
    21bc:	98 8d       	ldd	r25, Y+24	; 0x18
    21be:	20 e0       	ldi	r18, 0x00	; 0
    21c0:	3f ef       	ldi	r19, 0xFF	; 255
    21c2:	4f e7       	ldi	r20, 0x7F	; 127
    21c4:	57 e4       	ldi	r21, 0x47	; 71
    21c6:	0e 94 19 03 	call	0x632	; 0x632 <__gtsf2>
    21ca:	18 16       	cp	r1, r24
    21cc:	4c f5       	brge	.+82     	; 0x2220 <LCD_WriteInstruction+0x1ce>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    21ce:	69 8d       	ldd	r22, Y+25	; 0x19
    21d0:	7a 8d       	ldd	r23, Y+26	; 0x1a
    21d2:	8b 8d       	ldd	r24, Y+27	; 0x1b
    21d4:	9c 8d       	ldd	r25, Y+28	; 0x1c
    21d6:	20 e0       	ldi	r18, 0x00	; 0
    21d8:	30 e0       	ldi	r19, 0x00	; 0
    21da:	40 e2       	ldi	r20, 0x20	; 32
    21dc:	51 e4       	ldi	r21, 0x41	; 65
    21de:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    21e2:	dc 01       	movw	r26, r24
    21e4:	cb 01       	movw	r24, r22
    21e6:	bc 01       	movw	r22, r24
    21e8:	cd 01       	movw	r24, r26
    21ea:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    21ee:	dc 01       	movw	r26, r24
    21f0:	cb 01       	movw	r24, r22
    21f2:	9c 8b       	std	Y+20, r25	; 0x14
    21f4:	8b 8b       	std	Y+19, r24	; 0x13
    21f6:	0f c0       	rjmp	.+30     	; 0x2216 <LCD_WriteInstruction+0x1c4>
    21f8:	88 ec       	ldi	r24, 0xC8	; 200
    21fa:	90 e0       	ldi	r25, 0x00	; 0
    21fc:	9a 8b       	std	Y+18, r25	; 0x12
    21fe:	89 8b       	std	Y+17, r24	; 0x11
    2200:	89 89       	ldd	r24, Y+17	; 0x11
    2202:	9a 89       	ldd	r25, Y+18	; 0x12
    2204:	01 97       	sbiw	r24, 0x01	; 1
    2206:	f1 f7       	brne	.-4      	; 0x2204 <LCD_WriteInstruction+0x1b2>
    2208:	9a 8b       	std	Y+18, r25	; 0x12
    220a:	89 8b       	std	Y+17, r24	; 0x11
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    220c:	8b 89       	ldd	r24, Y+19	; 0x13
    220e:	9c 89       	ldd	r25, Y+20	; 0x14
    2210:	01 97       	sbiw	r24, 0x01	; 1
    2212:	9c 8b       	std	Y+20, r25	; 0x14
    2214:	8b 8b       	std	Y+19, r24	; 0x13
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    2216:	8b 89       	ldd	r24, Y+19	; 0x13
    2218:	9c 89       	ldd	r25, Y+20	; 0x14
    221a:	00 97       	sbiw	r24, 0x00	; 0
    221c:	69 f7       	brne	.-38     	; 0x21f8 <LCD_WriteInstruction+0x1a6>
    221e:	14 c0       	rjmp	.+40     	; 0x2248 <LCD_WriteInstruction+0x1f6>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    2220:	6d 89       	ldd	r22, Y+21	; 0x15
    2222:	7e 89       	ldd	r23, Y+22	; 0x16
    2224:	8f 89       	ldd	r24, Y+23	; 0x17
    2226:	98 8d       	ldd	r25, Y+24	; 0x18
    2228:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    222c:	dc 01       	movw	r26, r24
    222e:	cb 01       	movw	r24, r22
    2230:	9c 8b       	std	Y+20, r25	; 0x14
    2232:	8b 8b       	std	Y+19, r24	; 0x13
    2234:	8b 89       	ldd	r24, Y+19	; 0x13
    2236:	9c 89       	ldd	r25, Y+20	; 0x14
    2238:	98 8b       	std	Y+16, r25	; 0x10
    223a:	8f 87       	std	Y+15, r24	; 0x0f
    223c:	8f 85       	ldd	r24, Y+15	; 0x0f
    223e:	98 89       	ldd	r25, Y+16	; 0x10
    2240:	01 97       	sbiw	r24, 0x01	; 1
    2242:	f1 f7       	brne	.-4      	; 0x2240 <LCD_WriteInstruction+0x1ee>
    2244:	98 8b       	std	Y+16, r25	; 0x10
    2246:	8f 87       	std	Y+15, r24	; 0x0f
	_delay_ms(1);
	DIO_WritePin(EN,LOW);
    2248:	89 e0       	ldi	r24, 0x09	; 9
    224a:	60 e0       	ldi	r22, 0x00	; 0
    224c:	0e 94 f9 09 	call	0x13f2	; 0x13f2 <DIO_WritePin>
    2250:	80 e0       	ldi	r24, 0x00	; 0
    2252:	90 e0       	ldi	r25, 0x00	; 0
    2254:	a0 e8       	ldi	r26, 0x80	; 128
    2256:	bf e3       	ldi	r27, 0x3F	; 63
    2258:	8b 87       	std	Y+11, r24	; 0x0b
    225a:	9c 87       	std	Y+12, r25	; 0x0c
    225c:	ad 87       	std	Y+13, r26	; 0x0d
    225e:	be 87       	std	Y+14, r27	; 0x0e
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    2260:	6b 85       	ldd	r22, Y+11	; 0x0b
    2262:	7c 85       	ldd	r23, Y+12	; 0x0c
    2264:	8d 85       	ldd	r24, Y+13	; 0x0d
    2266:	9e 85       	ldd	r25, Y+14	; 0x0e
    2268:	20 e0       	ldi	r18, 0x00	; 0
    226a:	30 e0       	ldi	r19, 0x00	; 0
    226c:	4a ef       	ldi	r20, 0xFA	; 250
    226e:	54 e4       	ldi	r21, 0x44	; 68
    2270:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    2274:	dc 01       	movw	r26, r24
    2276:	cb 01       	movw	r24, r22
    2278:	8f 83       	std	Y+7, r24	; 0x07
    227a:	98 87       	std	Y+8, r25	; 0x08
    227c:	a9 87       	std	Y+9, r26	; 0x09
    227e:	ba 87       	std	Y+10, r27	; 0x0a
	if (__tmp < 1.0)
    2280:	6f 81       	ldd	r22, Y+7	; 0x07
    2282:	78 85       	ldd	r23, Y+8	; 0x08
    2284:	89 85       	ldd	r24, Y+9	; 0x09
    2286:	9a 85       	ldd	r25, Y+10	; 0x0a
    2288:	20 e0       	ldi	r18, 0x00	; 0
    228a:	30 e0       	ldi	r19, 0x00	; 0
    228c:	40 e8       	ldi	r20, 0x80	; 128
    228e:	5f e3       	ldi	r21, 0x3F	; 63
    2290:	0e 94 79 03 	call	0x6f2	; 0x6f2 <__ltsf2>
    2294:	88 23       	and	r24, r24
    2296:	2c f4       	brge	.+10     	; 0x22a2 <LCD_WriteInstruction+0x250>
		__ticks = 1;
    2298:	81 e0       	ldi	r24, 0x01	; 1
    229a:	90 e0       	ldi	r25, 0x00	; 0
    229c:	9e 83       	std	Y+6, r25	; 0x06
    229e:	8d 83       	std	Y+5, r24	; 0x05
    22a0:	3f c0       	rjmp	.+126    	; 0x2320 <LCD_WriteInstruction+0x2ce>
	else if (__tmp > 65535)
    22a2:	6f 81       	ldd	r22, Y+7	; 0x07
    22a4:	78 85       	ldd	r23, Y+8	; 0x08
    22a6:	89 85       	ldd	r24, Y+9	; 0x09
    22a8:	9a 85       	ldd	r25, Y+10	; 0x0a
    22aa:	20 e0       	ldi	r18, 0x00	; 0
    22ac:	3f ef       	ldi	r19, 0xFF	; 255
    22ae:	4f e7       	ldi	r20, 0x7F	; 127
    22b0:	57 e4       	ldi	r21, 0x47	; 71
    22b2:	0e 94 19 03 	call	0x632	; 0x632 <__gtsf2>
    22b6:	18 16       	cp	r1, r24
    22b8:	4c f5       	brge	.+82     	; 0x230c <LCD_WriteInstruction+0x2ba>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    22ba:	6b 85       	ldd	r22, Y+11	; 0x0b
    22bc:	7c 85       	ldd	r23, Y+12	; 0x0c
    22be:	8d 85       	ldd	r24, Y+13	; 0x0d
    22c0:	9e 85       	ldd	r25, Y+14	; 0x0e
    22c2:	20 e0       	ldi	r18, 0x00	; 0
    22c4:	30 e0       	ldi	r19, 0x00	; 0
    22c6:	40 e2       	ldi	r20, 0x20	; 32
    22c8:	51 e4       	ldi	r21, 0x41	; 65
    22ca:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    22ce:	dc 01       	movw	r26, r24
    22d0:	cb 01       	movw	r24, r22
    22d2:	bc 01       	movw	r22, r24
    22d4:	cd 01       	movw	r24, r26
    22d6:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    22da:	dc 01       	movw	r26, r24
    22dc:	cb 01       	movw	r24, r22
    22de:	9e 83       	std	Y+6, r25	; 0x06
    22e0:	8d 83       	std	Y+5, r24	; 0x05
    22e2:	0f c0       	rjmp	.+30     	; 0x2302 <LCD_WriteInstruction+0x2b0>
    22e4:	88 ec       	ldi	r24, 0xC8	; 200
    22e6:	90 e0       	ldi	r25, 0x00	; 0
    22e8:	9c 83       	std	Y+4, r25	; 0x04
    22ea:	8b 83       	std	Y+3, r24	; 0x03
    22ec:	8b 81       	ldd	r24, Y+3	; 0x03
    22ee:	9c 81       	ldd	r25, Y+4	; 0x04
    22f0:	01 97       	sbiw	r24, 0x01	; 1
    22f2:	f1 f7       	brne	.-4      	; 0x22f0 <LCD_WriteInstruction+0x29e>
    22f4:	9c 83       	std	Y+4, r25	; 0x04
    22f6:	8b 83       	std	Y+3, r24	; 0x03
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    22f8:	8d 81       	ldd	r24, Y+5	; 0x05
    22fa:	9e 81       	ldd	r25, Y+6	; 0x06
    22fc:	01 97       	sbiw	r24, 0x01	; 1
    22fe:	9e 83       	std	Y+6, r25	; 0x06
    2300:	8d 83       	std	Y+5, r24	; 0x05
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    2302:	8d 81       	ldd	r24, Y+5	; 0x05
    2304:	9e 81       	ldd	r25, Y+6	; 0x06
    2306:	00 97       	sbiw	r24, 0x00	; 0
    2308:	69 f7       	brne	.-38     	; 0x22e4 <LCD_WriteInstruction+0x292>
    230a:	14 c0       	rjmp	.+40     	; 0x2334 <LCD_WriteInstruction+0x2e2>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    230c:	6f 81       	ldd	r22, Y+7	; 0x07
    230e:	78 85       	ldd	r23, Y+8	; 0x08
    2310:	89 85       	ldd	r24, Y+9	; 0x09
    2312:	9a 85       	ldd	r25, Y+10	; 0x0a
    2314:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    2318:	dc 01       	movw	r26, r24
    231a:	cb 01       	movw	r24, r22
    231c:	9e 83       	std	Y+6, r25	; 0x06
    231e:	8d 83       	std	Y+5, r24	; 0x05
    2320:	8d 81       	ldd	r24, Y+5	; 0x05
    2322:	9e 81       	ldd	r25, Y+6	; 0x06
    2324:	9a 83       	std	Y+2, r25	; 0x02
    2326:	89 83       	std	Y+1, r24	; 0x01
    2328:	89 81       	ldd	r24, Y+1	; 0x01
    232a:	9a 81       	ldd	r25, Y+2	; 0x02
    232c:	01 97       	sbiw	r24, 0x01	; 1
    232e:	f1 f7       	brne	.-4      	; 0x232c <LCD_WriteInstruction+0x2da>
    2330:	9a 83       	std	Y+2, r25	; 0x02
    2332:	89 83       	std	Y+1, r24	; 0x01
	_delay_ms(1);
}
    2334:	ab 96       	adiw	r28, 0x2b	; 43
    2336:	0f b6       	in	r0, 0x3f	; 63
    2338:	f8 94       	cli
    233a:	de bf       	out	0x3e, r29	; 62
    233c:	0f be       	out	0x3f, r0	; 63
    233e:	cd bf       	out	0x3d, r28	; 61
    2340:	cf 91       	pop	r28
    2342:	df 91       	pop	r29
    2344:	08 95       	ret

00002346 <LCD_Init>:


void LCD_Init(void){
    2346:	df 93       	push	r29
    2348:	cf 93       	push	r28
    234a:	cd b7       	in	r28, 0x3d	; 61
    234c:	de b7       	in	r29, 0x3e	; 62
    234e:	6c 97       	sbiw	r28, 0x1c	; 28
    2350:	0f b6       	in	r0, 0x3f	; 63
    2352:	f8 94       	cli
    2354:	de bf       	out	0x3e, r29	; 62
    2356:	0f be       	out	0x3f, r0	; 63
    2358:	cd bf       	out	0x3d, r28	; 61
    235a:	80 e0       	ldi	r24, 0x00	; 0
    235c:	90 e0       	ldi	r25, 0x00	; 0
    235e:	a8 e4       	ldi	r26, 0x48	; 72
    2360:	b2 e4       	ldi	r27, 0x42	; 66
    2362:	89 8f       	std	Y+25, r24	; 0x19
    2364:	9a 8f       	std	Y+26, r25	; 0x1a
    2366:	ab 8f       	std	Y+27, r26	; 0x1b
    2368:	bc 8f       	std	Y+28, r27	; 0x1c
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    236a:	69 8d       	ldd	r22, Y+25	; 0x19
    236c:	7a 8d       	ldd	r23, Y+26	; 0x1a
    236e:	8b 8d       	ldd	r24, Y+27	; 0x1b
    2370:	9c 8d       	ldd	r25, Y+28	; 0x1c
    2372:	20 e0       	ldi	r18, 0x00	; 0
    2374:	30 e0       	ldi	r19, 0x00	; 0
    2376:	4a ef       	ldi	r20, 0xFA	; 250
    2378:	54 e4       	ldi	r21, 0x44	; 68
    237a:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    237e:	dc 01       	movw	r26, r24
    2380:	cb 01       	movw	r24, r22
    2382:	8d 8b       	std	Y+21, r24	; 0x15
    2384:	9e 8b       	std	Y+22, r25	; 0x16
    2386:	af 8b       	std	Y+23, r26	; 0x17
    2388:	b8 8f       	std	Y+24, r27	; 0x18
	if (__tmp < 1.0)
    238a:	6d 89       	ldd	r22, Y+21	; 0x15
    238c:	7e 89       	ldd	r23, Y+22	; 0x16
    238e:	8f 89       	ldd	r24, Y+23	; 0x17
    2390:	98 8d       	ldd	r25, Y+24	; 0x18
    2392:	20 e0       	ldi	r18, 0x00	; 0
    2394:	30 e0       	ldi	r19, 0x00	; 0
    2396:	40 e8       	ldi	r20, 0x80	; 128
    2398:	5f e3       	ldi	r21, 0x3F	; 63
    239a:	0e 94 79 03 	call	0x6f2	; 0x6f2 <__ltsf2>
    239e:	88 23       	and	r24, r24
    23a0:	2c f4       	brge	.+10     	; 0x23ac <LCD_Init+0x66>
		__ticks = 1;
    23a2:	81 e0       	ldi	r24, 0x01	; 1
    23a4:	90 e0       	ldi	r25, 0x00	; 0
    23a6:	9c 8b       	std	Y+20, r25	; 0x14
    23a8:	8b 8b       	std	Y+19, r24	; 0x13
    23aa:	3f c0       	rjmp	.+126    	; 0x242a <LCD_Init+0xe4>
	else if (__tmp > 65535)
    23ac:	6d 89       	ldd	r22, Y+21	; 0x15
    23ae:	7e 89       	ldd	r23, Y+22	; 0x16
    23b0:	8f 89       	ldd	r24, Y+23	; 0x17
    23b2:	98 8d       	ldd	r25, Y+24	; 0x18
    23b4:	20 e0       	ldi	r18, 0x00	; 0
    23b6:	3f ef       	ldi	r19, 0xFF	; 255
    23b8:	4f e7       	ldi	r20, 0x7F	; 127
    23ba:	57 e4       	ldi	r21, 0x47	; 71
    23bc:	0e 94 19 03 	call	0x632	; 0x632 <__gtsf2>
    23c0:	18 16       	cp	r1, r24
    23c2:	4c f5       	brge	.+82     	; 0x2416 <LCD_Init+0xd0>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    23c4:	69 8d       	ldd	r22, Y+25	; 0x19
    23c6:	7a 8d       	ldd	r23, Y+26	; 0x1a
    23c8:	8b 8d       	ldd	r24, Y+27	; 0x1b
    23ca:	9c 8d       	ldd	r25, Y+28	; 0x1c
    23cc:	20 e0       	ldi	r18, 0x00	; 0
    23ce:	30 e0       	ldi	r19, 0x00	; 0
    23d0:	40 e2       	ldi	r20, 0x20	; 32
    23d2:	51 e4       	ldi	r21, 0x41	; 65
    23d4:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    23d8:	dc 01       	movw	r26, r24
    23da:	cb 01       	movw	r24, r22
    23dc:	bc 01       	movw	r22, r24
    23de:	cd 01       	movw	r24, r26
    23e0:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    23e4:	dc 01       	movw	r26, r24
    23e6:	cb 01       	movw	r24, r22
    23e8:	9c 8b       	std	Y+20, r25	; 0x14
    23ea:	8b 8b       	std	Y+19, r24	; 0x13
    23ec:	0f c0       	rjmp	.+30     	; 0x240c <LCD_Init+0xc6>
    23ee:	88 ec       	ldi	r24, 0xC8	; 200
    23f0:	90 e0       	ldi	r25, 0x00	; 0
    23f2:	9a 8b       	std	Y+18, r25	; 0x12
    23f4:	89 8b       	std	Y+17, r24	; 0x11
    23f6:	89 89       	ldd	r24, Y+17	; 0x11
    23f8:	9a 89       	ldd	r25, Y+18	; 0x12
    23fa:	01 97       	sbiw	r24, 0x01	; 1
    23fc:	f1 f7       	brne	.-4      	; 0x23fa <LCD_Init+0xb4>
    23fe:	9a 8b       	std	Y+18, r25	; 0x12
    2400:	89 8b       	std	Y+17, r24	; 0x11
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    2402:	8b 89       	ldd	r24, Y+19	; 0x13
    2404:	9c 89       	ldd	r25, Y+20	; 0x14
    2406:	01 97       	sbiw	r24, 0x01	; 1
    2408:	9c 8b       	std	Y+20, r25	; 0x14
    240a:	8b 8b       	std	Y+19, r24	; 0x13
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    240c:	8b 89       	ldd	r24, Y+19	; 0x13
    240e:	9c 89       	ldd	r25, Y+20	; 0x14
    2410:	00 97       	sbiw	r24, 0x00	; 0
    2412:	69 f7       	brne	.-38     	; 0x23ee <LCD_Init+0xa8>
    2414:	14 c0       	rjmp	.+40     	; 0x243e <LCD_Init+0xf8>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    2416:	6d 89       	ldd	r22, Y+21	; 0x15
    2418:	7e 89       	ldd	r23, Y+22	; 0x16
    241a:	8f 89       	ldd	r24, Y+23	; 0x17
    241c:	98 8d       	ldd	r25, Y+24	; 0x18
    241e:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    2422:	dc 01       	movw	r26, r24
    2424:	cb 01       	movw	r24, r22
    2426:	9c 8b       	std	Y+20, r25	; 0x14
    2428:	8b 8b       	std	Y+19, r24	; 0x13
    242a:	8b 89       	ldd	r24, Y+19	; 0x13
    242c:	9c 89       	ldd	r25, Y+20	; 0x14
    242e:	98 8b       	std	Y+16, r25	; 0x10
    2430:	8f 87       	std	Y+15, r24	; 0x0f
    2432:	8f 85       	ldd	r24, Y+15	; 0x0f
    2434:	98 89       	ldd	r25, Y+16	; 0x10
    2436:	01 97       	sbiw	r24, 0x01	; 1
    2438:	f1 f7       	brne	.-4      	; 0x2436 <LCD_Init+0xf0>
    243a:	98 8b       	std	Y+16, r25	; 0x10
    243c:	8f 87       	std	Y+15, r24	; 0x0f
	_delay_ms(50);
	LCD_WriteInstruction(0x38);          //8bit mode 2line 5*7 font
    243e:	88 e3       	ldi	r24, 0x38	; 56
    2440:	0e 94 29 10 	call	0x2052	; 0x2052 <LCD_WriteInstruction>
	LCD_WriteInstruction(0x0c);
    2444:	8c e0       	ldi	r24, 0x0C	; 12
    2446:	0e 94 29 10 	call	0x2052	; 0x2052 <LCD_WriteInstruction>
	LCD_WriteInstruction(0x01);          //Display Clear
    244a:	81 e0       	ldi	r24, 0x01	; 1
    244c:	0e 94 29 10 	call	0x2052	; 0x2052 <LCD_WriteInstruction>
    2450:	80 e0       	ldi	r24, 0x00	; 0
    2452:	90 e0       	ldi	r25, 0x00	; 0
    2454:	a0 e8       	ldi	r26, 0x80	; 128
    2456:	bf e3       	ldi	r27, 0x3F	; 63
    2458:	8b 87       	std	Y+11, r24	; 0x0b
    245a:	9c 87       	std	Y+12, r25	; 0x0c
    245c:	ad 87       	std	Y+13, r26	; 0x0d
    245e:	be 87       	std	Y+14, r27	; 0x0e
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    2460:	6b 85       	ldd	r22, Y+11	; 0x0b
    2462:	7c 85       	ldd	r23, Y+12	; 0x0c
    2464:	8d 85       	ldd	r24, Y+13	; 0x0d
    2466:	9e 85       	ldd	r25, Y+14	; 0x0e
    2468:	20 e0       	ldi	r18, 0x00	; 0
    246a:	30 e0       	ldi	r19, 0x00	; 0
    246c:	4a ef       	ldi	r20, 0xFA	; 250
    246e:	54 e4       	ldi	r21, 0x44	; 68
    2470:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    2474:	dc 01       	movw	r26, r24
    2476:	cb 01       	movw	r24, r22
    2478:	8f 83       	std	Y+7, r24	; 0x07
    247a:	98 87       	std	Y+8, r25	; 0x08
    247c:	a9 87       	std	Y+9, r26	; 0x09
    247e:	ba 87       	std	Y+10, r27	; 0x0a
	if (__tmp < 1.0)
    2480:	6f 81       	ldd	r22, Y+7	; 0x07
    2482:	78 85       	ldd	r23, Y+8	; 0x08
    2484:	89 85       	ldd	r24, Y+9	; 0x09
    2486:	9a 85       	ldd	r25, Y+10	; 0x0a
    2488:	20 e0       	ldi	r18, 0x00	; 0
    248a:	30 e0       	ldi	r19, 0x00	; 0
    248c:	40 e8       	ldi	r20, 0x80	; 128
    248e:	5f e3       	ldi	r21, 0x3F	; 63
    2490:	0e 94 79 03 	call	0x6f2	; 0x6f2 <__ltsf2>
    2494:	88 23       	and	r24, r24
    2496:	2c f4       	brge	.+10     	; 0x24a2 <LCD_Init+0x15c>
		__ticks = 1;
    2498:	81 e0       	ldi	r24, 0x01	; 1
    249a:	90 e0       	ldi	r25, 0x00	; 0
    249c:	9e 83       	std	Y+6, r25	; 0x06
    249e:	8d 83       	std	Y+5, r24	; 0x05
    24a0:	3f c0       	rjmp	.+126    	; 0x2520 <LCD_Init+0x1da>
	else if (__tmp > 65535)
    24a2:	6f 81       	ldd	r22, Y+7	; 0x07
    24a4:	78 85       	ldd	r23, Y+8	; 0x08
    24a6:	89 85       	ldd	r24, Y+9	; 0x09
    24a8:	9a 85       	ldd	r25, Y+10	; 0x0a
    24aa:	20 e0       	ldi	r18, 0x00	; 0
    24ac:	3f ef       	ldi	r19, 0xFF	; 255
    24ae:	4f e7       	ldi	r20, 0x7F	; 127
    24b0:	57 e4       	ldi	r21, 0x47	; 71
    24b2:	0e 94 19 03 	call	0x632	; 0x632 <__gtsf2>
    24b6:	18 16       	cp	r1, r24
    24b8:	4c f5       	brge	.+82     	; 0x250c <LCD_Init+0x1c6>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    24ba:	6b 85       	ldd	r22, Y+11	; 0x0b
    24bc:	7c 85       	ldd	r23, Y+12	; 0x0c
    24be:	8d 85       	ldd	r24, Y+13	; 0x0d
    24c0:	9e 85       	ldd	r25, Y+14	; 0x0e
    24c2:	20 e0       	ldi	r18, 0x00	; 0
    24c4:	30 e0       	ldi	r19, 0x00	; 0
    24c6:	40 e2       	ldi	r20, 0x20	; 32
    24c8:	51 e4       	ldi	r21, 0x41	; 65
    24ca:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    24ce:	dc 01       	movw	r26, r24
    24d0:	cb 01       	movw	r24, r22
    24d2:	bc 01       	movw	r22, r24
    24d4:	cd 01       	movw	r24, r26
    24d6:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    24da:	dc 01       	movw	r26, r24
    24dc:	cb 01       	movw	r24, r22
    24de:	9e 83       	std	Y+6, r25	; 0x06
    24e0:	8d 83       	std	Y+5, r24	; 0x05
    24e2:	0f c0       	rjmp	.+30     	; 0x2502 <LCD_Init+0x1bc>
    24e4:	88 ec       	ldi	r24, 0xC8	; 200
    24e6:	90 e0       	ldi	r25, 0x00	; 0
    24e8:	9c 83       	std	Y+4, r25	; 0x04
    24ea:	8b 83       	std	Y+3, r24	; 0x03
    24ec:	8b 81       	ldd	r24, Y+3	; 0x03
    24ee:	9c 81       	ldd	r25, Y+4	; 0x04
    24f0:	01 97       	sbiw	r24, 0x01	; 1
    24f2:	f1 f7       	brne	.-4      	; 0x24f0 <LCD_Init+0x1aa>
    24f4:	9c 83       	std	Y+4, r25	; 0x04
    24f6:	8b 83       	std	Y+3, r24	; 0x03
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    24f8:	8d 81       	ldd	r24, Y+5	; 0x05
    24fa:	9e 81       	ldd	r25, Y+6	; 0x06
    24fc:	01 97       	sbiw	r24, 0x01	; 1
    24fe:	9e 83       	std	Y+6, r25	; 0x06
    2500:	8d 83       	std	Y+5, r24	; 0x05
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    2502:	8d 81       	ldd	r24, Y+5	; 0x05
    2504:	9e 81       	ldd	r25, Y+6	; 0x06
    2506:	00 97       	sbiw	r24, 0x00	; 0
    2508:	69 f7       	brne	.-38     	; 0x24e4 <LCD_Init+0x19e>
    250a:	14 c0       	rjmp	.+40     	; 0x2534 <LCD_Init+0x1ee>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    250c:	6f 81       	ldd	r22, Y+7	; 0x07
    250e:	78 85       	ldd	r23, Y+8	; 0x08
    2510:	89 85       	ldd	r24, Y+9	; 0x09
    2512:	9a 85       	ldd	r25, Y+10	; 0x0a
    2514:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    2518:	dc 01       	movw	r26, r24
    251a:	cb 01       	movw	r24, r22
    251c:	9e 83       	std	Y+6, r25	; 0x06
    251e:	8d 83       	std	Y+5, r24	; 0x05
    2520:	8d 81       	ldd	r24, Y+5	; 0x05
    2522:	9e 81       	ldd	r25, Y+6	; 0x06
    2524:	9a 83       	std	Y+2, r25	; 0x02
    2526:	89 83       	std	Y+1, r24	; 0x01
    2528:	89 81       	ldd	r24, Y+1	; 0x01
    252a:	9a 81       	ldd	r25, Y+2	; 0x02
    252c:	01 97       	sbiw	r24, 0x01	; 1
    252e:	f1 f7       	brne	.-4      	; 0x252c <LCD_Init+0x1e6>
    2530:	9a 83       	std	Y+2, r25	; 0x02
    2532:	89 83       	std	Y+1, r24	; 0x01
	_delay_ms(1);
	LCD_WriteInstruction(0x06);
    2534:	86 e0       	ldi	r24, 0x06	; 6
    2536:	0e 94 29 10 	call	0x2052	; 0x2052 <LCD_WriteInstruction>
}
    253a:	6c 96       	adiw	r28, 0x1c	; 28
    253c:	0f b6       	in	r0, 0x3f	; 63
    253e:	f8 94       	cli
    2540:	de bf       	out	0x3e, r29	; 62
    2542:	0f be       	out	0x3f, r0	; 63
    2544:	cd bf       	out	0x3d, r28	; 61
    2546:	cf 91       	pop	r28
    2548:	df 91       	pop	r29
    254a:	08 95       	ret

0000254c <LCD_WriteData>:

static void LCD_WriteData(u8 chh)
{
    254c:	df 93       	push	r29
    254e:	cf 93       	push	r28
    2550:	cd b7       	in	r28, 0x3d	; 61
    2552:	de b7       	in	r29, 0x3e	; 62
    2554:	ab 97       	sbiw	r28, 0x2b	; 43
    2556:	0f b6       	in	r0, 0x3f	; 63
    2558:	f8 94       	cli
    255a:	de bf       	out	0x3e, r29	; 62
    255c:	0f be       	out	0x3f, r0	; 63
    255e:	cd bf       	out	0x3d, r28	; 61
    2560:	8b a7       	std	Y+43, r24	; 0x2b
	DIO_WritePin(RS,HIGH);
    2562:	88 e0       	ldi	r24, 0x08	; 8
    2564:	61 e0       	ldi	r22, 0x01	; 1
    2566:	0e 94 f9 09 	call	0x13f2	; 0x13f2 <DIO_WritePin>
	DIO_WritePort(PA,chh);
    256a:	80 e0       	ldi	r24, 0x00	; 0
    256c:	6b a5       	ldd	r22, Y+43	; 0x2b
    256e:	0e 94 23 0c 	call	0x1846	; 0x1846 <DIO_WritePort>
    2572:	80 e0       	ldi	r24, 0x00	; 0
    2574:	90 e0       	ldi	r25, 0x00	; 0
    2576:	a0 e8       	ldi	r26, 0x80	; 128
    2578:	bf e3       	ldi	r27, 0x3F	; 63
    257a:	8f a3       	std	Y+39, r24	; 0x27
    257c:	98 a7       	std	Y+40, r25	; 0x28
    257e:	a9 a7       	std	Y+41, r26	; 0x29
    2580:	ba a7       	std	Y+42, r27	; 0x2a
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    2582:	6f a1       	ldd	r22, Y+39	; 0x27
    2584:	78 a5       	ldd	r23, Y+40	; 0x28
    2586:	89 a5       	ldd	r24, Y+41	; 0x29
    2588:	9a a5       	ldd	r25, Y+42	; 0x2a
    258a:	20 e0       	ldi	r18, 0x00	; 0
    258c:	30 e0       	ldi	r19, 0x00	; 0
    258e:	4a ef       	ldi	r20, 0xFA	; 250
    2590:	54 e4       	ldi	r21, 0x44	; 68
    2592:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    2596:	dc 01       	movw	r26, r24
    2598:	cb 01       	movw	r24, r22
    259a:	8b a3       	std	Y+35, r24	; 0x23
    259c:	9c a3       	std	Y+36, r25	; 0x24
    259e:	ad a3       	std	Y+37, r26	; 0x25
    25a0:	be a3       	std	Y+38, r27	; 0x26
	if (__tmp < 1.0)
    25a2:	6b a1       	ldd	r22, Y+35	; 0x23
    25a4:	7c a1       	ldd	r23, Y+36	; 0x24
    25a6:	8d a1       	ldd	r24, Y+37	; 0x25
    25a8:	9e a1       	ldd	r25, Y+38	; 0x26
    25aa:	20 e0       	ldi	r18, 0x00	; 0
    25ac:	30 e0       	ldi	r19, 0x00	; 0
    25ae:	40 e8       	ldi	r20, 0x80	; 128
    25b0:	5f e3       	ldi	r21, 0x3F	; 63
    25b2:	0e 94 79 03 	call	0x6f2	; 0x6f2 <__ltsf2>
    25b6:	88 23       	and	r24, r24
    25b8:	2c f4       	brge	.+10     	; 0x25c4 <LCD_WriteData+0x78>
		__ticks = 1;
    25ba:	81 e0       	ldi	r24, 0x01	; 1
    25bc:	90 e0       	ldi	r25, 0x00	; 0
    25be:	9a a3       	std	Y+34, r25	; 0x22
    25c0:	89 a3       	std	Y+33, r24	; 0x21
    25c2:	3f c0       	rjmp	.+126    	; 0x2642 <LCD_WriteData+0xf6>
	else if (__tmp > 65535)
    25c4:	6b a1       	ldd	r22, Y+35	; 0x23
    25c6:	7c a1       	ldd	r23, Y+36	; 0x24
    25c8:	8d a1       	ldd	r24, Y+37	; 0x25
    25ca:	9e a1       	ldd	r25, Y+38	; 0x26
    25cc:	20 e0       	ldi	r18, 0x00	; 0
    25ce:	3f ef       	ldi	r19, 0xFF	; 255
    25d0:	4f e7       	ldi	r20, 0x7F	; 127
    25d2:	57 e4       	ldi	r21, 0x47	; 71
    25d4:	0e 94 19 03 	call	0x632	; 0x632 <__gtsf2>
    25d8:	18 16       	cp	r1, r24
    25da:	4c f5       	brge	.+82     	; 0x262e <LCD_WriteData+0xe2>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    25dc:	6f a1       	ldd	r22, Y+39	; 0x27
    25de:	78 a5       	ldd	r23, Y+40	; 0x28
    25e0:	89 a5       	ldd	r24, Y+41	; 0x29
    25e2:	9a a5       	ldd	r25, Y+42	; 0x2a
    25e4:	20 e0       	ldi	r18, 0x00	; 0
    25e6:	30 e0       	ldi	r19, 0x00	; 0
    25e8:	40 e2       	ldi	r20, 0x20	; 32
    25ea:	51 e4       	ldi	r21, 0x41	; 65
    25ec:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    25f0:	dc 01       	movw	r26, r24
    25f2:	cb 01       	movw	r24, r22
    25f4:	bc 01       	movw	r22, r24
    25f6:	cd 01       	movw	r24, r26
    25f8:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    25fc:	dc 01       	movw	r26, r24
    25fe:	cb 01       	movw	r24, r22
    2600:	9a a3       	std	Y+34, r25	; 0x22
    2602:	89 a3       	std	Y+33, r24	; 0x21
    2604:	0f c0       	rjmp	.+30     	; 0x2624 <LCD_WriteData+0xd8>
    2606:	88 ec       	ldi	r24, 0xC8	; 200
    2608:	90 e0       	ldi	r25, 0x00	; 0
    260a:	98 a3       	std	Y+32, r25	; 0x20
    260c:	8f 8f       	std	Y+31, r24	; 0x1f
    260e:	8f 8d       	ldd	r24, Y+31	; 0x1f
    2610:	98 a1       	ldd	r25, Y+32	; 0x20
    2612:	01 97       	sbiw	r24, 0x01	; 1
    2614:	f1 f7       	brne	.-4      	; 0x2612 <LCD_WriteData+0xc6>
    2616:	98 a3       	std	Y+32, r25	; 0x20
    2618:	8f 8f       	std	Y+31, r24	; 0x1f
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    261a:	89 a1       	ldd	r24, Y+33	; 0x21
    261c:	9a a1       	ldd	r25, Y+34	; 0x22
    261e:	01 97       	sbiw	r24, 0x01	; 1
    2620:	9a a3       	std	Y+34, r25	; 0x22
    2622:	89 a3       	std	Y+33, r24	; 0x21
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    2624:	89 a1       	ldd	r24, Y+33	; 0x21
    2626:	9a a1       	ldd	r25, Y+34	; 0x22
    2628:	00 97       	sbiw	r24, 0x00	; 0
    262a:	69 f7       	brne	.-38     	; 0x2606 <LCD_WriteData+0xba>
    262c:	14 c0       	rjmp	.+40     	; 0x2656 <LCD_WriteData+0x10a>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    262e:	6b a1       	ldd	r22, Y+35	; 0x23
    2630:	7c a1       	ldd	r23, Y+36	; 0x24
    2632:	8d a1       	ldd	r24, Y+37	; 0x25
    2634:	9e a1       	ldd	r25, Y+38	; 0x26
    2636:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    263a:	dc 01       	movw	r26, r24
    263c:	cb 01       	movw	r24, r22
    263e:	9a a3       	std	Y+34, r25	; 0x22
    2640:	89 a3       	std	Y+33, r24	; 0x21
    2642:	89 a1       	ldd	r24, Y+33	; 0x21
    2644:	9a a1       	ldd	r25, Y+34	; 0x22
    2646:	9e 8f       	std	Y+30, r25	; 0x1e
    2648:	8d 8f       	std	Y+29, r24	; 0x1d
    264a:	8d 8d       	ldd	r24, Y+29	; 0x1d
    264c:	9e 8d       	ldd	r25, Y+30	; 0x1e
    264e:	01 97       	sbiw	r24, 0x01	; 1
    2650:	f1 f7       	brne	.-4      	; 0x264e <LCD_WriteData+0x102>
    2652:	9e 8f       	std	Y+30, r25	; 0x1e
    2654:	8d 8f       	std	Y+29, r24	; 0x1d

	_delay_ms(1);
	DIO_WritePin(EN,HIGH);
    2656:	89 e0       	ldi	r24, 0x09	; 9
    2658:	61 e0       	ldi	r22, 0x01	; 1
    265a:	0e 94 f9 09 	call	0x13f2	; 0x13f2 <DIO_WritePin>
    265e:	80 e0       	ldi	r24, 0x00	; 0
    2660:	90 e0       	ldi	r25, 0x00	; 0
    2662:	a0 e8       	ldi	r26, 0x80	; 128
    2664:	bf e3       	ldi	r27, 0x3F	; 63
    2666:	89 8f       	std	Y+25, r24	; 0x19
    2668:	9a 8f       	std	Y+26, r25	; 0x1a
    266a:	ab 8f       	std	Y+27, r26	; 0x1b
    266c:	bc 8f       	std	Y+28, r27	; 0x1c
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    266e:	69 8d       	ldd	r22, Y+25	; 0x19
    2670:	7a 8d       	ldd	r23, Y+26	; 0x1a
    2672:	8b 8d       	ldd	r24, Y+27	; 0x1b
    2674:	9c 8d       	ldd	r25, Y+28	; 0x1c
    2676:	20 e0       	ldi	r18, 0x00	; 0
    2678:	30 e0       	ldi	r19, 0x00	; 0
    267a:	4a ef       	ldi	r20, 0xFA	; 250
    267c:	54 e4       	ldi	r21, 0x44	; 68
    267e:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    2682:	dc 01       	movw	r26, r24
    2684:	cb 01       	movw	r24, r22
    2686:	8d 8b       	std	Y+21, r24	; 0x15
    2688:	9e 8b       	std	Y+22, r25	; 0x16
    268a:	af 8b       	std	Y+23, r26	; 0x17
    268c:	b8 8f       	std	Y+24, r27	; 0x18
	if (__tmp < 1.0)
    268e:	6d 89       	ldd	r22, Y+21	; 0x15
    2690:	7e 89       	ldd	r23, Y+22	; 0x16
    2692:	8f 89       	ldd	r24, Y+23	; 0x17
    2694:	98 8d       	ldd	r25, Y+24	; 0x18
    2696:	20 e0       	ldi	r18, 0x00	; 0
    2698:	30 e0       	ldi	r19, 0x00	; 0
    269a:	40 e8       	ldi	r20, 0x80	; 128
    269c:	5f e3       	ldi	r21, 0x3F	; 63
    269e:	0e 94 79 03 	call	0x6f2	; 0x6f2 <__ltsf2>
    26a2:	88 23       	and	r24, r24
    26a4:	2c f4       	brge	.+10     	; 0x26b0 <LCD_WriteData+0x164>
		__ticks = 1;
    26a6:	81 e0       	ldi	r24, 0x01	; 1
    26a8:	90 e0       	ldi	r25, 0x00	; 0
    26aa:	9c 8b       	std	Y+20, r25	; 0x14
    26ac:	8b 8b       	std	Y+19, r24	; 0x13
    26ae:	3f c0       	rjmp	.+126    	; 0x272e <LCD_WriteData+0x1e2>
	else if (__tmp > 65535)
    26b0:	6d 89       	ldd	r22, Y+21	; 0x15
    26b2:	7e 89       	ldd	r23, Y+22	; 0x16
    26b4:	8f 89       	ldd	r24, Y+23	; 0x17
    26b6:	98 8d       	ldd	r25, Y+24	; 0x18
    26b8:	20 e0       	ldi	r18, 0x00	; 0
    26ba:	3f ef       	ldi	r19, 0xFF	; 255
    26bc:	4f e7       	ldi	r20, 0x7F	; 127
    26be:	57 e4       	ldi	r21, 0x47	; 71
    26c0:	0e 94 19 03 	call	0x632	; 0x632 <__gtsf2>
    26c4:	18 16       	cp	r1, r24
    26c6:	4c f5       	brge	.+82     	; 0x271a <LCD_WriteData+0x1ce>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    26c8:	69 8d       	ldd	r22, Y+25	; 0x19
    26ca:	7a 8d       	ldd	r23, Y+26	; 0x1a
    26cc:	8b 8d       	ldd	r24, Y+27	; 0x1b
    26ce:	9c 8d       	ldd	r25, Y+28	; 0x1c
    26d0:	20 e0       	ldi	r18, 0x00	; 0
    26d2:	30 e0       	ldi	r19, 0x00	; 0
    26d4:	40 e2       	ldi	r20, 0x20	; 32
    26d6:	51 e4       	ldi	r21, 0x41	; 65
    26d8:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    26dc:	dc 01       	movw	r26, r24
    26de:	cb 01       	movw	r24, r22
    26e0:	bc 01       	movw	r22, r24
    26e2:	cd 01       	movw	r24, r26
    26e4:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    26e8:	dc 01       	movw	r26, r24
    26ea:	cb 01       	movw	r24, r22
    26ec:	9c 8b       	std	Y+20, r25	; 0x14
    26ee:	8b 8b       	std	Y+19, r24	; 0x13
    26f0:	0f c0       	rjmp	.+30     	; 0x2710 <LCD_WriteData+0x1c4>
    26f2:	88 ec       	ldi	r24, 0xC8	; 200
    26f4:	90 e0       	ldi	r25, 0x00	; 0
    26f6:	9a 8b       	std	Y+18, r25	; 0x12
    26f8:	89 8b       	std	Y+17, r24	; 0x11
    26fa:	89 89       	ldd	r24, Y+17	; 0x11
    26fc:	9a 89       	ldd	r25, Y+18	; 0x12
    26fe:	01 97       	sbiw	r24, 0x01	; 1
    2700:	f1 f7       	brne	.-4      	; 0x26fe <LCD_WriteData+0x1b2>
    2702:	9a 8b       	std	Y+18, r25	; 0x12
    2704:	89 8b       	std	Y+17, r24	; 0x11
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    2706:	8b 89       	ldd	r24, Y+19	; 0x13
    2708:	9c 89       	ldd	r25, Y+20	; 0x14
    270a:	01 97       	sbiw	r24, 0x01	; 1
    270c:	9c 8b       	std	Y+20, r25	; 0x14
    270e:	8b 8b       	std	Y+19, r24	; 0x13
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    2710:	8b 89       	ldd	r24, Y+19	; 0x13
    2712:	9c 89       	ldd	r25, Y+20	; 0x14
    2714:	00 97       	sbiw	r24, 0x00	; 0
    2716:	69 f7       	brne	.-38     	; 0x26f2 <LCD_WriteData+0x1a6>
    2718:	14 c0       	rjmp	.+40     	; 0x2742 <LCD_WriteData+0x1f6>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    271a:	6d 89       	ldd	r22, Y+21	; 0x15
    271c:	7e 89       	ldd	r23, Y+22	; 0x16
    271e:	8f 89       	ldd	r24, Y+23	; 0x17
    2720:	98 8d       	ldd	r25, Y+24	; 0x18
    2722:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    2726:	dc 01       	movw	r26, r24
    2728:	cb 01       	movw	r24, r22
    272a:	9c 8b       	std	Y+20, r25	; 0x14
    272c:	8b 8b       	std	Y+19, r24	; 0x13
    272e:	8b 89       	ldd	r24, Y+19	; 0x13
    2730:	9c 89       	ldd	r25, Y+20	; 0x14
    2732:	98 8b       	std	Y+16, r25	; 0x10
    2734:	8f 87       	std	Y+15, r24	; 0x0f
    2736:	8f 85       	ldd	r24, Y+15	; 0x0f
    2738:	98 89       	ldd	r25, Y+16	; 0x10
    273a:	01 97       	sbiw	r24, 0x01	; 1
    273c:	f1 f7       	brne	.-4      	; 0x273a <LCD_WriteData+0x1ee>
    273e:	98 8b       	std	Y+16, r25	; 0x10
    2740:	8f 87       	std	Y+15, r24	; 0x0f
	_delay_ms(1);
	DIO_WritePin(EN,LOW);
    2742:	89 e0       	ldi	r24, 0x09	; 9
    2744:	60 e0       	ldi	r22, 0x00	; 0
    2746:	0e 94 f9 09 	call	0x13f2	; 0x13f2 <DIO_WritePin>
    274a:	80 e0       	ldi	r24, 0x00	; 0
    274c:	90 e0       	ldi	r25, 0x00	; 0
    274e:	a0 e8       	ldi	r26, 0x80	; 128
    2750:	bf e3       	ldi	r27, 0x3F	; 63
    2752:	8b 87       	std	Y+11, r24	; 0x0b
    2754:	9c 87       	std	Y+12, r25	; 0x0c
    2756:	ad 87       	std	Y+13, r26	; 0x0d
    2758:	be 87       	std	Y+14, r27	; 0x0e
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    275a:	6b 85       	ldd	r22, Y+11	; 0x0b
    275c:	7c 85       	ldd	r23, Y+12	; 0x0c
    275e:	8d 85       	ldd	r24, Y+13	; 0x0d
    2760:	9e 85       	ldd	r25, Y+14	; 0x0e
    2762:	20 e0       	ldi	r18, 0x00	; 0
    2764:	30 e0       	ldi	r19, 0x00	; 0
    2766:	4a ef       	ldi	r20, 0xFA	; 250
    2768:	54 e4       	ldi	r21, 0x44	; 68
    276a:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    276e:	dc 01       	movw	r26, r24
    2770:	cb 01       	movw	r24, r22
    2772:	8f 83       	std	Y+7, r24	; 0x07
    2774:	98 87       	std	Y+8, r25	; 0x08
    2776:	a9 87       	std	Y+9, r26	; 0x09
    2778:	ba 87       	std	Y+10, r27	; 0x0a
	if (__tmp < 1.0)
    277a:	6f 81       	ldd	r22, Y+7	; 0x07
    277c:	78 85       	ldd	r23, Y+8	; 0x08
    277e:	89 85       	ldd	r24, Y+9	; 0x09
    2780:	9a 85       	ldd	r25, Y+10	; 0x0a
    2782:	20 e0       	ldi	r18, 0x00	; 0
    2784:	30 e0       	ldi	r19, 0x00	; 0
    2786:	40 e8       	ldi	r20, 0x80	; 128
    2788:	5f e3       	ldi	r21, 0x3F	; 63
    278a:	0e 94 79 03 	call	0x6f2	; 0x6f2 <__ltsf2>
    278e:	88 23       	and	r24, r24
    2790:	2c f4       	brge	.+10     	; 0x279c <LCD_WriteData+0x250>
		__ticks = 1;
    2792:	81 e0       	ldi	r24, 0x01	; 1
    2794:	90 e0       	ldi	r25, 0x00	; 0
    2796:	9e 83       	std	Y+6, r25	; 0x06
    2798:	8d 83       	std	Y+5, r24	; 0x05
    279a:	3f c0       	rjmp	.+126    	; 0x281a <LCD_WriteData+0x2ce>
	else if (__tmp > 65535)
    279c:	6f 81       	ldd	r22, Y+7	; 0x07
    279e:	78 85       	ldd	r23, Y+8	; 0x08
    27a0:	89 85       	ldd	r24, Y+9	; 0x09
    27a2:	9a 85       	ldd	r25, Y+10	; 0x0a
    27a4:	20 e0       	ldi	r18, 0x00	; 0
    27a6:	3f ef       	ldi	r19, 0xFF	; 255
    27a8:	4f e7       	ldi	r20, 0x7F	; 127
    27aa:	57 e4       	ldi	r21, 0x47	; 71
    27ac:	0e 94 19 03 	call	0x632	; 0x632 <__gtsf2>
    27b0:	18 16       	cp	r1, r24
    27b2:	4c f5       	brge	.+82     	; 0x2806 <LCD_WriteData+0x2ba>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    27b4:	6b 85       	ldd	r22, Y+11	; 0x0b
    27b6:	7c 85       	ldd	r23, Y+12	; 0x0c
    27b8:	8d 85       	ldd	r24, Y+13	; 0x0d
    27ba:	9e 85       	ldd	r25, Y+14	; 0x0e
    27bc:	20 e0       	ldi	r18, 0x00	; 0
    27be:	30 e0       	ldi	r19, 0x00	; 0
    27c0:	40 e2       	ldi	r20, 0x20	; 32
    27c2:	51 e4       	ldi	r21, 0x41	; 65
    27c4:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    27c8:	dc 01       	movw	r26, r24
    27ca:	cb 01       	movw	r24, r22
    27cc:	bc 01       	movw	r22, r24
    27ce:	cd 01       	movw	r24, r26
    27d0:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    27d4:	dc 01       	movw	r26, r24
    27d6:	cb 01       	movw	r24, r22
    27d8:	9e 83       	std	Y+6, r25	; 0x06
    27da:	8d 83       	std	Y+5, r24	; 0x05
    27dc:	0f c0       	rjmp	.+30     	; 0x27fc <LCD_WriteData+0x2b0>
    27de:	88 ec       	ldi	r24, 0xC8	; 200
    27e0:	90 e0       	ldi	r25, 0x00	; 0
    27e2:	9c 83       	std	Y+4, r25	; 0x04
    27e4:	8b 83       	std	Y+3, r24	; 0x03
    27e6:	8b 81       	ldd	r24, Y+3	; 0x03
    27e8:	9c 81       	ldd	r25, Y+4	; 0x04
    27ea:	01 97       	sbiw	r24, 0x01	; 1
    27ec:	f1 f7       	brne	.-4      	; 0x27ea <LCD_WriteData+0x29e>
    27ee:	9c 83       	std	Y+4, r25	; 0x04
    27f0:	8b 83       	std	Y+3, r24	; 0x03
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    27f2:	8d 81       	ldd	r24, Y+5	; 0x05
    27f4:	9e 81       	ldd	r25, Y+6	; 0x06
    27f6:	01 97       	sbiw	r24, 0x01	; 1
    27f8:	9e 83       	std	Y+6, r25	; 0x06
    27fa:	8d 83       	std	Y+5, r24	; 0x05
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    27fc:	8d 81       	ldd	r24, Y+5	; 0x05
    27fe:	9e 81       	ldd	r25, Y+6	; 0x06
    2800:	00 97       	sbiw	r24, 0x00	; 0
    2802:	69 f7       	brne	.-38     	; 0x27de <LCD_WriteData+0x292>
    2804:	14 c0       	rjmp	.+40     	; 0x282e <LCD_WriteData+0x2e2>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    2806:	6f 81       	ldd	r22, Y+7	; 0x07
    2808:	78 85       	ldd	r23, Y+8	; 0x08
    280a:	89 85       	ldd	r24, Y+9	; 0x09
    280c:	9a 85       	ldd	r25, Y+10	; 0x0a
    280e:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    2812:	dc 01       	movw	r26, r24
    2814:	cb 01       	movw	r24, r22
    2816:	9e 83       	std	Y+6, r25	; 0x06
    2818:	8d 83       	std	Y+5, r24	; 0x05
    281a:	8d 81       	ldd	r24, Y+5	; 0x05
    281c:	9e 81       	ldd	r25, Y+6	; 0x06
    281e:	9a 83       	std	Y+2, r25	; 0x02
    2820:	89 83       	std	Y+1, r24	; 0x01
    2822:	89 81       	ldd	r24, Y+1	; 0x01
    2824:	9a 81       	ldd	r25, Y+2	; 0x02
    2826:	01 97       	sbiw	r24, 0x01	; 1
    2828:	f1 f7       	brne	.-4      	; 0x2826 <LCD_WriteData+0x2da>
    282a:	9a 83       	std	Y+2, r25	; 0x02
    282c:	89 83       	std	Y+1, r24	; 0x01
	_delay_ms(1);

}
    282e:	ab 96       	adiw	r28, 0x2b	; 43
    2830:	0f b6       	in	r0, 0x3f	; 63
    2832:	f8 94       	cli
    2834:	de bf       	out	0x3e, r29	; 62
    2836:	0f be       	out	0x3f, r0	; 63
    2838:	cd bf       	out	0x3d, r28	; 61
    283a:	cf 91       	pop	r28
    283c:	df 91       	pop	r29
    283e:	08 95       	ret

00002840 <LCD_WriteNumber>:
void LCD_WriteNumber(s32 num){
    2840:	0f 93       	push	r16
    2842:	1f 93       	push	r17
    2844:	df 93       	push	r29
    2846:	cf 93       	push	r28
    2848:	cd b7       	in	r28, 0x3d	; 61
    284a:	de b7       	in	r29, 0x3e	; 62
    284c:	66 97       	sbiw	r28, 0x16	; 22
    284e:	0f b6       	in	r0, 0x3f	; 63
    2850:	f8 94       	cli
    2852:	de bf       	out	0x3e, r29	; 62
    2854:	0f be       	out	0x3f, r0	; 63
    2856:	cd bf       	out	0x3d, r28	; 61
    2858:	6b 8b       	std	Y+19, r22	; 0x13
    285a:	7c 8b       	std	Y+20, r23	; 0x14
    285c:	8d 8b       	std	Y+21, r24	; 0x15
    285e:	9e 8b       	std	Y+22, r25	; 0x16

	u8 str[16];
	u8 i=0;
    2860:	1a 82       	std	Y+2, r1	; 0x02
	if(num<0){
    2862:	8b 89       	ldd	r24, Y+19	; 0x13
    2864:	9c 89       	ldd	r25, Y+20	; 0x14
    2866:	ad 89       	ldd	r26, Y+21	; 0x15
    2868:	be 89       	ldd	r27, Y+22	; 0x16
    286a:	bb 23       	and	r27, r27
    286c:	94 f4       	brge	.+36     	; 0x2892 <LCD_WriteNumber+0x52>
		num=num*(-1);
    286e:	8b 89       	ldd	r24, Y+19	; 0x13
    2870:	9c 89       	ldd	r25, Y+20	; 0x14
    2872:	ad 89       	ldd	r26, Y+21	; 0x15
    2874:	be 89       	ldd	r27, Y+22	; 0x16
    2876:	b0 95       	com	r27
    2878:	a0 95       	com	r26
    287a:	90 95       	com	r25
    287c:	81 95       	neg	r24
    287e:	9f 4f       	sbci	r25, 0xFF	; 255
    2880:	af 4f       	sbci	r26, 0xFF	; 255
    2882:	bf 4f       	sbci	r27, 0xFF	; 255
    2884:	8b 8b       	std	Y+19, r24	; 0x13
    2886:	9c 8b       	std	Y+20, r25	; 0x14
    2888:	ad 8b       	std	Y+21, r26	; 0x15
    288a:	be 8b       	std	Y+22, r27	; 0x16
		LCD_WriteChar('-');
    288c:	8d e2       	ldi	r24, 0x2D	; 45
    288e:	0e 94 a2 14 	call	0x2944	; 0x2944 <LCD_WriteChar>
	}

	do{
		str[i]=num%10+'0';
    2892:	8a 81       	ldd	r24, Y+2	; 0x02
    2894:	08 2f       	mov	r16, r24
    2896:	10 e0       	ldi	r17, 0x00	; 0
    2898:	8b 89       	ldd	r24, Y+19	; 0x13
    289a:	9c 89       	ldd	r25, Y+20	; 0x14
    289c:	ad 89       	ldd	r26, Y+21	; 0x15
    289e:	be 89       	ldd	r27, Y+22	; 0x16
    28a0:	2a e0       	ldi	r18, 0x0A	; 10
    28a2:	30 e0       	ldi	r19, 0x00	; 0
    28a4:	40 e0       	ldi	r20, 0x00	; 0
    28a6:	50 e0       	ldi	r21, 0x00	; 0
    28a8:	bc 01       	movw	r22, r24
    28aa:	cd 01       	movw	r24, r26
    28ac:	0e 94 6c 3c 	call	0x78d8	; 0x78d8 <__divmodsi4>
    28b0:	dc 01       	movw	r26, r24
    28b2:	cb 01       	movw	r24, r22
    28b4:	28 2f       	mov	r18, r24
    28b6:	20 5d       	subi	r18, 0xD0	; 208
    28b8:	ce 01       	movw	r24, r28
    28ba:	03 96       	adiw	r24, 0x03	; 3
    28bc:	fc 01       	movw	r30, r24
    28be:	e0 0f       	add	r30, r16
    28c0:	f1 1f       	adc	r31, r17
    28c2:	20 83       	st	Z, r18
		num=num/10;
    28c4:	8b 89       	ldd	r24, Y+19	; 0x13
    28c6:	9c 89       	ldd	r25, Y+20	; 0x14
    28c8:	ad 89       	ldd	r26, Y+21	; 0x15
    28ca:	be 89       	ldd	r27, Y+22	; 0x16
    28cc:	2a e0       	ldi	r18, 0x0A	; 10
    28ce:	30 e0       	ldi	r19, 0x00	; 0
    28d0:	40 e0       	ldi	r20, 0x00	; 0
    28d2:	50 e0       	ldi	r21, 0x00	; 0
    28d4:	bc 01       	movw	r22, r24
    28d6:	cd 01       	movw	r24, r26
    28d8:	0e 94 6c 3c 	call	0x78d8	; 0x78d8 <__divmodsi4>
    28dc:	da 01       	movw	r26, r20
    28de:	c9 01       	movw	r24, r18
    28e0:	8b 8b       	std	Y+19, r24	; 0x13
    28e2:	9c 8b       	std	Y+20, r25	; 0x14
    28e4:	ad 8b       	std	Y+21, r26	; 0x15
    28e6:	be 8b       	std	Y+22, r27	; 0x16
		i++;
    28e8:	8a 81       	ldd	r24, Y+2	; 0x02
    28ea:	8f 5f       	subi	r24, 0xFF	; 255
    28ec:	8a 83       	std	Y+2, r24	; 0x02
	}while(num>0);
    28ee:	8b 89       	ldd	r24, Y+19	; 0x13
    28f0:	9c 89       	ldd	r25, Y+20	; 0x14
    28f2:	ad 89       	ldd	r26, Y+21	; 0x15
    28f4:	be 89       	ldd	r27, Y+22	; 0x16
    28f6:	18 16       	cp	r1, r24
    28f8:	19 06       	cpc	r1, r25
    28fa:	1a 06       	cpc	r1, r26
    28fc:	1b 06       	cpc	r1, r27
    28fe:	4c f2       	brlt	.-110    	; 0x2892 <LCD_WriteNumber+0x52>

	for(s8 j=i-1;j>=0;j--)
    2900:	8a 81       	ldd	r24, Y+2	; 0x02
    2902:	81 50       	subi	r24, 0x01	; 1
    2904:	89 83       	std	Y+1, r24	; 0x01
    2906:	10 c0       	rjmp	.+32     	; 0x2928 <LCD_WriteNumber+0xe8>
	{   LCD_WriteChar(str[j]);
    2908:	89 81       	ldd	r24, Y+1	; 0x01
    290a:	28 2f       	mov	r18, r24
    290c:	33 27       	eor	r19, r19
    290e:	27 fd       	sbrc	r18, 7
    2910:	30 95       	com	r19
    2912:	ce 01       	movw	r24, r28
    2914:	03 96       	adiw	r24, 0x03	; 3
    2916:	fc 01       	movw	r30, r24
    2918:	e2 0f       	add	r30, r18
    291a:	f3 1f       	adc	r31, r19
    291c:	80 81       	ld	r24, Z
    291e:	0e 94 a2 14 	call	0x2944	; 0x2944 <LCD_WriteChar>
		str[i]=num%10+'0';
		num=num/10;
		i++;
	}while(num>0);

	for(s8 j=i-1;j>=0;j--)
    2922:	89 81       	ldd	r24, Y+1	; 0x01
    2924:	81 50       	subi	r24, 0x01	; 1
    2926:	89 83       	std	Y+1, r24	; 0x01
    2928:	89 81       	ldd	r24, Y+1	; 0x01
    292a:	88 23       	and	r24, r24
    292c:	6c f7       	brge	.-38     	; 0x2908 <LCD_WriteNumber+0xc8>
	{   LCD_WriteChar(str[j]);
	}

}
    292e:	66 96       	adiw	r28, 0x16	; 22
    2930:	0f b6       	in	r0, 0x3f	; 63
    2932:	f8 94       	cli
    2934:	de bf       	out	0x3e, r29	; 62
    2936:	0f be       	out	0x3f, r0	; 63
    2938:	cd bf       	out	0x3d, r28	; 61
    293a:	cf 91       	pop	r28
    293c:	df 91       	pop	r29
    293e:	1f 91       	pop	r17
    2940:	0f 91       	pop	r16
    2942:	08 95       	ret

00002944 <LCD_WriteChar>:


void LCD_WriteChar(u8 ch){
    2944:	df 93       	push	r29
    2946:	cf 93       	push	r28
    2948:	0f 92       	push	r0
    294a:	cd b7       	in	r28, 0x3d	; 61
    294c:	de b7       	in	r29, 0x3e	; 62
    294e:	89 83       	std	Y+1, r24	; 0x01
	LCD_WriteData(ch);
    2950:	89 81       	ldd	r24, Y+1	; 0x01
    2952:	0e 94 a6 12 	call	0x254c	; 0x254c <LCD_WriteData>
}
    2956:	0f 90       	pop	r0
    2958:	cf 91       	pop	r28
    295a:	df 91       	pop	r29
    295c:	08 95       	ret

0000295e <LCD_WriteString>:

void LCD_WriteString(u8 *str){
    295e:	0f 93       	push	r16
    2960:	1f 93       	push	r17
    2962:	df 93       	push	r29
    2964:	cf 93       	push	r28
    2966:	00 d0       	rcall	.+0      	; 0x2968 <LCD_WriteString+0xa>
    2968:	0f 92       	push	r0
    296a:	cd b7       	in	r28, 0x3d	; 61
    296c:	de b7       	in	r29, 0x3e	; 62
    296e:	9b 83       	std	Y+3, r25	; 0x03
    2970:	8a 83       	std	Y+2, r24	; 0x02

	for(u8 i=0;i<strlen(str);i++){
    2972:	19 82       	std	Y+1, r1	; 0x01
    2974:	0e c0       	rjmp	.+28     	; 0x2992 <LCD_WriteString+0x34>
		LCD_WriteChar(str[i]);
    2976:	89 81       	ldd	r24, Y+1	; 0x01
    2978:	28 2f       	mov	r18, r24
    297a:	30 e0       	ldi	r19, 0x00	; 0
    297c:	8a 81       	ldd	r24, Y+2	; 0x02
    297e:	9b 81       	ldd	r25, Y+3	; 0x03
    2980:	fc 01       	movw	r30, r24
    2982:	e2 0f       	add	r30, r18
    2984:	f3 1f       	adc	r31, r19
    2986:	80 81       	ld	r24, Z
    2988:	0e 94 a2 14 	call	0x2944	; 0x2944 <LCD_WriteChar>
	LCD_WriteData(ch);
}

void LCD_WriteString(u8 *str){

	for(u8 i=0;i<strlen(str);i++){
    298c:	89 81       	ldd	r24, Y+1	; 0x01
    298e:	8f 5f       	subi	r24, 0xFF	; 255
    2990:	89 83       	std	Y+1, r24	; 0x01
    2992:	89 81       	ldd	r24, Y+1	; 0x01
    2994:	08 2f       	mov	r16, r24
    2996:	10 e0       	ldi	r17, 0x00	; 0
    2998:	8a 81       	ldd	r24, Y+2	; 0x02
    299a:	9b 81       	ldd	r25, Y+3	; 0x03
    299c:	0e 94 fc 3c 	call	0x79f8	; 0x79f8 <strlen>
    29a0:	08 17       	cp	r16, r24
    29a2:	19 07       	cpc	r17, r25
    29a4:	40 f3       	brcs	.-48     	; 0x2976 <LCD_WriteString+0x18>
		LCD_WriteChar(str[i]);

	}


}
    29a6:	0f 90       	pop	r0
    29a8:	0f 90       	pop	r0
    29aa:	0f 90       	pop	r0
    29ac:	cf 91       	pop	r28
    29ae:	df 91       	pop	r29
    29b0:	1f 91       	pop	r17
    29b2:	0f 91       	pop	r16
    29b4:	08 95       	ret

000029b6 <LCD_Clear>:
void LCD_Clear(void) {
    29b6:	df 93       	push	r29
    29b8:	cf 93       	push	r28
    29ba:	cd b7       	in	r28, 0x3d	; 61
    29bc:	de b7       	in	r29, 0x3e	; 62
    29be:	2e 97       	sbiw	r28, 0x0e	; 14
    29c0:	0f b6       	in	r0, 0x3f	; 63
    29c2:	f8 94       	cli
    29c4:	de bf       	out	0x3e, r29	; 62
    29c6:	0f be       	out	0x3f, r0	; 63
    29c8:	cd bf       	out	0x3d, r28	; 61
	LCD_WriteInstruction(0x01);
    29ca:	81 e0       	ldi	r24, 0x01	; 1
    29cc:	0e 94 29 10 	call	0x2052	; 0x2052 <LCD_WriteInstruction>
    29d0:	80 e0       	ldi	r24, 0x00	; 0
    29d2:	90 e0       	ldi	r25, 0x00	; 0
    29d4:	a0 e8       	ldi	r26, 0x80	; 128
    29d6:	bf e3       	ldi	r27, 0x3F	; 63
    29d8:	8b 87       	std	Y+11, r24	; 0x0b
    29da:	9c 87       	std	Y+12, r25	; 0x0c
    29dc:	ad 87       	std	Y+13, r26	; 0x0d
    29de:	be 87       	std	Y+14, r27	; 0x0e
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    29e0:	6b 85       	ldd	r22, Y+11	; 0x0b
    29e2:	7c 85       	ldd	r23, Y+12	; 0x0c
    29e4:	8d 85       	ldd	r24, Y+13	; 0x0d
    29e6:	9e 85       	ldd	r25, Y+14	; 0x0e
    29e8:	20 e0       	ldi	r18, 0x00	; 0
    29ea:	30 e0       	ldi	r19, 0x00	; 0
    29ec:	4a ef       	ldi	r20, 0xFA	; 250
    29ee:	54 e4       	ldi	r21, 0x44	; 68
    29f0:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    29f4:	dc 01       	movw	r26, r24
    29f6:	cb 01       	movw	r24, r22
    29f8:	8f 83       	std	Y+7, r24	; 0x07
    29fa:	98 87       	std	Y+8, r25	; 0x08
    29fc:	a9 87       	std	Y+9, r26	; 0x09
    29fe:	ba 87       	std	Y+10, r27	; 0x0a
	if (__tmp < 1.0)
    2a00:	6f 81       	ldd	r22, Y+7	; 0x07
    2a02:	78 85       	ldd	r23, Y+8	; 0x08
    2a04:	89 85       	ldd	r24, Y+9	; 0x09
    2a06:	9a 85       	ldd	r25, Y+10	; 0x0a
    2a08:	20 e0       	ldi	r18, 0x00	; 0
    2a0a:	30 e0       	ldi	r19, 0x00	; 0
    2a0c:	40 e8       	ldi	r20, 0x80	; 128
    2a0e:	5f e3       	ldi	r21, 0x3F	; 63
    2a10:	0e 94 79 03 	call	0x6f2	; 0x6f2 <__ltsf2>
    2a14:	88 23       	and	r24, r24
    2a16:	2c f4       	brge	.+10     	; 0x2a22 <LCD_Clear+0x6c>
		__ticks = 1;
    2a18:	81 e0       	ldi	r24, 0x01	; 1
    2a1a:	90 e0       	ldi	r25, 0x00	; 0
    2a1c:	9e 83       	std	Y+6, r25	; 0x06
    2a1e:	8d 83       	std	Y+5, r24	; 0x05
    2a20:	3f c0       	rjmp	.+126    	; 0x2aa0 <LCD_Clear+0xea>
	else if (__tmp > 65535)
    2a22:	6f 81       	ldd	r22, Y+7	; 0x07
    2a24:	78 85       	ldd	r23, Y+8	; 0x08
    2a26:	89 85       	ldd	r24, Y+9	; 0x09
    2a28:	9a 85       	ldd	r25, Y+10	; 0x0a
    2a2a:	20 e0       	ldi	r18, 0x00	; 0
    2a2c:	3f ef       	ldi	r19, 0xFF	; 255
    2a2e:	4f e7       	ldi	r20, 0x7F	; 127
    2a30:	57 e4       	ldi	r21, 0x47	; 71
    2a32:	0e 94 19 03 	call	0x632	; 0x632 <__gtsf2>
    2a36:	18 16       	cp	r1, r24
    2a38:	4c f5       	brge	.+82     	; 0x2a8c <LCD_Clear+0xd6>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    2a3a:	6b 85       	ldd	r22, Y+11	; 0x0b
    2a3c:	7c 85       	ldd	r23, Y+12	; 0x0c
    2a3e:	8d 85       	ldd	r24, Y+13	; 0x0d
    2a40:	9e 85       	ldd	r25, Y+14	; 0x0e
    2a42:	20 e0       	ldi	r18, 0x00	; 0
    2a44:	30 e0       	ldi	r19, 0x00	; 0
    2a46:	40 e2       	ldi	r20, 0x20	; 32
    2a48:	51 e4       	ldi	r21, 0x41	; 65
    2a4a:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    2a4e:	dc 01       	movw	r26, r24
    2a50:	cb 01       	movw	r24, r22
    2a52:	bc 01       	movw	r22, r24
    2a54:	cd 01       	movw	r24, r26
    2a56:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    2a5a:	dc 01       	movw	r26, r24
    2a5c:	cb 01       	movw	r24, r22
    2a5e:	9e 83       	std	Y+6, r25	; 0x06
    2a60:	8d 83       	std	Y+5, r24	; 0x05
    2a62:	0f c0       	rjmp	.+30     	; 0x2a82 <LCD_Clear+0xcc>
    2a64:	88 ec       	ldi	r24, 0xC8	; 200
    2a66:	90 e0       	ldi	r25, 0x00	; 0
    2a68:	9c 83       	std	Y+4, r25	; 0x04
    2a6a:	8b 83       	std	Y+3, r24	; 0x03
    2a6c:	8b 81       	ldd	r24, Y+3	; 0x03
    2a6e:	9c 81       	ldd	r25, Y+4	; 0x04
    2a70:	01 97       	sbiw	r24, 0x01	; 1
    2a72:	f1 f7       	brne	.-4      	; 0x2a70 <LCD_Clear+0xba>
    2a74:	9c 83       	std	Y+4, r25	; 0x04
    2a76:	8b 83       	std	Y+3, r24	; 0x03
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    2a78:	8d 81       	ldd	r24, Y+5	; 0x05
    2a7a:	9e 81       	ldd	r25, Y+6	; 0x06
    2a7c:	01 97       	sbiw	r24, 0x01	; 1
    2a7e:	9e 83       	std	Y+6, r25	; 0x06
    2a80:	8d 83       	std	Y+5, r24	; 0x05
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    2a82:	8d 81       	ldd	r24, Y+5	; 0x05
    2a84:	9e 81       	ldd	r25, Y+6	; 0x06
    2a86:	00 97       	sbiw	r24, 0x00	; 0
    2a88:	69 f7       	brne	.-38     	; 0x2a64 <LCD_Clear+0xae>
    2a8a:	14 c0       	rjmp	.+40     	; 0x2ab4 <LCD_Clear+0xfe>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    2a8c:	6f 81       	ldd	r22, Y+7	; 0x07
    2a8e:	78 85       	ldd	r23, Y+8	; 0x08
    2a90:	89 85       	ldd	r24, Y+9	; 0x09
    2a92:	9a 85       	ldd	r25, Y+10	; 0x0a
    2a94:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    2a98:	dc 01       	movw	r26, r24
    2a9a:	cb 01       	movw	r24, r22
    2a9c:	9e 83       	std	Y+6, r25	; 0x06
    2a9e:	8d 83       	std	Y+5, r24	; 0x05
    2aa0:	8d 81       	ldd	r24, Y+5	; 0x05
    2aa2:	9e 81       	ldd	r25, Y+6	; 0x06
    2aa4:	9a 83       	std	Y+2, r25	; 0x02
    2aa6:	89 83       	std	Y+1, r24	; 0x01
    2aa8:	89 81       	ldd	r24, Y+1	; 0x01
    2aaa:	9a 81       	ldd	r25, Y+2	; 0x02
    2aac:	01 97       	sbiw	r24, 0x01	; 1
    2aae:	f1 f7       	brne	.-4      	; 0x2aac <LCD_Clear+0xf6>
    2ab0:	9a 83       	std	Y+2, r25	; 0x02
    2ab2:	89 83       	std	Y+1, r24	; 0x01
	_delay_ms(1);
}
    2ab4:	2e 96       	adiw	r28, 0x0e	; 14
    2ab6:	0f b6       	in	r0, 0x3f	; 63
    2ab8:	f8 94       	cli
    2aba:	de bf       	out	0x3e, r29	; 62
    2abc:	0f be       	out	0x3f, r0	; 63
    2abe:	cd bf       	out	0x3d, r28	; 61
    2ac0:	cf 91       	pop	r28
    2ac2:	df 91       	pop	r29
    2ac4:	08 95       	ret

00002ac6 <LCD_SetCursor>:


void  LCD_SetCursor(u8 line,u8 cell){
    2ac6:	df 93       	push	r29
    2ac8:	cf 93       	push	r28
    2aca:	00 d0       	rcall	.+0      	; 0x2acc <LCD_SetCursor+0x6>
    2acc:	cd b7       	in	r28, 0x3d	; 61
    2ace:	de b7       	in	r29, 0x3e	; 62
    2ad0:	89 83       	std	Y+1, r24	; 0x01
    2ad2:	6a 83       	std	Y+2, r22	; 0x02

	if(line==0)
    2ad4:	89 81       	ldd	r24, Y+1	; 0x01
    2ad6:	88 23       	and	r24, r24
    2ad8:	29 f4       	brne	.+10     	; 0x2ae4 <LCD_SetCursor+0x1e>
	{   LCD_WriteInstruction(0x80+cell);
    2ada:	8a 81       	ldd	r24, Y+2	; 0x02
    2adc:	80 58       	subi	r24, 0x80	; 128
    2ade:	0e 94 29 10 	call	0x2052	; 0x2052 <LCD_WriteInstruction>
    2ae2:	07 c0       	rjmp	.+14     	; 0x2af2 <LCD_SetCursor+0x2c>
	}
	else if(line==1)
    2ae4:	89 81       	ldd	r24, Y+1	; 0x01
    2ae6:	81 30       	cpi	r24, 0x01	; 1
    2ae8:	21 f4       	brne	.+8      	; 0x2af2 <LCD_SetCursor+0x2c>
	{   LCD_WriteInstruction(0x80+0x40+cell);
    2aea:	8a 81       	ldd	r24, Y+2	; 0x02
    2aec:	80 54       	subi	r24, 0x40	; 64
    2aee:	0e 94 29 10 	call	0x2052	; 0x2052 <LCD_WriteInstruction>
	}
}
    2af2:	0f 90       	pop	r0
    2af4:	0f 90       	pop	r0
    2af6:	cf 91       	pop	r28
    2af8:	df 91       	pop	r29
    2afa:	08 95       	ret

00002afc <LCD_WriteHex>:

void LCD_WriteHex(u8 num){
    2afc:	df 93       	push	r29
    2afe:	cf 93       	push	r28
    2b00:	cd b7       	in	r28, 0x3d	; 61
    2b02:	de b7       	in	r29, 0x3e	; 62
    2b04:	64 97       	sbiw	r28, 0x14	; 20
    2b06:	0f b6       	in	r0, 0x3f	; 63
    2b08:	f8 94       	cli
    2b0a:	de bf       	out	0x3e, r29	; 62
    2b0c:	0f be       	out	0x3f, r0	; 63
    2b0e:	cd bf       	out	0x3d, r28	; 61
    2b10:	8c 8b       	std	Y+20, r24	; 0x14

	u8 str[16];
	u8 i=0;
    2b12:	1b 82       	std	Y+3, r1	; 0x03
	u8 value;
	if(num<=15){
    2b14:	8c 89       	ldd	r24, Y+20	; 0x14
    2b16:	80 31       	cpi	r24, 0x10	; 16
    2b18:	a0 f4       	brcc	.+40     	; 0x2b42 <LCD_WriteHex+0x46>
		str[i]="0123456789ABCDEF"[num];
    2b1a:	8b 81       	ldd	r24, Y+3	; 0x03
    2b1c:	28 2f       	mov	r18, r24
    2b1e:	30 e0       	ldi	r19, 0x00	; 0
    2b20:	8c 89       	ldd	r24, Y+20	; 0x14
    2b22:	88 2f       	mov	r24, r24
    2b24:	90 e0       	ldi	r25, 0x00	; 0
    2b26:	fc 01       	movw	r30, r24
    2b28:	e0 5a       	subi	r30, 0xA0	; 160
    2b2a:	ff 4f       	sbci	r31, 0xFF	; 255
    2b2c:	40 81       	ld	r20, Z
    2b2e:	ce 01       	movw	r24, r28
    2b30:	04 96       	adiw	r24, 0x04	; 4
    2b32:	fc 01       	movw	r30, r24
    2b34:	e2 0f       	add	r30, r18
    2b36:	f3 1f       	adc	r31, r19
    2b38:	40 83       	st	Z, r20
		i++;
    2b3a:	8b 81       	ldd	r24, Y+3	; 0x03
    2b3c:	8f 5f       	subi	r24, 0xFF	; 255
    2b3e:	8b 83       	std	Y+3, r24	; 0x03
    2b40:	1d c0       	rjmp	.+58     	; 0x2b7c <LCD_WriteHex+0x80>
	}
	else{
		do{
			value=num%16;
    2b42:	8c 89       	ldd	r24, Y+20	; 0x14
    2b44:	8f 70       	andi	r24, 0x0F	; 15
    2b46:	8a 83       	std	Y+2, r24	; 0x02
			num=num/16;
    2b48:	8c 89       	ldd	r24, Y+20	; 0x14
    2b4a:	82 95       	swap	r24
    2b4c:	8f 70       	andi	r24, 0x0F	; 15
    2b4e:	8c 8b       	std	Y+20, r24	; 0x14
			str[i]="0123456789ABCDEF"[value];
    2b50:	8b 81       	ldd	r24, Y+3	; 0x03
    2b52:	28 2f       	mov	r18, r24
    2b54:	30 e0       	ldi	r19, 0x00	; 0
    2b56:	8a 81       	ldd	r24, Y+2	; 0x02
    2b58:	88 2f       	mov	r24, r24
    2b5a:	90 e0       	ldi	r25, 0x00	; 0
    2b5c:	fc 01       	movw	r30, r24
    2b5e:	e0 5a       	subi	r30, 0xA0	; 160
    2b60:	ff 4f       	sbci	r31, 0xFF	; 255
    2b62:	40 81       	ld	r20, Z
    2b64:	ce 01       	movw	r24, r28
    2b66:	04 96       	adiw	r24, 0x04	; 4
    2b68:	fc 01       	movw	r30, r24
    2b6a:	e2 0f       	add	r30, r18
    2b6c:	f3 1f       	adc	r31, r19
    2b6e:	40 83       	st	Z, r20
			i++;
    2b70:	8b 81       	ldd	r24, Y+3	; 0x03
    2b72:	8f 5f       	subi	r24, 0xFF	; 255
    2b74:	8b 83       	std	Y+3, r24	; 0x03
		}while(num>0);
    2b76:	8c 89       	ldd	r24, Y+20	; 0x14
    2b78:	88 23       	and	r24, r24
    2b7a:	19 f7       	brne	.-58     	; 0x2b42 <LCD_WriteHex+0x46>
	}
	for(s8 j=i-1;j>=0;j--)
    2b7c:	8b 81       	ldd	r24, Y+3	; 0x03
    2b7e:	81 50       	subi	r24, 0x01	; 1
    2b80:	89 83       	std	Y+1, r24	; 0x01
    2b82:	10 c0       	rjmp	.+32     	; 0x2ba4 <LCD_WriteHex+0xa8>
	{   LCD_WriteChar(str[j]);
    2b84:	89 81       	ldd	r24, Y+1	; 0x01
    2b86:	28 2f       	mov	r18, r24
    2b88:	33 27       	eor	r19, r19
    2b8a:	27 fd       	sbrc	r18, 7
    2b8c:	30 95       	com	r19
    2b8e:	ce 01       	movw	r24, r28
    2b90:	04 96       	adiw	r24, 0x04	; 4
    2b92:	fc 01       	movw	r30, r24
    2b94:	e2 0f       	add	r30, r18
    2b96:	f3 1f       	adc	r31, r19
    2b98:	80 81       	ld	r24, Z
    2b9a:	0e 94 a2 14 	call	0x2944	; 0x2944 <LCD_WriteChar>
			num=num/16;
			str[i]="0123456789ABCDEF"[value];
			i++;
		}while(num>0);
	}
	for(s8 j=i-1;j>=0;j--)
    2b9e:	89 81       	ldd	r24, Y+1	; 0x01
    2ba0:	81 50       	subi	r24, 0x01	; 1
    2ba2:	89 83       	std	Y+1, r24	; 0x01
    2ba4:	89 81       	ldd	r24, Y+1	; 0x01
    2ba6:	88 23       	and	r24, r24
    2ba8:	6c f7       	brge	.-38     	; 0x2b84 <LCD_WriteHex+0x88>
	{   LCD_WriteChar(str[j]);
	}
}
    2baa:	64 96       	adiw	r28, 0x14	; 20
    2bac:	0f b6       	in	r0, 0x3f	; 63
    2bae:	f8 94       	cli
    2bb0:	de bf       	out	0x3e, r29	; 62
    2bb2:	0f be       	out	0x3f, r0	; 63
    2bb4:	cd bf       	out	0x3d, r28	; 61
    2bb6:	cf 91       	pop	r28
    2bb8:	df 91       	pop	r29
    2bba:	08 95       	ret

00002bbc <LCD_WriteBinary>:

void LCD_WriteBinary(u8 num){
    2bbc:	df 93       	push	r29
    2bbe:	cf 93       	push	r28
    2bc0:	cd b7       	in	r28, 0x3d	; 61
    2bc2:	de b7       	in	r29, 0x3e	; 62
    2bc4:	2c 97       	sbiw	r28, 0x0c	; 12
    2bc6:	0f b6       	in	r0, 0x3f	; 63
    2bc8:	f8 94       	cli
    2bca:	de bf       	out	0x3e, r29	; 62
    2bcc:	0f be       	out	0x3f, r0	; 63
    2bce:	cd bf       	out	0x3d, r28	; 61
    2bd0:	8c 87       	std	Y+12, r24	; 0x0c

	u8 str[8];
	u8 i=0;
    2bd2:	1b 82       	std	Y+3, r1	; 0x03
	u8 value;
	//num=100;
	do{
		value=(u8)(num%2); //1 1 1 1 >>15
    2bd4:	8c 85       	ldd	r24, Y+12	; 0x0c
    2bd6:	81 70       	andi	r24, 0x01	; 1
    2bd8:	8a 83       	std	Y+2, r24	; 0x02

		num/=2; //7 3 1 0 >>15
    2bda:	8c 85       	ldd	r24, Y+12	; 0x0c
    2bdc:	86 95       	lsr	r24
    2bde:	8c 87       	std	Y+12, r24	; 0x0c
		if(value==1){
    2be0:	8a 81       	ldd	r24, Y+2	; 0x02
    2be2:	81 30       	cpi	r24, 0x01	; 1
    2be4:	59 f4       	brne	.+22     	; 0x2bfc <LCD_WriteBinary+0x40>
			str[i]='1';
    2be6:	8b 81       	ldd	r24, Y+3	; 0x03
    2be8:	28 2f       	mov	r18, r24
    2bea:	30 e0       	ldi	r19, 0x00	; 0
    2bec:	ce 01       	movw	r24, r28
    2bee:	04 96       	adiw	r24, 0x04	; 4
    2bf0:	fc 01       	movw	r30, r24
    2bf2:	e2 0f       	add	r30, r18
    2bf4:	f3 1f       	adc	r31, r19
    2bf6:	81 e3       	ldi	r24, 0x31	; 49
    2bf8:	80 83       	st	Z, r24
    2bfa:	0a c0       	rjmp	.+20     	; 0x2c10 <LCD_WriteBinary+0x54>
		}
		else{
			str[i]='0';
    2bfc:	8b 81       	ldd	r24, Y+3	; 0x03
    2bfe:	28 2f       	mov	r18, r24
    2c00:	30 e0       	ldi	r19, 0x00	; 0
    2c02:	ce 01       	movw	r24, r28
    2c04:	04 96       	adiw	r24, 0x04	; 4
    2c06:	fc 01       	movw	r30, r24
    2c08:	e2 0f       	add	r30, r18
    2c0a:	f3 1f       	adc	r31, r19
    2c0c:	80 e3       	ldi	r24, 0x30	; 48
    2c0e:	80 83       	st	Z, r24
		}

		i++;
    2c10:	8b 81       	ldd	r24, Y+3	; 0x03
    2c12:	8f 5f       	subi	r24, 0xFF	; 255
    2c14:	8b 83       	std	Y+3, r24	; 0x03
	}while(num>0);
    2c16:	8c 85       	ldd	r24, Y+12	; 0x0c
    2c18:	88 23       	and	r24, r24
    2c1a:	e1 f6       	brne	.-72     	; 0x2bd4 <LCD_WriteBinary+0x18>

	//LCD_WriteChar('P');
	for(s8 j=i-1;j>=0;j--)
    2c1c:	8b 81       	ldd	r24, Y+3	; 0x03
    2c1e:	81 50       	subi	r24, 0x01	; 1
    2c20:	89 83       	std	Y+1, r24	; 0x01
    2c22:	10 c0       	rjmp	.+32     	; 0x2c44 <LCD_WriteBinary+0x88>
	{

		LCD_WriteChar(str[j]);
    2c24:	89 81       	ldd	r24, Y+1	; 0x01
    2c26:	28 2f       	mov	r18, r24
    2c28:	33 27       	eor	r19, r19
    2c2a:	27 fd       	sbrc	r18, 7
    2c2c:	30 95       	com	r19
    2c2e:	ce 01       	movw	r24, r28
    2c30:	04 96       	adiw	r24, 0x04	; 4
    2c32:	fc 01       	movw	r30, r24
    2c34:	e2 0f       	add	r30, r18
    2c36:	f3 1f       	adc	r31, r19
    2c38:	80 81       	ld	r24, Z
    2c3a:	0e 94 a2 14 	call	0x2944	; 0x2944 <LCD_WriteChar>

		i++;
	}while(num>0);

	//LCD_WriteChar('P');
	for(s8 j=i-1;j>=0;j--)
    2c3e:	89 81       	ldd	r24, Y+1	; 0x01
    2c40:	81 50       	subi	r24, 0x01	; 1
    2c42:	89 83       	std	Y+1, r24	; 0x01
    2c44:	89 81       	ldd	r24, Y+1	; 0x01
    2c46:	88 23       	and	r24, r24
    2c48:	6c f7       	brge	.-38     	; 0x2c24 <LCD_WriteBinary+0x68>
	}




}
    2c4a:	2c 96       	adiw	r28, 0x0c	; 12
    2c4c:	0f b6       	in	r0, 0x3f	; 63
    2c4e:	f8 94       	cli
    2c50:	de bf       	out	0x3e, r29	; 62
    2c52:	0f be       	out	0x3f, r0	; 63
    2c54:	cd bf       	out	0x3d, r28	; 61
    2c56:	cf 91       	pop	r28
    2c58:	df 91       	pop	r29
    2c5a:	08 95       	ret

00002c5c <MOTOR_CW>:
};



void MOTOR_CW(MOTOR_type motor )
{
    2c5c:	df 93       	push	r29
    2c5e:	cf 93       	push	r28
    2c60:	0f 92       	push	r0
    2c62:	cd b7       	in	r28, 0x3d	; 61
    2c64:	de b7       	in	r29, 0x3e	; 62
    2c66:	89 83       	std	Y+1, r24	; 0x01
	DIO_WritePin(MotorPinsArray[motor][IN1],HIGH);
    2c68:	89 81       	ldd	r24, Y+1	; 0x01
    2c6a:	88 2f       	mov	r24, r24
    2c6c:	90 e0       	ldi	r25, 0x00	; 0
    2c6e:	88 0f       	add	r24, r24
    2c70:	99 1f       	adc	r25, r25
    2c72:	88 0f       	add	r24, r24
    2c74:	99 1f       	adc	r25, r25
    2c76:	fc 01       	movw	r30, r24
    2c78:	ec 5d       	subi	r30, 0xDC	; 220
    2c7a:	fe 4f       	sbci	r31, 0xFE	; 254
    2c7c:	80 81       	ld	r24, Z
    2c7e:	91 81       	ldd	r25, Z+1	; 0x01
    2c80:	61 e0       	ldi	r22, 0x01	; 1
    2c82:	0e 94 f9 09 	call	0x13f2	; 0x13f2 <DIO_WritePin>
	DIO_WritePin(MotorPinsArray[motor][IN2],LOW);
    2c86:	89 81       	ldd	r24, Y+1	; 0x01
    2c88:	88 2f       	mov	r24, r24
    2c8a:	90 e0       	ldi	r25, 0x00	; 0
    2c8c:	88 0f       	add	r24, r24
    2c8e:	99 1f       	adc	r25, r25
    2c90:	01 96       	adiw	r24, 0x01	; 1
    2c92:	88 0f       	add	r24, r24
    2c94:	99 1f       	adc	r25, r25
    2c96:	fc 01       	movw	r30, r24
    2c98:	ec 5d       	subi	r30, 0xDC	; 220
    2c9a:	fe 4f       	sbci	r31, 0xFE	; 254
    2c9c:	80 81       	ld	r24, Z
    2c9e:	91 81       	ldd	r25, Z+1	; 0x01
    2ca0:	60 e0       	ldi	r22, 0x00	; 0
    2ca2:	0e 94 f9 09 	call	0x13f2	; 0x13f2 <DIO_WritePin>
}
    2ca6:	0f 90       	pop	r0
    2ca8:	cf 91       	pop	r28
    2caa:	df 91       	pop	r29
    2cac:	08 95       	ret

00002cae <MOTOR_CCW>:
void MOTOR_CCW(MOTOR_type motor)
{
    2cae:	df 93       	push	r29
    2cb0:	cf 93       	push	r28
    2cb2:	0f 92       	push	r0
    2cb4:	cd b7       	in	r28, 0x3d	; 61
    2cb6:	de b7       	in	r29, 0x3e	; 62
    2cb8:	89 83       	std	Y+1, r24	; 0x01
    DIO_WritePin(MotorPinsArray[motor][IN1],LOW);
    2cba:	89 81       	ldd	r24, Y+1	; 0x01
    2cbc:	88 2f       	mov	r24, r24
    2cbe:	90 e0       	ldi	r25, 0x00	; 0
    2cc0:	88 0f       	add	r24, r24
    2cc2:	99 1f       	adc	r25, r25
    2cc4:	88 0f       	add	r24, r24
    2cc6:	99 1f       	adc	r25, r25
    2cc8:	fc 01       	movw	r30, r24
    2cca:	ec 5d       	subi	r30, 0xDC	; 220
    2ccc:	fe 4f       	sbci	r31, 0xFE	; 254
    2cce:	80 81       	ld	r24, Z
    2cd0:	91 81       	ldd	r25, Z+1	; 0x01
    2cd2:	60 e0       	ldi	r22, 0x00	; 0
    2cd4:	0e 94 f9 09 	call	0x13f2	; 0x13f2 <DIO_WritePin>
    DIO_WritePin(MotorPinsArray[motor][IN2],HIGH);
    2cd8:	89 81       	ldd	r24, Y+1	; 0x01
    2cda:	88 2f       	mov	r24, r24
    2cdc:	90 e0       	ldi	r25, 0x00	; 0
    2cde:	88 0f       	add	r24, r24
    2ce0:	99 1f       	adc	r25, r25
    2ce2:	01 96       	adiw	r24, 0x01	; 1
    2ce4:	88 0f       	add	r24, r24
    2ce6:	99 1f       	adc	r25, r25
    2ce8:	fc 01       	movw	r30, r24
    2cea:	ec 5d       	subi	r30, 0xDC	; 220
    2cec:	fe 4f       	sbci	r31, 0xFE	; 254
    2cee:	80 81       	ld	r24, Z
    2cf0:	91 81       	ldd	r25, Z+1	; 0x01
    2cf2:	61 e0       	ldi	r22, 0x01	; 1
    2cf4:	0e 94 f9 09 	call	0x13f2	; 0x13f2 <DIO_WritePin>
}
    2cf8:	0f 90       	pop	r0
    2cfa:	cf 91       	pop	r28
    2cfc:	df 91       	pop	r29
    2cfe:	08 95       	ret

00002d00 <MOTOR_STOP>:
void MOTOR_STOP(MOTOR_type motor)
{
    2d00:	df 93       	push	r29
    2d02:	cf 93       	push	r28
    2d04:	0f 92       	push	r0
    2d06:	cd b7       	in	r28, 0x3d	; 61
    2d08:	de b7       	in	r29, 0x3e	; 62
    2d0a:	89 83       	std	Y+1, r24	; 0x01
	DIO_WritePin(MotorPinsArray[motor][IN1],LOW);
    2d0c:	89 81       	ldd	r24, Y+1	; 0x01
    2d0e:	88 2f       	mov	r24, r24
    2d10:	90 e0       	ldi	r25, 0x00	; 0
    2d12:	88 0f       	add	r24, r24
    2d14:	99 1f       	adc	r25, r25
    2d16:	88 0f       	add	r24, r24
    2d18:	99 1f       	adc	r25, r25
    2d1a:	fc 01       	movw	r30, r24
    2d1c:	ec 5d       	subi	r30, 0xDC	; 220
    2d1e:	fe 4f       	sbci	r31, 0xFE	; 254
    2d20:	80 81       	ld	r24, Z
    2d22:	91 81       	ldd	r25, Z+1	; 0x01
    2d24:	60 e0       	ldi	r22, 0x00	; 0
    2d26:	0e 94 f9 09 	call	0x13f2	; 0x13f2 <DIO_WritePin>
	DIO_WritePin(MotorPinsArray[motor][IN2],LOW);
    2d2a:	89 81       	ldd	r24, Y+1	; 0x01
    2d2c:	88 2f       	mov	r24, r24
    2d2e:	90 e0       	ldi	r25, 0x00	; 0
    2d30:	88 0f       	add	r24, r24
    2d32:	99 1f       	adc	r25, r25
    2d34:	01 96       	adiw	r24, 0x01	; 1
    2d36:	88 0f       	add	r24, r24
    2d38:	99 1f       	adc	r25, r25
    2d3a:	fc 01       	movw	r30, r24
    2d3c:	ec 5d       	subi	r30, 0xDC	; 220
    2d3e:	fe 4f       	sbci	r31, 0xFE	; 254
    2d40:	80 81       	ld	r24, Z
    2d42:	91 81       	ldd	r25, Z+1	; 0x01
    2d44:	60 e0       	ldi	r22, 0x00	; 0
    2d46:	0e 94 f9 09 	call	0x13f2	; 0x13f2 <DIO_WritePin>
}
    2d4a:	0f 90       	pop	r0
    2d4c:	cf 91       	pop	r28
    2d4e:	df 91       	pop	r29
    2d50:	08 95       	ret

00002d52 <STEPPER_Bipolar_CW>:


#include "Stepper.h"

void STEPPER_Bipolar_CW(void)
{
    2d52:	df 93       	push	r29
    2d54:	cf 93       	push	r28
    2d56:	cd b7       	in	r28, 0x3d	; 61
    2d58:	de b7       	in	r29, 0x3e	; 62
    2d5a:	aa 97       	sbiw	r28, 0x2a	; 42
    2d5c:	0f b6       	in	r0, 0x3f	; 63
    2d5e:	f8 94       	cli
    2d60:	de bf       	out	0x3e, r29	; 62
    2d62:	0f be       	out	0x3f, r0	; 63
    2d64:	cd bf       	out	0x3d, r28	; 61
	DIO_WritePin(COIL1A,HIGH);
    2d66:	84 e1       	ldi	r24, 0x14	; 20
    2d68:	61 e0       	ldi	r22, 0x01	; 1
    2d6a:	0e 94 f9 09 	call	0x13f2	; 0x13f2 <DIO_WritePin>
	DIO_WritePin(COIL1B,LOW);
    2d6e:	85 e1       	ldi	r24, 0x15	; 21
    2d70:	60 e0       	ldi	r22, 0x00	; 0
    2d72:	0e 94 f9 09 	call	0x13f2	; 0x13f2 <DIO_WritePin>
	DIO_WritePin(COIL2A,LOW);
    2d76:	86 e1       	ldi	r24, 0x16	; 22
    2d78:	60 e0       	ldi	r22, 0x00	; 0
    2d7a:	0e 94 f9 09 	call	0x13f2	; 0x13f2 <DIO_WritePin>
	DIO_WritePin(COIL2B,LOW);
    2d7e:	87 e1       	ldi	r24, 0x17	; 23
    2d80:	60 e0       	ldi	r22, 0x00	; 0
    2d82:	0e 94 f9 09 	call	0x13f2	; 0x13f2 <DIO_WritePin>
    2d86:	80 e0       	ldi	r24, 0x00	; 0
    2d88:	90 e0       	ldi	r25, 0x00	; 0
    2d8a:	aa ef       	ldi	r26, 0xFA	; 250
    2d8c:	b3 e4       	ldi	r27, 0x43	; 67
    2d8e:	8f a3       	std	Y+39, r24	; 0x27
    2d90:	98 a7       	std	Y+40, r25	; 0x28
    2d92:	a9 a7       	std	Y+41, r26	; 0x29
    2d94:	ba a7       	std	Y+42, r27	; 0x2a
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    2d96:	6f a1       	ldd	r22, Y+39	; 0x27
    2d98:	78 a5       	ldd	r23, Y+40	; 0x28
    2d9a:	89 a5       	ldd	r24, Y+41	; 0x29
    2d9c:	9a a5       	ldd	r25, Y+42	; 0x2a
    2d9e:	20 e0       	ldi	r18, 0x00	; 0
    2da0:	30 e0       	ldi	r19, 0x00	; 0
    2da2:	4a ef       	ldi	r20, 0xFA	; 250
    2da4:	54 e4       	ldi	r21, 0x44	; 68
    2da6:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    2daa:	dc 01       	movw	r26, r24
    2dac:	cb 01       	movw	r24, r22
    2dae:	8b a3       	std	Y+35, r24	; 0x23
    2db0:	9c a3       	std	Y+36, r25	; 0x24
    2db2:	ad a3       	std	Y+37, r26	; 0x25
    2db4:	be a3       	std	Y+38, r27	; 0x26
	if (__tmp < 1.0)
    2db6:	6b a1       	ldd	r22, Y+35	; 0x23
    2db8:	7c a1       	ldd	r23, Y+36	; 0x24
    2dba:	8d a1       	ldd	r24, Y+37	; 0x25
    2dbc:	9e a1       	ldd	r25, Y+38	; 0x26
    2dbe:	20 e0       	ldi	r18, 0x00	; 0
    2dc0:	30 e0       	ldi	r19, 0x00	; 0
    2dc2:	40 e8       	ldi	r20, 0x80	; 128
    2dc4:	5f e3       	ldi	r21, 0x3F	; 63
    2dc6:	0e 94 79 03 	call	0x6f2	; 0x6f2 <__ltsf2>
    2dca:	88 23       	and	r24, r24
    2dcc:	2c f4       	brge	.+10     	; 0x2dd8 <STEPPER_Bipolar_CW+0x86>
		__ticks = 1;
    2dce:	81 e0       	ldi	r24, 0x01	; 1
    2dd0:	90 e0       	ldi	r25, 0x00	; 0
    2dd2:	9a a3       	std	Y+34, r25	; 0x22
    2dd4:	89 a3       	std	Y+33, r24	; 0x21
    2dd6:	3f c0       	rjmp	.+126    	; 0x2e56 <STEPPER_Bipolar_CW+0x104>
	else if (__tmp > 65535)
    2dd8:	6b a1       	ldd	r22, Y+35	; 0x23
    2dda:	7c a1       	ldd	r23, Y+36	; 0x24
    2ddc:	8d a1       	ldd	r24, Y+37	; 0x25
    2dde:	9e a1       	ldd	r25, Y+38	; 0x26
    2de0:	20 e0       	ldi	r18, 0x00	; 0
    2de2:	3f ef       	ldi	r19, 0xFF	; 255
    2de4:	4f e7       	ldi	r20, 0x7F	; 127
    2de6:	57 e4       	ldi	r21, 0x47	; 71
    2de8:	0e 94 19 03 	call	0x632	; 0x632 <__gtsf2>
    2dec:	18 16       	cp	r1, r24
    2dee:	4c f5       	brge	.+82     	; 0x2e42 <STEPPER_Bipolar_CW+0xf0>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    2df0:	6f a1       	ldd	r22, Y+39	; 0x27
    2df2:	78 a5       	ldd	r23, Y+40	; 0x28
    2df4:	89 a5       	ldd	r24, Y+41	; 0x29
    2df6:	9a a5       	ldd	r25, Y+42	; 0x2a
    2df8:	20 e0       	ldi	r18, 0x00	; 0
    2dfa:	30 e0       	ldi	r19, 0x00	; 0
    2dfc:	40 e2       	ldi	r20, 0x20	; 32
    2dfe:	51 e4       	ldi	r21, 0x41	; 65
    2e00:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    2e04:	dc 01       	movw	r26, r24
    2e06:	cb 01       	movw	r24, r22
    2e08:	bc 01       	movw	r22, r24
    2e0a:	cd 01       	movw	r24, r26
    2e0c:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    2e10:	dc 01       	movw	r26, r24
    2e12:	cb 01       	movw	r24, r22
    2e14:	9a a3       	std	Y+34, r25	; 0x22
    2e16:	89 a3       	std	Y+33, r24	; 0x21
    2e18:	0f c0       	rjmp	.+30     	; 0x2e38 <STEPPER_Bipolar_CW+0xe6>
    2e1a:	88 ec       	ldi	r24, 0xC8	; 200
    2e1c:	90 e0       	ldi	r25, 0x00	; 0
    2e1e:	98 a3       	std	Y+32, r25	; 0x20
    2e20:	8f 8f       	std	Y+31, r24	; 0x1f
    2e22:	8f 8d       	ldd	r24, Y+31	; 0x1f
    2e24:	98 a1       	ldd	r25, Y+32	; 0x20
    2e26:	01 97       	sbiw	r24, 0x01	; 1
    2e28:	f1 f7       	brne	.-4      	; 0x2e26 <STEPPER_Bipolar_CW+0xd4>
    2e2a:	98 a3       	std	Y+32, r25	; 0x20
    2e2c:	8f 8f       	std	Y+31, r24	; 0x1f
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    2e2e:	89 a1       	ldd	r24, Y+33	; 0x21
    2e30:	9a a1       	ldd	r25, Y+34	; 0x22
    2e32:	01 97       	sbiw	r24, 0x01	; 1
    2e34:	9a a3       	std	Y+34, r25	; 0x22
    2e36:	89 a3       	std	Y+33, r24	; 0x21
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    2e38:	89 a1       	ldd	r24, Y+33	; 0x21
    2e3a:	9a a1       	ldd	r25, Y+34	; 0x22
    2e3c:	00 97       	sbiw	r24, 0x00	; 0
    2e3e:	69 f7       	brne	.-38     	; 0x2e1a <STEPPER_Bipolar_CW+0xc8>
    2e40:	14 c0       	rjmp	.+40     	; 0x2e6a <STEPPER_Bipolar_CW+0x118>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    2e42:	6b a1       	ldd	r22, Y+35	; 0x23
    2e44:	7c a1       	ldd	r23, Y+36	; 0x24
    2e46:	8d a1       	ldd	r24, Y+37	; 0x25
    2e48:	9e a1       	ldd	r25, Y+38	; 0x26
    2e4a:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    2e4e:	dc 01       	movw	r26, r24
    2e50:	cb 01       	movw	r24, r22
    2e52:	9a a3       	std	Y+34, r25	; 0x22
    2e54:	89 a3       	std	Y+33, r24	; 0x21
    2e56:	89 a1       	ldd	r24, Y+33	; 0x21
    2e58:	9a a1       	ldd	r25, Y+34	; 0x22
    2e5a:	9e 8f       	std	Y+30, r25	; 0x1e
    2e5c:	8d 8f       	std	Y+29, r24	; 0x1d
    2e5e:	8d 8d       	ldd	r24, Y+29	; 0x1d
    2e60:	9e 8d       	ldd	r25, Y+30	; 0x1e
    2e62:	01 97       	sbiw	r24, 0x01	; 1
    2e64:	f1 f7       	brne	.-4      	; 0x2e62 <STEPPER_Bipolar_CW+0x110>
    2e66:	9e 8f       	std	Y+30, r25	; 0x1e
    2e68:	8d 8f       	std	Y+29, r24	; 0x1d
	_delay_ms( DELAY );
	DIO_WritePin(COIL1A,LOW);
    2e6a:	84 e1       	ldi	r24, 0x14	; 20
    2e6c:	60 e0       	ldi	r22, 0x00	; 0
    2e6e:	0e 94 f9 09 	call	0x13f2	; 0x13f2 <DIO_WritePin>
	DIO_WritePin(COIL1B,LOW);
    2e72:	85 e1       	ldi	r24, 0x15	; 21
    2e74:	60 e0       	ldi	r22, 0x00	; 0
    2e76:	0e 94 f9 09 	call	0x13f2	; 0x13f2 <DIO_WritePin>
	DIO_WritePin(COIL2A,HIGH);
    2e7a:	86 e1       	ldi	r24, 0x16	; 22
    2e7c:	61 e0       	ldi	r22, 0x01	; 1
    2e7e:	0e 94 f9 09 	call	0x13f2	; 0x13f2 <DIO_WritePin>
	DIO_WritePin(COIL2B,LOW);
    2e82:	87 e1       	ldi	r24, 0x17	; 23
    2e84:	60 e0       	ldi	r22, 0x00	; 0
    2e86:	0e 94 f9 09 	call	0x13f2	; 0x13f2 <DIO_WritePin>
    2e8a:	80 e0       	ldi	r24, 0x00	; 0
    2e8c:	90 e0       	ldi	r25, 0x00	; 0
    2e8e:	aa ef       	ldi	r26, 0xFA	; 250
    2e90:	b3 e4       	ldi	r27, 0x43	; 67
    2e92:	89 8f       	std	Y+25, r24	; 0x19
    2e94:	9a 8f       	std	Y+26, r25	; 0x1a
    2e96:	ab 8f       	std	Y+27, r26	; 0x1b
    2e98:	bc 8f       	std	Y+28, r27	; 0x1c
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    2e9a:	69 8d       	ldd	r22, Y+25	; 0x19
    2e9c:	7a 8d       	ldd	r23, Y+26	; 0x1a
    2e9e:	8b 8d       	ldd	r24, Y+27	; 0x1b
    2ea0:	9c 8d       	ldd	r25, Y+28	; 0x1c
    2ea2:	20 e0       	ldi	r18, 0x00	; 0
    2ea4:	30 e0       	ldi	r19, 0x00	; 0
    2ea6:	4a ef       	ldi	r20, 0xFA	; 250
    2ea8:	54 e4       	ldi	r21, 0x44	; 68
    2eaa:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    2eae:	dc 01       	movw	r26, r24
    2eb0:	cb 01       	movw	r24, r22
    2eb2:	8d 8b       	std	Y+21, r24	; 0x15
    2eb4:	9e 8b       	std	Y+22, r25	; 0x16
    2eb6:	af 8b       	std	Y+23, r26	; 0x17
    2eb8:	b8 8f       	std	Y+24, r27	; 0x18
	if (__tmp < 1.0)
    2eba:	6d 89       	ldd	r22, Y+21	; 0x15
    2ebc:	7e 89       	ldd	r23, Y+22	; 0x16
    2ebe:	8f 89       	ldd	r24, Y+23	; 0x17
    2ec0:	98 8d       	ldd	r25, Y+24	; 0x18
    2ec2:	20 e0       	ldi	r18, 0x00	; 0
    2ec4:	30 e0       	ldi	r19, 0x00	; 0
    2ec6:	40 e8       	ldi	r20, 0x80	; 128
    2ec8:	5f e3       	ldi	r21, 0x3F	; 63
    2eca:	0e 94 79 03 	call	0x6f2	; 0x6f2 <__ltsf2>
    2ece:	88 23       	and	r24, r24
    2ed0:	2c f4       	brge	.+10     	; 0x2edc <STEPPER_Bipolar_CW+0x18a>
		__ticks = 1;
    2ed2:	81 e0       	ldi	r24, 0x01	; 1
    2ed4:	90 e0       	ldi	r25, 0x00	; 0
    2ed6:	9c 8b       	std	Y+20, r25	; 0x14
    2ed8:	8b 8b       	std	Y+19, r24	; 0x13
    2eda:	3f c0       	rjmp	.+126    	; 0x2f5a <STEPPER_Bipolar_CW+0x208>
	else if (__tmp > 65535)
    2edc:	6d 89       	ldd	r22, Y+21	; 0x15
    2ede:	7e 89       	ldd	r23, Y+22	; 0x16
    2ee0:	8f 89       	ldd	r24, Y+23	; 0x17
    2ee2:	98 8d       	ldd	r25, Y+24	; 0x18
    2ee4:	20 e0       	ldi	r18, 0x00	; 0
    2ee6:	3f ef       	ldi	r19, 0xFF	; 255
    2ee8:	4f e7       	ldi	r20, 0x7F	; 127
    2eea:	57 e4       	ldi	r21, 0x47	; 71
    2eec:	0e 94 19 03 	call	0x632	; 0x632 <__gtsf2>
    2ef0:	18 16       	cp	r1, r24
    2ef2:	4c f5       	brge	.+82     	; 0x2f46 <STEPPER_Bipolar_CW+0x1f4>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    2ef4:	69 8d       	ldd	r22, Y+25	; 0x19
    2ef6:	7a 8d       	ldd	r23, Y+26	; 0x1a
    2ef8:	8b 8d       	ldd	r24, Y+27	; 0x1b
    2efa:	9c 8d       	ldd	r25, Y+28	; 0x1c
    2efc:	20 e0       	ldi	r18, 0x00	; 0
    2efe:	30 e0       	ldi	r19, 0x00	; 0
    2f00:	40 e2       	ldi	r20, 0x20	; 32
    2f02:	51 e4       	ldi	r21, 0x41	; 65
    2f04:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    2f08:	dc 01       	movw	r26, r24
    2f0a:	cb 01       	movw	r24, r22
    2f0c:	bc 01       	movw	r22, r24
    2f0e:	cd 01       	movw	r24, r26
    2f10:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    2f14:	dc 01       	movw	r26, r24
    2f16:	cb 01       	movw	r24, r22
    2f18:	9c 8b       	std	Y+20, r25	; 0x14
    2f1a:	8b 8b       	std	Y+19, r24	; 0x13
    2f1c:	0f c0       	rjmp	.+30     	; 0x2f3c <STEPPER_Bipolar_CW+0x1ea>
    2f1e:	88 ec       	ldi	r24, 0xC8	; 200
    2f20:	90 e0       	ldi	r25, 0x00	; 0
    2f22:	9a 8b       	std	Y+18, r25	; 0x12
    2f24:	89 8b       	std	Y+17, r24	; 0x11
    2f26:	89 89       	ldd	r24, Y+17	; 0x11
    2f28:	9a 89       	ldd	r25, Y+18	; 0x12
    2f2a:	01 97       	sbiw	r24, 0x01	; 1
    2f2c:	f1 f7       	brne	.-4      	; 0x2f2a <STEPPER_Bipolar_CW+0x1d8>
    2f2e:	9a 8b       	std	Y+18, r25	; 0x12
    2f30:	89 8b       	std	Y+17, r24	; 0x11
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    2f32:	8b 89       	ldd	r24, Y+19	; 0x13
    2f34:	9c 89       	ldd	r25, Y+20	; 0x14
    2f36:	01 97       	sbiw	r24, 0x01	; 1
    2f38:	9c 8b       	std	Y+20, r25	; 0x14
    2f3a:	8b 8b       	std	Y+19, r24	; 0x13
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    2f3c:	8b 89       	ldd	r24, Y+19	; 0x13
    2f3e:	9c 89       	ldd	r25, Y+20	; 0x14
    2f40:	00 97       	sbiw	r24, 0x00	; 0
    2f42:	69 f7       	brne	.-38     	; 0x2f1e <STEPPER_Bipolar_CW+0x1cc>
    2f44:	14 c0       	rjmp	.+40     	; 0x2f6e <STEPPER_Bipolar_CW+0x21c>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    2f46:	6d 89       	ldd	r22, Y+21	; 0x15
    2f48:	7e 89       	ldd	r23, Y+22	; 0x16
    2f4a:	8f 89       	ldd	r24, Y+23	; 0x17
    2f4c:	98 8d       	ldd	r25, Y+24	; 0x18
    2f4e:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    2f52:	dc 01       	movw	r26, r24
    2f54:	cb 01       	movw	r24, r22
    2f56:	9c 8b       	std	Y+20, r25	; 0x14
    2f58:	8b 8b       	std	Y+19, r24	; 0x13
    2f5a:	8b 89       	ldd	r24, Y+19	; 0x13
    2f5c:	9c 89       	ldd	r25, Y+20	; 0x14
    2f5e:	98 8b       	std	Y+16, r25	; 0x10
    2f60:	8f 87       	std	Y+15, r24	; 0x0f
    2f62:	8f 85       	ldd	r24, Y+15	; 0x0f
    2f64:	98 89       	ldd	r25, Y+16	; 0x10
    2f66:	01 97       	sbiw	r24, 0x01	; 1
    2f68:	f1 f7       	brne	.-4      	; 0x2f66 <STEPPER_Bipolar_CW+0x214>
    2f6a:	98 8b       	std	Y+16, r25	; 0x10
    2f6c:	8f 87       	std	Y+15, r24	; 0x0f
	_delay_ms( DELAY );
	DIO_WritePin(COIL1A,LOW);
    2f6e:	84 e1       	ldi	r24, 0x14	; 20
    2f70:	60 e0       	ldi	r22, 0x00	; 0
    2f72:	0e 94 f9 09 	call	0x13f2	; 0x13f2 <DIO_WritePin>
	DIO_WritePin(COIL1B,HIGH);
    2f76:	85 e1       	ldi	r24, 0x15	; 21
    2f78:	61 e0       	ldi	r22, 0x01	; 1
    2f7a:	0e 94 f9 09 	call	0x13f2	; 0x13f2 <DIO_WritePin>
	DIO_WritePin(COIL2A,LOW);
    2f7e:	86 e1       	ldi	r24, 0x16	; 22
    2f80:	60 e0       	ldi	r22, 0x00	; 0
    2f82:	0e 94 f9 09 	call	0x13f2	; 0x13f2 <DIO_WritePin>
	DIO_WritePin(COIL2B,LOW);
    2f86:	87 e1       	ldi	r24, 0x17	; 23
    2f88:	60 e0       	ldi	r22, 0x00	; 0
    2f8a:	0e 94 f9 09 	call	0x13f2	; 0x13f2 <DIO_WritePin>
    2f8e:	80 e0       	ldi	r24, 0x00	; 0
    2f90:	90 e0       	ldi	r25, 0x00	; 0
    2f92:	aa ef       	ldi	r26, 0xFA	; 250
    2f94:	b3 e4       	ldi	r27, 0x43	; 67
    2f96:	8b 87       	std	Y+11, r24	; 0x0b
    2f98:	9c 87       	std	Y+12, r25	; 0x0c
    2f9a:	ad 87       	std	Y+13, r26	; 0x0d
    2f9c:	be 87       	std	Y+14, r27	; 0x0e
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    2f9e:	6b 85       	ldd	r22, Y+11	; 0x0b
    2fa0:	7c 85       	ldd	r23, Y+12	; 0x0c
    2fa2:	8d 85       	ldd	r24, Y+13	; 0x0d
    2fa4:	9e 85       	ldd	r25, Y+14	; 0x0e
    2fa6:	20 e0       	ldi	r18, 0x00	; 0
    2fa8:	30 e0       	ldi	r19, 0x00	; 0
    2faa:	4a ef       	ldi	r20, 0xFA	; 250
    2fac:	54 e4       	ldi	r21, 0x44	; 68
    2fae:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    2fb2:	dc 01       	movw	r26, r24
    2fb4:	cb 01       	movw	r24, r22
    2fb6:	8f 83       	std	Y+7, r24	; 0x07
    2fb8:	98 87       	std	Y+8, r25	; 0x08
    2fba:	a9 87       	std	Y+9, r26	; 0x09
    2fbc:	ba 87       	std	Y+10, r27	; 0x0a
	if (__tmp < 1.0)
    2fbe:	6f 81       	ldd	r22, Y+7	; 0x07
    2fc0:	78 85       	ldd	r23, Y+8	; 0x08
    2fc2:	89 85       	ldd	r24, Y+9	; 0x09
    2fc4:	9a 85       	ldd	r25, Y+10	; 0x0a
    2fc6:	20 e0       	ldi	r18, 0x00	; 0
    2fc8:	30 e0       	ldi	r19, 0x00	; 0
    2fca:	40 e8       	ldi	r20, 0x80	; 128
    2fcc:	5f e3       	ldi	r21, 0x3F	; 63
    2fce:	0e 94 79 03 	call	0x6f2	; 0x6f2 <__ltsf2>
    2fd2:	88 23       	and	r24, r24
    2fd4:	2c f4       	brge	.+10     	; 0x2fe0 <STEPPER_Bipolar_CW+0x28e>
		__ticks = 1;
    2fd6:	81 e0       	ldi	r24, 0x01	; 1
    2fd8:	90 e0       	ldi	r25, 0x00	; 0
    2fda:	9e 83       	std	Y+6, r25	; 0x06
    2fdc:	8d 83       	std	Y+5, r24	; 0x05
    2fde:	3f c0       	rjmp	.+126    	; 0x305e <STEPPER_Bipolar_CW+0x30c>
	else if (__tmp > 65535)
    2fe0:	6f 81       	ldd	r22, Y+7	; 0x07
    2fe2:	78 85       	ldd	r23, Y+8	; 0x08
    2fe4:	89 85       	ldd	r24, Y+9	; 0x09
    2fe6:	9a 85       	ldd	r25, Y+10	; 0x0a
    2fe8:	20 e0       	ldi	r18, 0x00	; 0
    2fea:	3f ef       	ldi	r19, 0xFF	; 255
    2fec:	4f e7       	ldi	r20, 0x7F	; 127
    2fee:	57 e4       	ldi	r21, 0x47	; 71
    2ff0:	0e 94 19 03 	call	0x632	; 0x632 <__gtsf2>
    2ff4:	18 16       	cp	r1, r24
    2ff6:	4c f5       	brge	.+82     	; 0x304a <STEPPER_Bipolar_CW+0x2f8>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    2ff8:	6b 85       	ldd	r22, Y+11	; 0x0b
    2ffa:	7c 85       	ldd	r23, Y+12	; 0x0c
    2ffc:	8d 85       	ldd	r24, Y+13	; 0x0d
    2ffe:	9e 85       	ldd	r25, Y+14	; 0x0e
    3000:	20 e0       	ldi	r18, 0x00	; 0
    3002:	30 e0       	ldi	r19, 0x00	; 0
    3004:	40 e2       	ldi	r20, 0x20	; 32
    3006:	51 e4       	ldi	r21, 0x41	; 65
    3008:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    300c:	dc 01       	movw	r26, r24
    300e:	cb 01       	movw	r24, r22
    3010:	bc 01       	movw	r22, r24
    3012:	cd 01       	movw	r24, r26
    3014:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    3018:	dc 01       	movw	r26, r24
    301a:	cb 01       	movw	r24, r22
    301c:	9e 83       	std	Y+6, r25	; 0x06
    301e:	8d 83       	std	Y+5, r24	; 0x05
    3020:	0f c0       	rjmp	.+30     	; 0x3040 <STEPPER_Bipolar_CW+0x2ee>
    3022:	88 ec       	ldi	r24, 0xC8	; 200
    3024:	90 e0       	ldi	r25, 0x00	; 0
    3026:	9c 83       	std	Y+4, r25	; 0x04
    3028:	8b 83       	std	Y+3, r24	; 0x03
    302a:	8b 81       	ldd	r24, Y+3	; 0x03
    302c:	9c 81       	ldd	r25, Y+4	; 0x04
    302e:	01 97       	sbiw	r24, 0x01	; 1
    3030:	f1 f7       	brne	.-4      	; 0x302e <STEPPER_Bipolar_CW+0x2dc>
    3032:	9c 83       	std	Y+4, r25	; 0x04
    3034:	8b 83       	std	Y+3, r24	; 0x03
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    3036:	8d 81       	ldd	r24, Y+5	; 0x05
    3038:	9e 81       	ldd	r25, Y+6	; 0x06
    303a:	01 97       	sbiw	r24, 0x01	; 1
    303c:	9e 83       	std	Y+6, r25	; 0x06
    303e:	8d 83       	std	Y+5, r24	; 0x05
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    3040:	8d 81       	ldd	r24, Y+5	; 0x05
    3042:	9e 81       	ldd	r25, Y+6	; 0x06
    3044:	00 97       	sbiw	r24, 0x00	; 0
    3046:	69 f7       	brne	.-38     	; 0x3022 <STEPPER_Bipolar_CW+0x2d0>
    3048:	14 c0       	rjmp	.+40     	; 0x3072 <STEPPER_Bipolar_CW+0x320>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    304a:	6f 81       	ldd	r22, Y+7	; 0x07
    304c:	78 85       	ldd	r23, Y+8	; 0x08
    304e:	89 85       	ldd	r24, Y+9	; 0x09
    3050:	9a 85       	ldd	r25, Y+10	; 0x0a
    3052:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    3056:	dc 01       	movw	r26, r24
    3058:	cb 01       	movw	r24, r22
    305a:	9e 83       	std	Y+6, r25	; 0x06
    305c:	8d 83       	std	Y+5, r24	; 0x05
    305e:	8d 81       	ldd	r24, Y+5	; 0x05
    3060:	9e 81       	ldd	r25, Y+6	; 0x06
    3062:	9a 83       	std	Y+2, r25	; 0x02
    3064:	89 83       	std	Y+1, r24	; 0x01
    3066:	89 81       	ldd	r24, Y+1	; 0x01
    3068:	9a 81       	ldd	r25, Y+2	; 0x02
    306a:	01 97       	sbiw	r24, 0x01	; 1
    306c:	f1 f7       	brne	.-4      	; 0x306a <STEPPER_Bipolar_CW+0x318>
    306e:	9a 83       	std	Y+2, r25	; 0x02
    3070:	89 83       	std	Y+1, r24	; 0x01
	_delay_ms( DELAY );
	DIO_WritePin(COIL1A,LOW);
    3072:	84 e1       	ldi	r24, 0x14	; 20
    3074:	60 e0       	ldi	r22, 0x00	; 0
    3076:	0e 94 f9 09 	call	0x13f2	; 0x13f2 <DIO_WritePin>
	DIO_WritePin(COIL1B,LOW);
    307a:	85 e1       	ldi	r24, 0x15	; 21
    307c:	60 e0       	ldi	r22, 0x00	; 0
    307e:	0e 94 f9 09 	call	0x13f2	; 0x13f2 <DIO_WritePin>
	DIO_WritePin(COIL2A,LOW);
    3082:	86 e1       	ldi	r24, 0x16	; 22
    3084:	60 e0       	ldi	r22, 0x00	; 0
    3086:	0e 94 f9 09 	call	0x13f2	; 0x13f2 <DIO_WritePin>
	DIO_WritePin(COIL2B,HIGH);
    308a:	87 e1       	ldi	r24, 0x17	; 23
    308c:	61 e0       	ldi	r22, 0x01	; 1
    308e:	0e 94 f9 09 	call	0x13f2	; 0x13f2 <DIO_WritePin>
}
    3092:	aa 96       	adiw	r28, 0x2a	; 42
    3094:	0f b6       	in	r0, 0x3f	; 63
    3096:	f8 94       	cli
    3098:	de bf       	out	0x3e, r29	; 62
    309a:	0f be       	out	0x3f, r0	; 63
    309c:	cd bf       	out	0x3d, r28	; 61
    309e:	cf 91       	pop	r28
    30a0:	df 91       	pop	r29
    30a2:	08 95       	ret

000030a4 <STEPPER_Bipolar_CCW>:
void STEPPER_Bipolar_CCW(void)
{
    30a4:	df 93       	push	r29
    30a6:	cf 93       	push	r28
    30a8:	cd b7       	in	r28, 0x3d	; 61
    30aa:	de b7       	in	r29, 0x3e	; 62
    30ac:	e8 97       	sbiw	r28, 0x38	; 56
    30ae:	0f b6       	in	r0, 0x3f	; 63
    30b0:	f8 94       	cli
    30b2:	de bf       	out	0x3e, r29	; 62
    30b4:	0f be       	out	0x3f, r0	; 63
    30b6:	cd bf       	out	0x3d, r28	; 61
	DIO_WritePin(COIL1A,HIGH);
    30b8:	84 e1       	ldi	r24, 0x14	; 20
    30ba:	61 e0       	ldi	r22, 0x01	; 1
    30bc:	0e 94 f9 09 	call	0x13f2	; 0x13f2 <DIO_WritePin>
	DIO_WritePin(COIL1B,LOW);
    30c0:	85 e1       	ldi	r24, 0x15	; 21
    30c2:	60 e0       	ldi	r22, 0x00	; 0
    30c4:	0e 94 f9 09 	call	0x13f2	; 0x13f2 <DIO_WritePin>
	DIO_WritePin(COIL2A,LOW);
    30c8:	86 e1       	ldi	r24, 0x16	; 22
    30ca:	60 e0       	ldi	r22, 0x00	; 0
    30cc:	0e 94 f9 09 	call	0x13f2	; 0x13f2 <DIO_WritePin>
	DIO_WritePin(COIL2B,LOW);
    30d0:	87 e1       	ldi	r24, 0x17	; 23
    30d2:	60 e0       	ldi	r22, 0x00	; 0
    30d4:	0e 94 f9 09 	call	0x13f2	; 0x13f2 <DIO_WritePin>
    30d8:	80 e0       	ldi	r24, 0x00	; 0
    30da:	90 e0       	ldi	r25, 0x00	; 0
    30dc:	aa ef       	ldi	r26, 0xFA	; 250
    30de:	b3 e4       	ldi	r27, 0x43	; 67
    30e0:	8d ab       	std	Y+53, r24	; 0x35
    30e2:	9e ab       	std	Y+54, r25	; 0x36
    30e4:	af ab       	std	Y+55, r26	; 0x37
    30e6:	b8 af       	std	Y+56, r27	; 0x38
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    30e8:	6d a9       	ldd	r22, Y+53	; 0x35
    30ea:	7e a9       	ldd	r23, Y+54	; 0x36
    30ec:	8f a9       	ldd	r24, Y+55	; 0x37
    30ee:	98 ad       	ldd	r25, Y+56	; 0x38
    30f0:	20 e0       	ldi	r18, 0x00	; 0
    30f2:	30 e0       	ldi	r19, 0x00	; 0
    30f4:	4a ef       	ldi	r20, 0xFA	; 250
    30f6:	54 e4       	ldi	r21, 0x44	; 68
    30f8:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    30fc:	dc 01       	movw	r26, r24
    30fe:	cb 01       	movw	r24, r22
    3100:	89 ab       	std	Y+49, r24	; 0x31
    3102:	9a ab       	std	Y+50, r25	; 0x32
    3104:	ab ab       	std	Y+51, r26	; 0x33
    3106:	bc ab       	std	Y+52, r27	; 0x34
	if (__tmp < 1.0)
    3108:	69 a9       	ldd	r22, Y+49	; 0x31
    310a:	7a a9       	ldd	r23, Y+50	; 0x32
    310c:	8b a9       	ldd	r24, Y+51	; 0x33
    310e:	9c a9       	ldd	r25, Y+52	; 0x34
    3110:	20 e0       	ldi	r18, 0x00	; 0
    3112:	30 e0       	ldi	r19, 0x00	; 0
    3114:	40 e8       	ldi	r20, 0x80	; 128
    3116:	5f e3       	ldi	r21, 0x3F	; 63
    3118:	0e 94 79 03 	call	0x6f2	; 0x6f2 <__ltsf2>
    311c:	88 23       	and	r24, r24
    311e:	2c f4       	brge	.+10     	; 0x312a <STEPPER_Bipolar_CCW+0x86>
		__ticks = 1;
    3120:	81 e0       	ldi	r24, 0x01	; 1
    3122:	90 e0       	ldi	r25, 0x00	; 0
    3124:	98 ab       	std	Y+48, r25	; 0x30
    3126:	8f a7       	std	Y+47, r24	; 0x2f
    3128:	3f c0       	rjmp	.+126    	; 0x31a8 <STEPPER_Bipolar_CCW+0x104>
	else if (__tmp > 65535)
    312a:	69 a9       	ldd	r22, Y+49	; 0x31
    312c:	7a a9       	ldd	r23, Y+50	; 0x32
    312e:	8b a9       	ldd	r24, Y+51	; 0x33
    3130:	9c a9       	ldd	r25, Y+52	; 0x34
    3132:	20 e0       	ldi	r18, 0x00	; 0
    3134:	3f ef       	ldi	r19, 0xFF	; 255
    3136:	4f e7       	ldi	r20, 0x7F	; 127
    3138:	57 e4       	ldi	r21, 0x47	; 71
    313a:	0e 94 19 03 	call	0x632	; 0x632 <__gtsf2>
    313e:	18 16       	cp	r1, r24
    3140:	4c f5       	brge	.+82     	; 0x3194 <STEPPER_Bipolar_CCW+0xf0>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    3142:	6d a9       	ldd	r22, Y+53	; 0x35
    3144:	7e a9       	ldd	r23, Y+54	; 0x36
    3146:	8f a9       	ldd	r24, Y+55	; 0x37
    3148:	98 ad       	ldd	r25, Y+56	; 0x38
    314a:	20 e0       	ldi	r18, 0x00	; 0
    314c:	30 e0       	ldi	r19, 0x00	; 0
    314e:	40 e2       	ldi	r20, 0x20	; 32
    3150:	51 e4       	ldi	r21, 0x41	; 65
    3152:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    3156:	dc 01       	movw	r26, r24
    3158:	cb 01       	movw	r24, r22
    315a:	bc 01       	movw	r22, r24
    315c:	cd 01       	movw	r24, r26
    315e:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    3162:	dc 01       	movw	r26, r24
    3164:	cb 01       	movw	r24, r22
    3166:	98 ab       	std	Y+48, r25	; 0x30
    3168:	8f a7       	std	Y+47, r24	; 0x2f
    316a:	0f c0       	rjmp	.+30     	; 0x318a <STEPPER_Bipolar_CCW+0xe6>
    316c:	88 ec       	ldi	r24, 0xC8	; 200
    316e:	90 e0       	ldi	r25, 0x00	; 0
    3170:	9e a7       	std	Y+46, r25	; 0x2e
    3172:	8d a7       	std	Y+45, r24	; 0x2d
    3174:	8d a5       	ldd	r24, Y+45	; 0x2d
    3176:	9e a5       	ldd	r25, Y+46	; 0x2e
    3178:	01 97       	sbiw	r24, 0x01	; 1
    317a:	f1 f7       	brne	.-4      	; 0x3178 <STEPPER_Bipolar_CCW+0xd4>
    317c:	9e a7       	std	Y+46, r25	; 0x2e
    317e:	8d a7       	std	Y+45, r24	; 0x2d
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    3180:	8f a5       	ldd	r24, Y+47	; 0x2f
    3182:	98 a9       	ldd	r25, Y+48	; 0x30
    3184:	01 97       	sbiw	r24, 0x01	; 1
    3186:	98 ab       	std	Y+48, r25	; 0x30
    3188:	8f a7       	std	Y+47, r24	; 0x2f
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    318a:	8f a5       	ldd	r24, Y+47	; 0x2f
    318c:	98 a9       	ldd	r25, Y+48	; 0x30
    318e:	00 97       	sbiw	r24, 0x00	; 0
    3190:	69 f7       	brne	.-38     	; 0x316c <STEPPER_Bipolar_CCW+0xc8>
    3192:	14 c0       	rjmp	.+40     	; 0x31bc <STEPPER_Bipolar_CCW+0x118>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    3194:	69 a9       	ldd	r22, Y+49	; 0x31
    3196:	7a a9       	ldd	r23, Y+50	; 0x32
    3198:	8b a9       	ldd	r24, Y+51	; 0x33
    319a:	9c a9       	ldd	r25, Y+52	; 0x34
    319c:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    31a0:	dc 01       	movw	r26, r24
    31a2:	cb 01       	movw	r24, r22
    31a4:	98 ab       	std	Y+48, r25	; 0x30
    31a6:	8f a7       	std	Y+47, r24	; 0x2f
    31a8:	8f a5       	ldd	r24, Y+47	; 0x2f
    31aa:	98 a9       	ldd	r25, Y+48	; 0x30
    31ac:	9c a7       	std	Y+44, r25	; 0x2c
    31ae:	8b a7       	std	Y+43, r24	; 0x2b
    31b0:	8b a5       	ldd	r24, Y+43	; 0x2b
    31b2:	9c a5       	ldd	r25, Y+44	; 0x2c
    31b4:	01 97       	sbiw	r24, 0x01	; 1
    31b6:	f1 f7       	brne	.-4      	; 0x31b4 <STEPPER_Bipolar_CCW+0x110>
    31b8:	9c a7       	std	Y+44, r25	; 0x2c
    31ba:	8b a7       	std	Y+43, r24	; 0x2b
	_delay_ms( DELAY );
	DIO_WritePin(COIL1A,LOW);
    31bc:	84 e1       	ldi	r24, 0x14	; 20
    31be:	60 e0       	ldi	r22, 0x00	; 0
    31c0:	0e 94 f9 09 	call	0x13f2	; 0x13f2 <DIO_WritePin>
	DIO_WritePin(COIL1B,LOW);
    31c4:	85 e1       	ldi	r24, 0x15	; 21
    31c6:	60 e0       	ldi	r22, 0x00	; 0
    31c8:	0e 94 f9 09 	call	0x13f2	; 0x13f2 <DIO_WritePin>
	DIO_WritePin(COIL2A,LOW);
    31cc:	86 e1       	ldi	r24, 0x16	; 22
    31ce:	60 e0       	ldi	r22, 0x00	; 0
    31d0:	0e 94 f9 09 	call	0x13f2	; 0x13f2 <DIO_WritePin>
	DIO_WritePin(COIL2B,HIGH);
    31d4:	87 e1       	ldi	r24, 0x17	; 23
    31d6:	61 e0       	ldi	r22, 0x01	; 1
    31d8:	0e 94 f9 09 	call	0x13f2	; 0x13f2 <DIO_WritePin>
    31dc:	80 e0       	ldi	r24, 0x00	; 0
    31de:	90 e0       	ldi	r25, 0x00	; 0
    31e0:	aa ef       	ldi	r26, 0xFA	; 250
    31e2:	b3 e4       	ldi	r27, 0x43	; 67
    31e4:	8f a3       	std	Y+39, r24	; 0x27
    31e6:	98 a7       	std	Y+40, r25	; 0x28
    31e8:	a9 a7       	std	Y+41, r26	; 0x29
    31ea:	ba a7       	std	Y+42, r27	; 0x2a
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    31ec:	6f a1       	ldd	r22, Y+39	; 0x27
    31ee:	78 a5       	ldd	r23, Y+40	; 0x28
    31f0:	89 a5       	ldd	r24, Y+41	; 0x29
    31f2:	9a a5       	ldd	r25, Y+42	; 0x2a
    31f4:	20 e0       	ldi	r18, 0x00	; 0
    31f6:	30 e0       	ldi	r19, 0x00	; 0
    31f8:	4a ef       	ldi	r20, 0xFA	; 250
    31fa:	54 e4       	ldi	r21, 0x44	; 68
    31fc:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    3200:	dc 01       	movw	r26, r24
    3202:	cb 01       	movw	r24, r22
    3204:	8b a3       	std	Y+35, r24	; 0x23
    3206:	9c a3       	std	Y+36, r25	; 0x24
    3208:	ad a3       	std	Y+37, r26	; 0x25
    320a:	be a3       	std	Y+38, r27	; 0x26
	if (__tmp < 1.0)
    320c:	6b a1       	ldd	r22, Y+35	; 0x23
    320e:	7c a1       	ldd	r23, Y+36	; 0x24
    3210:	8d a1       	ldd	r24, Y+37	; 0x25
    3212:	9e a1       	ldd	r25, Y+38	; 0x26
    3214:	20 e0       	ldi	r18, 0x00	; 0
    3216:	30 e0       	ldi	r19, 0x00	; 0
    3218:	40 e8       	ldi	r20, 0x80	; 128
    321a:	5f e3       	ldi	r21, 0x3F	; 63
    321c:	0e 94 79 03 	call	0x6f2	; 0x6f2 <__ltsf2>
    3220:	88 23       	and	r24, r24
    3222:	2c f4       	brge	.+10     	; 0x322e <STEPPER_Bipolar_CCW+0x18a>
		__ticks = 1;
    3224:	81 e0       	ldi	r24, 0x01	; 1
    3226:	90 e0       	ldi	r25, 0x00	; 0
    3228:	9a a3       	std	Y+34, r25	; 0x22
    322a:	89 a3       	std	Y+33, r24	; 0x21
    322c:	3f c0       	rjmp	.+126    	; 0x32ac <STEPPER_Bipolar_CCW+0x208>
	else if (__tmp > 65535)
    322e:	6b a1       	ldd	r22, Y+35	; 0x23
    3230:	7c a1       	ldd	r23, Y+36	; 0x24
    3232:	8d a1       	ldd	r24, Y+37	; 0x25
    3234:	9e a1       	ldd	r25, Y+38	; 0x26
    3236:	20 e0       	ldi	r18, 0x00	; 0
    3238:	3f ef       	ldi	r19, 0xFF	; 255
    323a:	4f e7       	ldi	r20, 0x7F	; 127
    323c:	57 e4       	ldi	r21, 0x47	; 71
    323e:	0e 94 19 03 	call	0x632	; 0x632 <__gtsf2>
    3242:	18 16       	cp	r1, r24
    3244:	4c f5       	brge	.+82     	; 0x3298 <STEPPER_Bipolar_CCW+0x1f4>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    3246:	6f a1       	ldd	r22, Y+39	; 0x27
    3248:	78 a5       	ldd	r23, Y+40	; 0x28
    324a:	89 a5       	ldd	r24, Y+41	; 0x29
    324c:	9a a5       	ldd	r25, Y+42	; 0x2a
    324e:	20 e0       	ldi	r18, 0x00	; 0
    3250:	30 e0       	ldi	r19, 0x00	; 0
    3252:	40 e2       	ldi	r20, 0x20	; 32
    3254:	51 e4       	ldi	r21, 0x41	; 65
    3256:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    325a:	dc 01       	movw	r26, r24
    325c:	cb 01       	movw	r24, r22
    325e:	bc 01       	movw	r22, r24
    3260:	cd 01       	movw	r24, r26
    3262:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    3266:	dc 01       	movw	r26, r24
    3268:	cb 01       	movw	r24, r22
    326a:	9a a3       	std	Y+34, r25	; 0x22
    326c:	89 a3       	std	Y+33, r24	; 0x21
    326e:	0f c0       	rjmp	.+30     	; 0x328e <STEPPER_Bipolar_CCW+0x1ea>
    3270:	88 ec       	ldi	r24, 0xC8	; 200
    3272:	90 e0       	ldi	r25, 0x00	; 0
    3274:	98 a3       	std	Y+32, r25	; 0x20
    3276:	8f 8f       	std	Y+31, r24	; 0x1f
    3278:	8f 8d       	ldd	r24, Y+31	; 0x1f
    327a:	98 a1       	ldd	r25, Y+32	; 0x20
    327c:	01 97       	sbiw	r24, 0x01	; 1
    327e:	f1 f7       	brne	.-4      	; 0x327c <STEPPER_Bipolar_CCW+0x1d8>
    3280:	98 a3       	std	Y+32, r25	; 0x20
    3282:	8f 8f       	std	Y+31, r24	; 0x1f
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    3284:	89 a1       	ldd	r24, Y+33	; 0x21
    3286:	9a a1       	ldd	r25, Y+34	; 0x22
    3288:	01 97       	sbiw	r24, 0x01	; 1
    328a:	9a a3       	std	Y+34, r25	; 0x22
    328c:	89 a3       	std	Y+33, r24	; 0x21
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    328e:	89 a1       	ldd	r24, Y+33	; 0x21
    3290:	9a a1       	ldd	r25, Y+34	; 0x22
    3292:	00 97       	sbiw	r24, 0x00	; 0
    3294:	69 f7       	brne	.-38     	; 0x3270 <STEPPER_Bipolar_CCW+0x1cc>
    3296:	14 c0       	rjmp	.+40     	; 0x32c0 <STEPPER_Bipolar_CCW+0x21c>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    3298:	6b a1       	ldd	r22, Y+35	; 0x23
    329a:	7c a1       	ldd	r23, Y+36	; 0x24
    329c:	8d a1       	ldd	r24, Y+37	; 0x25
    329e:	9e a1       	ldd	r25, Y+38	; 0x26
    32a0:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    32a4:	dc 01       	movw	r26, r24
    32a6:	cb 01       	movw	r24, r22
    32a8:	9a a3       	std	Y+34, r25	; 0x22
    32aa:	89 a3       	std	Y+33, r24	; 0x21
    32ac:	89 a1       	ldd	r24, Y+33	; 0x21
    32ae:	9a a1       	ldd	r25, Y+34	; 0x22
    32b0:	9e 8f       	std	Y+30, r25	; 0x1e
    32b2:	8d 8f       	std	Y+29, r24	; 0x1d
    32b4:	8d 8d       	ldd	r24, Y+29	; 0x1d
    32b6:	9e 8d       	ldd	r25, Y+30	; 0x1e
    32b8:	01 97       	sbiw	r24, 0x01	; 1
    32ba:	f1 f7       	brne	.-4      	; 0x32b8 <STEPPER_Bipolar_CCW+0x214>
    32bc:	9e 8f       	std	Y+30, r25	; 0x1e
    32be:	8d 8f       	std	Y+29, r24	; 0x1d
	_delay_ms( DELAY );
	DIO_WritePin(COIL1A,LOW);
    32c0:	84 e1       	ldi	r24, 0x14	; 20
    32c2:	60 e0       	ldi	r22, 0x00	; 0
    32c4:	0e 94 f9 09 	call	0x13f2	; 0x13f2 <DIO_WritePin>
	DIO_WritePin(COIL1B,HIGH);
    32c8:	85 e1       	ldi	r24, 0x15	; 21
    32ca:	61 e0       	ldi	r22, 0x01	; 1
    32cc:	0e 94 f9 09 	call	0x13f2	; 0x13f2 <DIO_WritePin>
	DIO_WritePin(COIL2A,LOW);
    32d0:	86 e1       	ldi	r24, 0x16	; 22
    32d2:	60 e0       	ldi	r22, 0x00	; 0
    32d4:	0e 94 f9 09 	call	0x13f2	; 0x13f2 <DIO_WritePin>
	DIO_WritePin(COIL2B,LOW);
    32d8:	87 e1       	ldi	r24, 0x17	; 23
    32da:	60 e0       	ldi	r22, 0x00	; 0
    32dc:	0e 94 f9 09 	call	0x13f2	; 0x13f2 <DIO_WritePin>
    32e0:	80 e0       	ldi	r24, 0x00	; 0
    32e2:	90 e0       	ldi	r25, 0x00	; 0
    32e4:	aa ef       	ldi	r26, 0xFA	; 250
    32e6:	b3 e4       	ldi	r27, 0x43	; 67
    32e8:	89 8f       	std	Y+25, r24	; 0x19
    32ea:	9a 8f       	std	Y+26, r25	; 0x1a
    32ec:	ab 8f       	std	Y+27, r26	; 0x1b
    32ee:	bc 8f       	std	Y+28, r27	; 0x1c
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    32f0:	69 8d       	ldd	r22, Y+25	; 0x19
    32f2:	7a 8d       	ldd	r23, Y+26	; 0x1a
    32f4:	8b 8d       	ldd	r24, Y+27	; 0x1b
    32f6:	9c 8d       	ldd	r25, Y+28	; 0x1c
    32f8:	20 e0       	ldi	r18, 0x00	; 0
    32fa:	30 e0       	ldi	r19, 0x00	; 0
    32fc:	4a ef       	ldi	r20, 0xFA	; 250
    32fe:	54 e4       	ldi	r21, 0x44	; 68
    3300:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    3304:	dc 01       	movw	r26, r24
    3306:	cb 01       	movw	r24, r22
    3308:	8d 8b       	std	Y+21, r24	; 0x15
    330a:	9e 8b       	std	Y+22, r25	; 0x16
    330c:	af 8b       	std	Y+23, r26	; 0x17
    330e:	b8 8f       	std	Y+24, r27	; 0x18
	if (__tmp < 1.0)
    3310:	6d 89       	ldd	r22, Y+21	; 0x15
    3312:	7e 89       	ldd	r23, Y+22	; 0x16
    3314:	8f 89       	ldd	r24, Y+23	; 0x17
    3316:	98 8d       	ldd	r25, Y+24	; 0x18
    3318:	20 e0       	ldi	r18, 0x00	; 0
    331a:	30 e0       	ldi	r19, 0x00	; 0
    331c:	40 e8       	ldi	r20, 0x80	; 128
    331e:	5f e3       	ldi	r21, 0x3F	; 63
    3320:	0e 94 79 03 	call	0x6f2	; 0x6f2 <__ltsf2>
    3324:	88 23       	and	r24, r24
    3326:	2c f4       	brge	.+10     	; 0x3332 <STEPPER_Bipolar_CCW+0x28e>
		__ticks = 1;
    3328:	81 e0       	ldi	r24, 0x01	; 1
    332a:	90 e0       	ldi	r25, 0x00	; 0
    332c:	9c 8b       	std	Y+20, r25	; 0x14
    332e:	8b 8b       	std	Y+19, r24	; 0x13
    3330:	3f c0       	rjmp	.+126    	; 0x33b0 <STEPPER_Bipolar_CCW+0x30c>
	else if (__tmp > 65535)
    3332:	6d 89       	ldd	r22, Y+21	; 0x15
    3334:	7e 89       	ldd	r23, Y+22	; 0x16
    3336:	8f 89       	ldd	r24, Y+23	; 0x17
    3338:	98 8d       	ldd	r25, Y+24	; 0x18
    333a:	20 e0       	ldi	r18, 0x00	; 0
    333c:	3f ef       	ldi	r19, 0xFF	; 255
    333e:	4f e7       	ldi	r20, 0x7F	; 127
    3340:	57 e4       	ldi	r21, 0x47	; 71
    3342:	0e 94 19 03 	call	0x632	; 0x632 <__gtsf2>
    3346:	18 16       	cp	r1, r24
    3348:	4c f5       	brge	.+82     	; 0x339c <STEPPER_Bipolar_CCW+0x2f8>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    334a:	69 8d       	ldd	r22, Y+25	; 0x19
    334c:	7a 8d       	ldd	r23, Y+26	; 0x1a
    334e:	8b 8d       	ldd	r24, Y+27	; 0x1b
    3350:	9c 8d       	ldd	r25, Y+28	; 0x1c
    3352:	20 e0       	ldi	r18, 0x00	; 0
    3354:	30 e0       	ldi	r19, 0x00	; 0
    3356:	40 e2       	ldi	r20, 0x20	; 32
    3358:	51 e4       	ldi	r21, 0x41	; 65
    335a:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    335e:	dc 01       	movw	r26, r24
    3360:	cb 01       	movw	r24, r22
    3362:	bc 01       	movw	r22, r24
    3364:	cd 01       	movw	r24, r26
    3366:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    336a:	dc 01       	movw	r26, r24
    336c:	cb 01       	movw	r24, r22
    336e:	9c 8b       	std	Y+20, r25	; 0x14
    3370:	8b 8b       	std	Y+19, r24	; 0x13
    3372:	0f c0       	rjmp	.+30     	; 0x3392 <STEPPER_Bipolar_CCW+0x2ee>
    3374:	88 ec       	ldi	r24, 0xC8	; 200
    3376:	90 e0       	ldi	r25, 0x00	; 0
    3378:	9a 8b       	std	Y+18, r25	; 0x12
    337a:	89 8b       	std	Y+17, r24	; 0x11
    337c:	89 89       	ldd	r24, Y+17	; 0x11
    337e:	9a 89       	ldd	r25, Y+18	; 0x12
    3380:	01 97       	sbiw	r24, 0x01	; 1
    3382:	f1 f7       	brne	.-4      	; 0x3380 <STEPPER_Bipolar_CCW+0x2dc>
    3384:	9a 8b       	std	Y+18, r25	; 0x12
    3386:	89 8b       	std	Y+17, r24	; 0x11
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    3388:	8b 89       	ldd	r24, Y+19	; 0x13
    338a:	9c 89       	ldd	r25, Y+20	; 0x14
    338c:	01 97       	sbiw	r24, 0x01	; 1
    338e:	9c 8b       	std	Y+20, r25	; 0x14
    3390:	8b 8b       	std	Y+19, r24	; 0x13
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    3392:	8b 89       	ldd	r24, Y+19	; 0x13
    3394:	9c 89       	ldd	r25, Y+20	; 0x14
    3396:	00 97       	sbiw	r24, 0x00	; 0
    3398:	69 f7       	brne	.-38     	; 0x3374 <STEPPER_Bipolar_CCW+0x2d0>
    339a:	14 c0       	rjmp	.+40     	; 0x33c4 <STEPPER_Bipolar_CCW+0x320>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    339c:	6d 89       	ldd	r22, Y+21	; 0x15
    339e:	7e 89       	ldd	r23, Y+22	; 0x16
    33a0:	8f 89       	ldd	r24, Y+23	; 0x17
    33a2:	98 8d       	ldd	r25, Y+24	; 0x18
    33a4:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    33a8:	dc 01       	movw	r26, r24
    33aa:	cb 01       	movw	r24, r22
    33ac:	9c 8b       	std	Y+20, r25	; 0x14
    33ae:	8b 8b       	std	Y+19, r24	; 0x13
    33b0:	8b 89       	ldd	r24, Y+19	; 0x13
    33b2:	9c 89       	ldd	r25, Y+20	; 0x14
    33b4:	98 8b       	std	Y+16, r25	; 0x10
    33b6:	8f 87       	std	Y+15, r24	; 0x0f
    33b8:	8f 85       	ldd	r24, Y+15	; 0x0f
    33ba:	98 89       	ldd	r25, Y+16	; 0x10
    33bc:	01 97       	sbiw	r24, 0x01	; 1
    33be:	f1 f7       	brne	.-4      	; 0x33bc <STEPPER_Bipolar_CCW+0x318>
    33c0:	98 8b       	std	Y+16, r25	; 0x10
    33c2:	8f 87       	std	Y+15, r24	; 0x0f
	_delay_ms( DELAY );
	DIO_WritePin(COIL1A,LOW);
    33c4:	84 e1       	ldi	r24, 0x14	; 20
    33c6:	60 e0       	ldi	r22, 0x00	; 0
    33c8:	0e 94 f9 09 	call	0x13f2	; 0x13f2 <DIO_WritePin>
	DIO_WritePin(COIL1B,LOW);
    33cc:	85 e1       	ldi	r24, 0x15	; 21
    33ce:	60 e0       	ldi	r22, 0x00	; 0
    33d0:	0e 94 f9 09 	call	0x13f2	; 0x13f2 <DIO_WritePin>
	DIO_WritePin(COIL2A,HIGH);
    33d4:	86 e1       	ldi	r24, 0x16	; 22
    33d6:	61 e0       	ldi	r22, 0x01	; 1
    33d8:	0e 94 f9 09 	call	0x13f2	; 0x13f2 <DIO_WritePin>
	DIO_WritePin(COIL2B,LOW);
    33dc:	87 e1       	ldi	r24, 0x17	; 23
    33de:	60 e0       	ldi	r22, 0x00	; 0
    33e0:	0e 94 f9 09 	call	0x13f2	; 0x13f2 <DIO_WritePin>
    33e4:	80 e0       	ldi	r24, 0x00	; 0
    33e6:	90 e0       	ldi	r25, 0x00	; 0
    33e8:	aa ef       	ldi	r26, 0xFA	; 250
    33ea:	b3 e4       	ldi	r27, 0x43	; 67
    33ec:	8b 87       	std	Y+11, r24	; 0x0b
    33ee:	9c 87       	std	Y+12, r25	; 0x0c
    33f0:	ad 87       	std	Y+13, r26	; 0x0d
    33f2:	be 87       	std	Y+14, r27	; 0x0e
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    33f4:	6b 85       	ldd	r22, Y+11	; 0x0b
    33f6:	7c 85       	ldd	r23, Y+12	; 0x0c
    33f8:	8d 85       	ldd	r24, Y+13	; 0x0d
    33fa:	9e 85       	ldd	r25, Y+14	; 0x0e
    33fc:	20 e0       	ldi	r18, 0x00	; 0
    33fe:	30 e0       	ldi	r19, 0x00	; 0
    3400:	4a ef       	ldi	r20, 0xFA	; 250
    3402:	54 e4       	ldi	r21, 0x44	; 68
    3404:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    3408:	dc 01       	movw	r26, r24
    340a:	cb 01       	movw	r24, r22
    340c:	8f 83       	std	Y+7, r24	; 0x07
    340e:	98 87       	std	Y+8, r25	; 0x08
    3410:	a9 87       	std	Y+9, r26	; 0x09
    3412:	ba 87       	std	Y+10, r27	; 0x0a
	if (__tmp < 1.0)
    3414:	6f 81       	ldd	r22, Y+7	; 0x07
    3416:	78 85       	ldd	r23, Y+8	; 0x08
    3418:	89 85       	ldd	r24, Y+9	; 0x09
    341a:	9a 85       	ldd	r25, Y+10	; 0x0a
    341c:	20 e0       	ldi	r18, 0x00	; 0
    341e:	30 e0       	ldi	r19, 0x00	; 0
    3420:	40 e8       	ldi	r20, 0x80	; 128
    3422:	5f e3       	ldi	r21, 0x3F	; 63
    3424:	0e 94 79 03 	call	0x6f2	; 0x6f2 <__ltsf2>
    3428:	88 23       	and	r24, r24
    342a:	2c f4       	brge	.+10     	; 0x3436 <STEPPER_Bipolar_CCW+0x392>
		__ticks = 1;
    342c:	81 e0       	ldi	r24, 0x01	; 1
    342e:	90 e0       	ldi	r25, 0x00	; 0
    3430:	9e 83       	std	Y+6, r25	; 0x06
    3432:	8d 83       	std	Y+5, r24	; 0x05
    3434:	3f c0       	rjmp	.+126    	; 0x34b4 <STEPPER_Bipolar_CCW+0x410>
	else if (__tmp > 65535)
    3436:	6f 81       	ldd	r22, Y+7	; 0x07
    3438:	78 85       	ldd	r23, Y+8	; 0x08
    343a:	89 85       	ldd	r24, Y+9	; 0x09
    343c:	9a 85       	ldd	r25, Y+10	; 0x0a
    343e:	20 e0       	ldi	r18, 0x00	; 0
    3440:	3f ef       	ldi	r19, 0xFF	; 255
    3442:	4f e7       	ldi	r20, 0x7F	; 127
    3444:	57 e4       	ldi	r21, 0x47	; 71
    3446:	0e 94 19 03 	call	0x632	; 0x632 <__gtsf2>
    344a:	18 16       	cp	r1, r24
    344c:	4c f5       	brge	.+82     	; 0x34a0 <STEPPER_Bipolar_CCW+0x3fc>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    344e:	6b 85       	ldd	r22, Y+11	; 0x0b
    3450:	7c 85       	ldd	r23, Y+12	; 0x0c
    3452:	8d 85       	ldd	r24, Y+13	; 0x0d
    3454:	9e 85       	ldd	r25, Y+14	; 0x0e
    3456:	20 e0       	ldi	r18, 0x00	; 0
    3458:	30 e0       	ldi	r19, 0x00	; 0
    345a:	40 e2       	ldi	r20, 0x20	; 32
    345c:	51 e4       	ldi	r21, 0x41	; 65
    345e:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    3462:	dc 01       	movw	r26, r24
    3464:	cb 01       	movw	r24, r22
    3466:	bc 01       	movw	r22, r24
    3468:	cd 01       	movw	r24, r26
    346a:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    346e:	dc 01       	movw	r26, r24
    3470:	cb 01       	movw	r24, r22
    3472:	9e 83       	std	Y+6, r25	; 0x06
    3474:	8d 83       	std	Y+5, r24	; 0x05
    3476:	0f c0       	rjmp	.+30     	; 0x3496 <STEPPER_Bipolar_CCW+0x3f2>
    3478:	88 ec       	ldi	r24, 0xC8	; 200
    347a:	90 e0       	ldi	r25, 0x00	; 0
    347c:	9c 83       	std	Y+4, r25	; 0x04
    347e:	8b 83       	std	Y+3, r24	; 0x03
    3480:	8b 81       	ldd	r24, Y+3	; 0x03
    3482:	9c 81       	ldd	r25, Y+4	; 0x04
    3484:	01 97       	sbiw	r24, 0x01	; 1
    3486:	f1 f7       	brne	.-4      	; 0x3484 <STEPPER_Bipolar_CCW+0x3e0>
    3488:	9c 83       	std	Y+4, r25	; 0x04
    348a:	8b 83       	std	Y+3, r24	; 0x03
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    348c:	8d 81       	ldd	r24, Y+5	; 0x05
    348e:	9e 81       	ldd	r25, Y+6	; 0x06
    3490:	01 97       	sbiw	r24, 0x01	; 1
    3492:	9e 83       	std	Y+6, r25	; 0x06
    3494:	8d 83       	std	Y+5, r24	; 0x05
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    3496:	8d 81       	ldd	r24, Y+5	; 0x05
    3498:	9e 81       	ldd	r25, Y+6	; 0x06
    349a:	00 97       	sbiw	r24, 0x00	; 0
    349c:	69 f7       	brne	.-38     	; 0x3478 <STEPPER_Bipolar_CCW+0x3d4>
    349e:	14 c0       	rjmp	.+40     	; 0x34c8 <STEPPER_Bipolar_CCW+0x424>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    34a0:	6f 81       	ldd	r22, Y+7	; 0x07
    34a2:	78 85       	ldd	r23, Y+8	; 0x08
    34a4:	89 85       	ldd	r24, Y+9	; 0x09
    34a6:	9a 85       	ldd	r25, Y+10	; 0x0a
    34a8:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    34ac:	dc 01       	movw	r26, r24
    34ae:	cb 01       	movw	r24, r22
    34b0:	9e 83       	std	Y+6, r25	; 0x06
    34b2:	8d 83       	std	Y+5, r24	; 0x05
    34b4:	8d 81       	ldd	r24, Y+5	; 0x05
    34b6:	9e 81       	ldd	r25, Y+6	; 0x06
    34b8:	9a 83       	std	Y+2, r25	; 0x02
    34ba:	89 83       	std	Y+1, r24	; 0x01
    34bc:	89 81       	ldd	r24, Y+1	; 0x01
    34be:	9a 81       	ldd	r25, Y+2	; 0x02
    34c0:	01 97       	sbiw	r24, 0x01	; 1
    34c2:	f1 f7       	brne	.-4      	; 0x34c0 <STEPPER_Bipolar_CCW+0x41c>
    34c4:	9a 83       	std	Y+2, r25	; 0x02
    34c6:	89 83       	std	Y+1, r24	; 0x01
	_delay_ms( DELAY );


}
    34c8:	e8 96       	adiw	r28, 0x38	; 56
    34ca:	0f b6       	in	r0, 0x3f	; 63
    34cc:	f8 94       	cli
    34ce:	de bf       	out	0x3e, r29	; 62
    34d0:	0f be       	out	0x3f, r0	; 63
    34d2:	cd bf       	out	0x3d, r28	; 61
    34d4:	cf 91       	pop	r28
    34d6:	df 91       	pop	r29
    34d8:	08 95       	ret

000034da <STEPPER_Unipolar_CW>:

void STEPPER_Unipolar_CW(void)
{
    34da:	df 93       	push	r29
    34dc:	cf 93       	push	r28
    34de:	cd b7       	in	r28, 0x3d	; 61
    34e0:	de b7       	in	r29, 0x3e	; 62
    34e2:	e8 97       	sbiw	r28, 0x38	; 56
    34e4:	0f b6       	in	r0, 0x3f	; 63
    34e6:	f8 94       	cli
    34e8:	de bf       	out	0x3e, r29	; 62
    34ea:	0f be       	out	0x3f, r0	; 63
    34ec:	cd bf       	out	0x3d, r28	; 61
	DIO_WritePin(COIL1A,HIGH);
    34ee:	84 e1       	ldi	r24, 0x14	; 20
    34f0:	61 e0       	ldi	r22, 0x01	; 1
    34f2:	0e 94 f9 09 	call	0x13f2	; 0x13f2 <DIO_WritePin>
	DIO_WritePin(COIL1B,LOW);
    34f6:	85 e1       	ldi	r24, 0x15	; 21
    34f8:	60 e0       	ldi	r22, 0x00	; 0
    34fa:	0e 94 f9 09 	call	0x13f2	; 0x13f2 <DIO_WritePin>
	DIO_WritePin(COIL2A,LOW);
    34fe:	86 e1       	ldi	r24, 0x16	; 22
    3500:	60 e0       	ldi	r22, 0x00	; 0
    3502:	0e 94 f9 09 	call	0x13f2	; 0x13f2 <DIO_WritePin>
	DIO_WritePin(COIL2B,LOW);
    3506:	87 e1       	ldi	r24, 0x17	; 23
    3508:	60 e0       	ldi	r22, 0x00	; 0
    350a:	0e 94 f9 09 	call	0x13f2	; 0x13f2 <DIO_WritePin>
    350e:	80 e0       	ldi	r24, 0x00	; 0
    3510:	90 e0       	ldi	r25, 0x00	; 0
    3512:	aa ef       	ldi	r26, 0xFA	; 250
    3514:	b3 e4       	ldi	r27, 0x43	; 67
    3516:	8d ab       	std	Y+53, r24	; 0x35
    3518:	9e ab       	std	Y+54, r25	; 0x36
    351a:	af ab       	std	Y+55, r26	; 0x37
    351c:	b8 af       	std	Y+56, r27	; 0x38
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    351e:	6d a9       	ldd	r22, Y+53	; 0x35
    3520:	7e a9       	ldd	r23, Y+54	; 0x36
    3522:	8f a9       	ldd	r24, Y+55	; 0x37
    3524:	98 ad       	ldd	r25, Y+56	; 0x38
    3526:	20 e0       	ldi	r18, 0x00	; 0
    3528:	30 e0       	ldi	r19, 0x00	; 0
    352a:	4a ef       	ldi	r20, 0xFA	; 250
    352c:	54 e4       	ldi	r21, 0x44	; 68
    352e:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    3532:	dc 01       	movw	r26, r24
    3534:	cb 01       	movw	r24, r22
    3536:	89 ab       	std	Y+49, r24	; 0x31
    3538:	9a ab       	std	Y+50, r25	; 0x32
    353a:	ab ab       	std	Y+51, r26	; 0x33
    353c:	bc ab       	std	Y+52, r27	; 0x34
	if (__tmp < 1.0)
    353e:	69 a9       	ldd	r22, Y+49	; 0x31
    3540:	7a a9       	ldd	r23, Y+50	; 0x32
    3542:	8b a9       	ldd	r24, Y+51	; 0x33
    3544:	9c a9       	ldd	r25, Y+52	; 0x34
    3546:	20 e0       	ldi	r18, 0x00	; 0
    3548:	30 e0       	ldi	r19, 0x00	; 0
    354a:	40 e8       	ldi	r20, 0x80	; 128
    354c:	5f e3       	ldi	r21, 0x3F	; 63
    354e:	0e 94 79 03 	call	0x6f2	; 0x6f2 <__ltsf2>
    3552:	88 23       	and	r24, r24
    3554:	2c f4       	brge	.+10     	; 0x3560 <STEPPER_Unipolar_CW+0x86>
		__ticks = 1;
    3556:	81 e0       	ldi	r24, 0x01	; 1
    3558:	90 e0       	ldi	r25, 0x00	; 0
    355a:	98 ab       	std	Y+48, r25	; 0x30
    355c:	8f a7       	std	Y+47, r24	; 0x2f
    355e:	3f c0       	rjmp	.+126    	; 0x35de <STEPPER_Unipolar_CW+0x104>
	else if (__tmp > 65535)
    3560:	69 a9       	ldd	r22, Y+49	; 0x31
    3562:	7a a9       	ldd	r23, Y+50	; 0x32
    3564:	8b a9       	ldd	r24, Y+51	; 0x33
    3566:	9c a9       	ldd	r25, Y+52	; 0x34
    3568:	20 e0       	ldi	r18, 0x00	; 0
    356a:	3f ef       	ldi	r19, 0xFF	; 255
    356c:	4f e7       	ldi	r20, 0x7F	; 127
    356e:	57 e4       	ldi	r21, 0x47	; 71
    3570:	0e 94 19 03 	call	0x632	; 0x632 <__gtsf2>
    3574:	18 16       	cp	r1, r24
    3576:	4c f5       	brge	.+82     	; 0x35ca <STEPPER_Unipolar_CW+0xf0>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    3578:	6d a9       	ldd	r22, Y+53	; 0x35
    357a:	7e a9       	ldd	r23, Y+54	; 0x36
    357c:	8f a9       	ldd	r24, Y+55	; 0x37
    357e:	98 ad       	ldd	r25, Y+56	; 0x38
    3580:	20 e0       	ldi	r18, 0x00	; 0
    3582:	30 e0       	ldi	r19, 0x00	; 0
    3584:	40 e2       	ldi	r20, 0x20	; 32
    3586:	51 e4       	ldi	r21, 0x41	; 65
    3588:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    358c:	dc 01       	movw	r26, r24
    358e:	cb 01       	movw	r24, r22
    3590:	bc 01       	movw	r22, r24
    3592:	cd 01       	movw	r24, r26
    3594:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    3598:	dc 01       	movw	r26, r24
    359a:	cb 01       	movw	r24, r22
    359c:	98 ab       	std	Y+48, r25	; 0x30
    359e:	8f a7       	std	Y+47, r24	; 0x2f
    35a0:	0f c0       	rjmp	.+30     	; 0x35c0 <STEPPER_Unipolar_CW+0xe6>
    35a2:	88 ec       	ldi	r24, 0xC8	; 200
    35a4:	90 e0       	ldi	r25, 0x00	; 0
    35a6:	9e a7       	std	Y+46, r25	; 0x2e
    35a8:	8d a7       	std	Y+45, r24	; 0x2d
    35aa:	8d a5       	ldd	r24, Y+45	; 0x2d
    35ac:	9e a5       	ldd	r25, Y+46	; 0x2e
    35ae:	01 97       	sbiw	r24, 0x01	; 1
    35b0:	f1 f7       	brne	.-4      	; 0x35ae <STEPPER_Unipolar_CW+0xd4>
    35b2:	9e a7       	std	Y+46, r25	; 0x2e
    35b4:	8d a7       	std	Y+45, r24	; 0x2d
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    35b6:	8f a5       	ldd	r24, Y+47	; 0x2f
    35b8:	98 a9       	ldd	r25, Y+48	; 0x30
    35ba:	01 97       	sbiw	r24, 0x01	; 1
    35bc:	98 ab       	std	Y+48, r25	; 0x30
    35be:	8f a7       	std	Y+47, r24	; 0x2f
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    35c0:	8f a5       	ldd	r24, Y+47	; 0x2f
    35c2:	98 a9       	ldd	r25, Y+48	; 0x30
    35c4:	00 97       	sbiw	r24, 0x00	; 0
    35c6:	69 f7       	brne	.-38     	; 0x35a2 <STEPPER_Unipolar_CW+0xc8>
    35c8:	14 c0       	rjmp	.+40     	; 0x35f2 <STEPPER_Unipolar_CW+0x118>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    35ca:	69 a9       	ldd	r22, Y+49	; 0x31
    35cc:	7a a9       	ldd	r23, Y+50	; 0x32
    35ce:	8b a9       	ldd	r24, Y+51	; 0x33
    35d0:	9c a9       	ldd	r25, Y+52	; 0x34
    35d2:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    35d6:	dc 01       	movw	r26, r24
    35d8:	cb 01       	movw	r24, r22
    35da:	98 ab       	std	Y+48, r25	; 0x30
    35dc:	8f a7       	std	Y+47, r24	; 0x2f
    35de:	8f a5       	ldd	r24, Y+47	; 0x2f
    35e0:	98 a9       	ldd	r25, Y+48	; 0x30
    35e2:	9c a7       	std	Y+44, r25	; 0x2c
    35e4:	8b a7       	std	Y+43, r24	; 0x2b
    35e6:	8b a5       	ldd	r24, Y+43	; 0x2b
    35e8:	9c a5       	ldd	r25, Y+44	; 0x2c
    35ea:	01 97       	sbiw	r24, 0x01	; 1
    35ec:	f1 f7       	brne	.-4      	; 0x35ea <STEPPER_Unipolar_CW+0x110>
    35ee:	9c a7       	std	Y+44, r25	; 0x2c
    35f0:	8b a7       	std	Y+43, r24	; 0x2b
	_delay_ms( DELAY );
	DIO_WritePin(COIL1A,LOW);
    35f2:	84 e1       	ldi	r24, 0x14	; 20
    35f4:	60 e0       	ldi	r22, 0x00	; 0
    35f6:	0e 94 f9 09 	call	0x13f2	; 0x13f2 <DIO_WritePin>
	DIO_WritePin(COIL1B,HIGH);
    35fa:	85 e1       	ldi	r24, 0x15	; 21
    35fc:	61 e0       	ldi	r22, 0x01	; 1
    35fe:	0e 94 f9 09 	call	0x13f2	; 0x13f2 <DIO_WritePin>
	DIO_WritePin(COIL2A,LOW);
    3602:	86 e1       	ldi	r24, 0x16	; 22
    3604:	60 e0       	ldi	r22, 0x00	; 0
    3606:	0e 94 f9 09 	call	0x13f2	; 0x13f2 <DIO_WritePin>
	DIO_WritePin(COIL2B,LOW);
    360a:	87 e1       	ldi	r24, 0x17	; 23
    360c:	60 e0       	ldi	r22, 0x00	; 0
    360e:	0e 94 f9 09 	call	0x13f2	; 0x13f2 <DIO_WritePin>
    3612:	80 e0       	ldi	r24, 0x00	; 0
    3614:	90 e0       	ldi	r25, 0x00	; 0
    3616:	aa ef       	ldi	r26, 0xFA	; 250
    3618:	b3 e4       	ldi	r27, 0x43	; 67
    361a:	8f a3       	std	Y+39, r24	; 0x27
    361c:	98 a7       	std	Y+40, r25	; 0x28
    361e:	a9 a7       	std	Y+41, r26	; 0x29
    3620:	ba a7       	std	Y+42, r27	; 0x2a
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    3622:	6f a1       	ldd	r22, Y+39	; 0x27
    3624:	78 a5       	ldd	r23, Y+40	; 0x28
    3626:	89 a5       	ldd	r24, Y+41	; 0x29
    3628:	9a a5       	ldd	r25, Y+42	; 0x2a
    362a:	20 e0       	ldi	r18, 0x00	; 0
    362c:	30 e0       	ldi	r19, 0x00	; 0
    362e:	4a ef       	ldi	r20, 0xFA	; 250
    3630:	54 e4       	ldi	r21, 0x44	; 68
    3632:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    3636:	dc 01       	movw	r26, r24
    3638:	cb 01       	movw	r24, r22
    363a:	8b a3       	std	Y+35, r24	; 0x23
    363c:	9c a3       	std	Y+36, r25	; 0x24
    363e:	ad a3       	std	Y+37, r26	; 0x25
    3640:	be a3       	std	Y+38, r27	; 0x26
	if (__tmp < 1.0)
    3642:	6b a1       	ldd	r22, Y+35	; 0x23
    3644:	7c a1       	ldd	r23, Y+36	; 0x24
    3646:	8d a1       	ldd	r24, Y+37	; 0x25
    3648:	9e a1       	ldd	r25, Y+38	; 0x26
    364a:	20 e0       	ldi	r18, 0x00	; 0
    364c:	30 e0       	ldi	r19, 0x00	; 0
    364e:	40 e8       	ldi	r20, 0x80	; 128
    3650:	5f e3       	ldi	r21, 0x3F	; 63
    3652:	0e 94 79 03 	call	0x6f2	; 0x6f2 <__ltsf2>
    3656:	88 23       	and	r24, r24
    3658:	2c f4       	brge	.+10     	; 0x3664 <STEPPER_Unipolar_CW+0x18a>
		__ticks = 1;
    365a:	81 e0       	ldi	r24, 0x01	; 1
    365c:	90 e0       	ldi	r25, 0x00	; 0
    365e:	9a a3       	std	Y+34, r25	; 0x22
    3660:	89 a3       	std	Y+33, r24	; 0x21
    3662:	3f c0       	rjmp	.+126    	; 0x36e2 <STEPPER_Unipolar_CW+0x208>
	else if (__tmp > 65535)
    3664:	6b a1       	ldd	r22, Y+35	; 0x23
    3666:	7c a1       	ldd	r23, Y+36	; 0x24
    3668:	8d a1       	ldd	r24, Y+37	; 0x25
    366a:	9e a1       	ldd	r25, Y+38	; 0x26
    366c:	20 e0       	ldi	r18, 0x00	; 0
    366e:	3f ef       	ldi	r19, 0xFF	; 255
    3670:	4f e7       	ldi	r20, 0x7F	; 127
    3672:	57 e4       	ldi	r21, 0x47	; 71
    3674:	0e 94 19 03 	call	0x632	; 0x632 <__gtsf2>
    3678:	18 16       	cp	r1, r24
    367a:	4c f5       	brge	.+82     	; 0x36ce <STEPPER_Unipolar_CW+0x1f4>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    367c:	6f a1       	ldd	r22, Y+39	; 0x27
    367e:	78 a5       	ldd	r23, Y+40	; 0x28
    3680:	89 a5       	ldd	r24, Y+41	; 0x29
    3682:	9a a5       	ldd	r25, Y+42	; 0x2a
    3684:	20 e0       	ldi	r18, 0x00	; 0
    3686:	30 e0       	ldi	r19, 0x00	; 0
    3688:	40 e2       	ldi	r20, 0x20	; 32
    368a:	51 e4       	ldi	r21, 0x41	; 65
    368c:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    3690:	dc 01       	movw	r26, r24
    3692:	cb 01       	movw	r24, r22
    3694:	bc 01       	movw	r22, r24
    3696:	cd 01       	movw	r24, r26
    3698:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    369c:	dc 01       	movw	r26, r24
    369e:	cb 01       	movw	r24, r22
    36a0:	9a a3       	std	Y+34, r25	; 0x22
    36a2:	89 a3       	std	Y+33, r24	; 0x21
    36a4:	0f c0       	rjmp	.+30     	; 0x36c4 <STEPPER_Unipolar_CW+0x1ea>
    36a6:	88 ec       	ldi	r24, 0xC8	; 200
    36a8:	90 e0       	ldi	r25, 0x00	; 0
    36aa:	98 a3       	std	Y+32, r25	; 0x20
    36ac:	8f 8f       	std	Y+31, r24	; 0x1f
    36ae:	8f 8d       	ldd	r24, Y+31	; 0x1f
    36b0:	98 a1       	ldd	r25, Y+32	; 0x20
    36b2:	01 97       	sbiw	r24, 0x01	; 1
    36b4:	f1 f7       	brne	.-4      	; 0x36b2 <STEPPER_Unipolar_CW+0x1d8>
    36b6:	98 a3       	std	Y+32, r25	; 0x20
    36b8:	8f 8f       	std	Y+31, r24	; 0x1f
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    36ba:	89 a1       	ldd	r24, Y+33	; 0x21
    36bc:	9a a1       	ldd	r25, Y+34	; 0x22
    36be:	01 97       	sbiw	r24, 0x01	; 1
    36c0:	9a a3       	std	Y+34, r25	; 0x22
    36c2:	89 a3       	std	Y+33, r24	; 0x21
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    36c4:	89 a1       	ldd	r24, Y+33	; 0x21
    36c6:	9a a1       	ldd	r25, Y+34	; 0x22
    36c8:	00 97       	sbiw	r24, 0x00	; 0
    36ca:	69 f7       	brne	.-38     	; 0x36a6 <STEPPER_Unipolar_CW+0x1cc>
    36cc:	14 c0       	rjmp	.+40     	; 0x36f6 <STEPPER_Unipolar_CW+0x21c>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    36ce:	6b a1       	ldd	r22, Y+35	; 0x23
    36d0:	7c a1       	ldd	r23, Y+36	; 0x24
    36d2:	8d a1       	ldd	r24, Y+37	; 0x25
    36d4:	9e a1       	ldd	r25, Y+38	; 0x26
    36d6:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    36da:	dc 01       	movw	r26, r24
    36dc:	cb 01       	movw	r24, r22
    36de:	9a a3       	std	Y+34, r25	; 0x22
    36e0:	89 a3       	std	Y+33, r24	; 0x21
    36e2:	89 a1       	ldd	r24, Y+33	; 0x21
    36e4:	9a a1       	ldd	r25, Y+34	; 0x22
    36e6:	9e 8f       	std	Y+30, r25	; 0x1e
    36e8:	8d 8f       	std	Y+29, r24	; 0x1d
    36ea:	8d 8d       	ldd	r24, Y+29	; 0x1d
    36ec:	9e 8d       	ldd	r25, Y+30	; 0x1e
    36ee:	01 97       	sbiw	r24, 0x01	; 1
    36f0:	f1 f7       	brne	.-4      	; 0x36ee <STEPPER_Unipolar_CW+0x214>
    36f2:	9e 8f       	std	Y+30, r25	; 0x1e
    36f4:	8d 8f       	std	Y+29, r24	; 0x1d
	_delay_ms( DELAY );
	DIO_WritePin(COIL1A,LOW);
    36f6:	84 e1       	ldi	r24, 0x14	; 20
    36f8:	60 e0       	ldi	r22, 0x00	; 0
    36fa:	0e 94 f9 09 	call	0x13f2	; 0x13f2 <DIO_WritePin>
	DIO_WritePin(COIL1B,LOW);
    36fe:	85 e1       	ldi	r24, 0x15	; 21
    3700:	60 e0       	ldi	r22, 0x00	; 0
    3702:	0e 94 f9 09 	call	0x13f2	; 0x13f2 <DIO_WritePin>
	DIO_WritePin(COIL2A,HIGH);
    3706:	86 e1       	ldi	r24, 0x16	; 22
    3708:	61 e0       	ldi	r22, 0x01	; 1
    370a:	0e 94 f9 09 	call	0x13f2	; 0x13f2 <DIO_WritePin>
	DIO_WritePin(COIL2B,LOW);
    370e:	87 e1       	ldi	r24, 0x17	; 23
    3710:	60 e0       	ldi	r22, 0x00	; 0
    3712:	0e 94 f9 09 	call	0x13f2	; 0x13f2 <DIO_WritePin>
    3716:	80 e0       	ldi	r24, 0x00	; 0
    3718:	90 e0       	ldi	r25, 0x00	; 0
    371a:	aa ef       	ldi	r26, 0xFA	; 250
    371c:	b3 e4       	ldi	r27, 0x43	; 67
    371e:	89 8f       	std	Y+25, r24	; 0x19
    3720:	9a 8f       	std	Y+26, r25	; 0x1a
    3722:	ab 8f       	std	Y+27, r26	; 0x1b
    3724:	bc 8f       	std	Y+28, r27	; 0x1c
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    3726:	69 8d       	ldd	r22, Y+25	; 0x19
    3728:	7a 8d       	ldd	r23, Y+26	; 0x1a
    372a:	8b 8d       	ldd	r24, Y+27	; 0x1b
    372c:	9c 8d       	ldd	r25, Y+28	; 0x1c
    372e:	20 e0       	ldi	r18, 0x00	; 0
    3730:	30 e0       	ldi	r19, 0x00	; 0
    3732:	4a ef       	ldi	r20, 0xFA	; 250
    3734:	54 e4       	ldi	r21, 0x44	; 68
    3736:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    373a:	dc 01       	movw	r26, r24
    373c:	cb 01       	movw	r24, r22
    373e:	8d 8b       	std	Y+21, r24	; 0x15
    3740:	9e 8b       	std	Y+22, r25	; 0x16
    3742:	af 8b       	std	Y+23, r26	; 0x17
    3744:	b8 8f       	std	Y+24, r27	; 0x18
	if (__tmp < 1.0)
    3746:	6d 89       	ldd	r22, Y+21	; 0x15
    3748:	7e 89       	ldd	r23, Y+22	; 0x16
    374a:	8f 89       	ldd	r24, Y+23	; 0x17
    374c:	98 8d       	ldd	r25, Y+24	; 0x18
    374e:	20 e0       	ldi	r18, 0x00	; 0
    3750:	30 e0       	ldi	r19, 0x00	; 0
    3752:	40 e8       	ldi	r20, 0x80	; 128
    3754:	5f e3       	ldi	r21, 0x3F	; 63
    3756:	0e 94 79 03 	call	0x6f2	; 0x6f2 <__ltsf2>
    375a:	88 23       	and	r24, r24
    375c:	2c f4       	brge	.+10     	; 0x3768 <STEPPER_Unipolar_CW+0x28e>
		__ticks = 1;
    375e:	81 e0       	ldi	r24, 0x01	; 1
    3760:	90 e0       	ldi	r25, 0x00	; 0
    3762:	9c 8b       	std	Y+20, r25	; 0x14
    3764:	8b 8b       	std	Y+19, r24	; 0x13
    3766:	3f c0       	rjmp	.+126    	; 0x37e6 <STEPPER_Unipolar_CW+0x30c>
	else if (__tmp > 65535)
    3768:	6d 89       	ldd	r22, Y+21	; 0x15
    376a:	7e 89       	ldd	r23, Y+22	; 0x16
    376c:	8f 89       	ldd	r24, Y+23	; 0x17
    376e:	98 8d       	ldd	r25, Y+24	; 0x18
    3770:	20 e0       	ldi	r18, 0x00	; 0
    3772:	3f ef       	ldi	r19, 0xFF	; 255
    3774:	4f e7       	ldi	r20, 0x7F	; 127
    3776:	57 e4       	ldi	r21, 0x47	; 71
    3778:	0e 94 19 03 	call	0x632	; 0x632 <__gtsf2>
    377c:	18 16       	cp	r1, r24
    377e:	4c f5       	brge	.+82     	; 0x37d2 <STEPPER_Unipolar_CW+0x2f8>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    3780:	69 8d       	ldd	r22, Y+25	; 0x19
    3782:	7a 8d       	ldd	r23, Y+26	; 0x1a
    3784:	8b 8d       	ldd	r24, Y+27	; 0x1b
    3786:	9c 8d       	ldd	r25, Y+28	; 0x1c
    3788:	20 e0       	ldi	r18, 0x00	; 0
    378a:	30 e0       	ldi	r19, 0x00	; 0
    378c:	40 e2       	ldi	r20, 0x20	; 32
    378e:	51 e4       	ldi	r21, 0x41	; 65
    3790:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    3794:	dc 01       	movw	r26, r24
    3796:	cb 01       	movw	r24, r22
    3798:	bc 01       	movw	r22, r24
    379a:	cd 01       	movw	r24, r26
    379c:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    37a0:	dc 01       	movw	r26, r24
    37a2:	cb 01       	movw	r24, r22
    37a4:	9c 8b       	std	Y+20, r25	; 0x14
    37a6:	8b 8b       	std	Y+19, r24	; 0x13
    37a8:	0f c0       	rjmp	.+30     	; 0x37c8 <STEPPER_Unipolar_CW+0x2ee>
    37aa:	88 ec       	ldi	r24, 0xC8	; 200
    37ac:	90 e0       	ldi	r25, 0x00	; 0
    37ae:	9a 8b       	std	Y+18, r25	; 0x12
    37b0:	89 8b       	std	Y+17, r24	; 0x11
    37b2:	89 89       	ldd	r24, Y+17	; 0x11
    37b4:	9a 89       	ldd	r25, Y+18	; 0x12
    37b6:	01 97       	sbiw	r24, 0x01	; 1
    37b8:	f1 f7       	brne	.-4      	; 0x37b6 <STEPPER_Unipolar_CW+0x2dc>
    37ba:	9a 8b       	std	Y+18, r25	; 0x12
    37bc:	89 8b       	std	Y+17, r24	; 0x11
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    37be:	8b 89       	ldd	r24, Y+19	; 0x13
    37c0:	9c 89       	ldd	r25, Y+20	; 0x14
    37c2:	01 97       	sbiw	r24, 0x01	; 1
    37c4:	9c 8b       	std	Y+20, r25	; 0x14
    37c6:	8b 8b       	std	Y+19, r24	; 0x13
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    37c8:	8b 89       	ldd	r24, Y+19	; 0x13
    37ca:	9c 89       	ldd	r25, Y+20	; 0x14
    37cc:	00 97       	sbiw	r24, 0x00	; 0
    37ce:	69 f7       	brne	.-38     	; 0x37aa <STEPPER_Unipolar_CW+0x2d0>
    37d0:	14 c0       	rjmp	.+40     	; 0x37fa <STEPPER_Unipolar_CW+0x320>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    37d2:	6d 89       	ldd	r22, Y+21	; 0x15
    37d4:	7e 89       	ldd	r23, Y+22	; 0x16
    37d6:	8f 89       	ldd	r24, Y+23	; 0x17
    37d8:	98 8d       	ldd	r25, Y+24	; 0x18
    37da:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    37de:	dc 01       	movw	r26, r24
    37e0:	cb 01       	movw	r24, r22
    37e2:	9c 8b       	std	Y+20, r25	; 0x14
    37e4:	8b 8b       	std	Y+19, r24	; 0x13
    37e6:	8b 89       	ldd	r24, Y+19	; 0x13
    37e8:	9c 89       	ldd	r25, Y+20	; 0x14
    37ea:	98 8b       	std	Y+16, r25	; 0x10
    37ec:	8f 87       	std	Y+15, r24	; 0x0f
    37ee:	8f 85       	ldd	r24, Y+15	; 0x0f
    37f0:	98 89       	ldd	r25, Y+16	; 0x10
    37f2:	01 97       	sbiw	r24, 0x01	; 1
    37f4:	f1 f7       	brne	.-4      	; 0x37f2 <STEPPER_Unipolar_CW+0x318>
    37f6:	98 8b       	std	Y+16, r25	; 0x10
    37f8:	8f 87       	std	Y+15, r24	; 0x0f
	_delay_ms( DELAY );
	DIO_WritePin(COIL1A,LOW);
    37fa:	84 e1       	ldi	r24, 0x14	; 20
    37fc:	60 e0       	ldi	r22, 0x00	; 0
    37fe:	0e 94 f9 09 	call	0x13f2	; 0x13f2 <DIO_WritePin>
	DIO_WritePin(COIL1B,LOW);
    3802:	85 e1       	ldi	r24, 0x15	; 21
    3804:	60 e0       	ldi	r22, 0x00	; 0
    3806:	0e 94 f9 09 	call	0x13f2	; 0x13f2 <DIO_WritePin>
	DIO_WritePin(COIL2A,LOW);
    380a:	86 e1       	ldi	r24, 0x16	; 22
    380c:	60 e0       	ldi	r22, 0x00	; 0
    380e:	0e 94 f9 09 	call	0x13f2	; 0x13f2 <DIO_WritePin>
	DIO_WritePin(COIL2B,HIGH);
    3812:	87 e1       	ldi	r24, 0x17	; 23
    3814:	61 e0       	ldi	r22, 0x01	; 1
    3816:	0e 94 f9 09 	call	0x13f2	; 0x13f2 <DIO_WritePin>
    381a:	80 e0       	ldi	r24, 0x00	; 0
    381c:	90 e0       	ldi	r25, 0x00	; 0
    381e:	aa ef       	ldi	r26, 0xFA	; 250
    3820:	b3 e4       	ldi	r27, 0x43	; 67
    3822:	8b 87       	std	Y+11, r24	; 0x0b
    3824:	9c 87       	std	Y+12, r25	; 0x0c
    3826:	ad 87       	std	Y+13, r26	; 0x0d
    3828:	be 87       	std	Y+14, r27	; 0x0e
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    382a:	6b 85       	ldd	r22, Y+11	; 0x0b
    382c:	7c 85       	ldd	r23, Y+12	; 0x0c
    382e:	8d 85       	ldd	r24, Y+13	; 0x0d
    3830:	9e 85       	ldd	r25, Y+14	; 0x0e
    3832:	20 e0       	ldi	r18, 0x00	; 0
    3834:	30 e0       	ldi	r19, 0x00	; 0
    3836:	4a ef       	ldi	r20, 0xFA	; 250
    3838:	54 e4       	ldi	r21, 0x44	; 68
    383a:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    383e:	dc 01       	movw	r26, r24
    3840:	cb 01       	movw	r24, r22
    3842:	8f 83       	std	Y+7, r24	; 0x07
    3844:	98 87       	std	Y+8, r25	; 0x08
    3846:	a9 87       	std	Y+9, r26	; 0x09
    3848:	ba 87       	std	Y+10, r27	; 0x0a
	if (__tmp < 1.0)
    384a:	6f 81       	ldd	r22, Y+7	; 0x07
    384c:	78 85       	ldd	r23, Y+8	; 0x08
    384e:	89 85       	ldd	r24, Y+9	; 0x09
    3850:	9a 85       	ldd	r25, Y+10	; 0x0a
    3852:	20 e0       	ldi	r18, 0x00	; 0
    3854:	30 e0       	ldi	r19, 0x00	; 0
    3856:	40 e8       	ldi	r20, 0x80	; 128
    3858:	5f e3       	ldi	r21, 0x3F	; 63
    385a:	0e 94 79 03 	call	0x6f2	; 0x6f2 <__ltsf2>
    385e:	88 23       	and	r24, r24
    3860:	2c f4       	brge	.+10     	; 0x386c <STEPPER_Unipolar_CW+0x392>
		__ticks = 1;
    3862:	81 e0       	ldi	r24, 0x01	; 1
    3864:	90 e0       	ldi	r25, 0x00	; 0
    3866:	9e 83       	std	Y+6, r25	; 0x06
    3868:	8d 83       	std	Y+5, r24	; 0x05
    386a:	3f c0       	rjmp	.+126    	; 0x38ea <STEPPER_Unipolar_CW+0x410>
	else if (__tmp > 65535)
    386c:	6f 81       	ldd	r22, Y+7	; 0x07
    386e:	78 85       	ldd	r23, Y+8	; 0x08
    3870:	89 85       	ldd	r24, Y+9	; 0x09
    3872:	9a 85       	ldd	r25, Y+10	; 0x0a
    3874:	20 e0       	ldi	r18, 0x00	; 0
    3876:	3f ef       	ldi	r19, 0xFF	; 255
    3878:	4f e7       	ldi	r20, 0x7F	; 127
    387a:	57 e4       	ldi	r21, 0x47	; 71
    387c:	0e 94 19 03 	call	0x632	; 0x632 <__gtsf2>
    3880:	18 16       	cp	r1, r24
    3882:	4c f5       	brge	.+82     	; 0x38d6 <STEPPER_Unipolar_CW+0x3fc>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    3884:	6b 85       	ldd	r22, Y+11	; 0x0b
    3886:	7c 85       	ldd	r23, Y+12	; 0x0c
    3888:	8d 85       	ldd	r24, Y+13	; 0x0d
    388a:	9e 85       	ldd	r25, Y+14	; 0x0e
    388c:	20 e0       	ldi	r18, 0x00	; 0
    388e:	30 e0       	ldi	r19, 0x00	; 0
    3890:	40 e2       	ldi	r20, 0x20	; 32
    3892:	51 e4       	ldi	r21, 0x41	; 65
    3894:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    3898:	dc 01       	movw	r26, r24
    389a:	cb 01       	movw	r24, r22
    389c:	bc 01       	movw	r22, r24
    389e:	cd 01       	movw	r24, r26
    38a0:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    38a4:	dc 01       	movw	r26, r24
    38a6:	cb 01       	movw	r24, r22
    38a8:	9e 83       	std	Y+6, r25	; 0x06
    38aa:	8d 83       	std	Y+5, r24	; 0x05
    38ac:	0f c0       	rjmp	.+30     	; 0x38cc <STEPPER_Unipolar_CW+0x3f2>
    38ae:	88 ec       	ldi	r24, 0xC8	; 200
    38b0:	90 e0       	ldi	r25, 0x00	; 0
    38b2:	9c 83       	std	Y+4, r25	; 0x04
    38b4:	8b 83       	std	Y+3, r24	; 0x03
    38b6:	8b 81       	ldd	r24, Y+3	; 0x03
    38b8:	9c 81       	ldd	r25, Y+4	; 0x04
    38ba:	01 97       	sbiw	r24, 0x01	; 1
    38bc:	f1 f7       	brne	.-4      	; 0x38ba <STEPPER_Unipolar_CW+0x3e0>
    38be:	9c 83       	std	Y+4, r25	; 0x04
    38c0:	8b 83       	std	Y+3, r24	; 0x03
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    38c2:	8d 81       	ldd	r24, Y+5	; 0x05
    38c4:	9e 81       	ldd	r25, Y+6	; 0x06
    38c6:	01 97       	sbiw	r24, 0x01	; 1
    38c8:	9e 83       	std	Y+6, r25	; 0x06
    38ca:	8d 83       	std	Y+5, r24	; 0x05
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    38cc:	8d 81       	ldd	r24, Y+5	; 0x05
    38ce:	9e 81       	ldd	r25, Y+6	; 0x06
    38d0:	00 97       	sbiw	r24, 0x00	; 0
    38d2:	69 f7       	brne	.-38     	; 0x38ae <STEPPER_Unipolar_CW+0x3d4>
    38d4:	14 c0       	rjmp	.+40     	; 0x38fe <STEPPER_Unipolar_CW+0x424>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    38d6:	6f 81       	ldd	r22, Y+7	; 0x07
    38d8:	78 85       	ldd	r23, Y+8	; 0x08
    38da:	89 85       	ldd	r24, Y+9	; 0x09
    38dc:	9a 85       	ldd	r25, Y+10	; 0x0a
    38de:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    38e2:	dc 01       	movw	r26, r24
    38e4:	cb 01       	movw	r24, r22
    38e6:	9e 83       	std	Y+6, r25	; 0x06
    38e8:	8d 83       	std	Y+5, r24	; 0x05
    38ea:	8d 81       	ldd	r24, Y+5	; 0x05
    38ec:	9e 81       	ldd	r25, Y+6	; 0x06
    38ee:	9a 83       	std	Y+2, r25	; 0x02
    38f0:	89 83       	std	Y+1, r24	; 0x01
    38f2:	89 81       	ldd	r24, Y+1	; 0x01
    38f4:	9a 81       	ldd	r25, Y+2	; 0x02
    38f6:	01 97       	sbiw	r24, 0x01	; 1
    38f8:	f1 f7       	brne	.-4      	; 0x38f6 <STEPPER_Unipolar_CW+0x41c>
    38fa:	9a 83       	std	Y+2, r25	; 0x02
    38fc:	89 83       	std	Y+1, r24	; 0x01
	_delay_ms( DELAY );

}
    38fe:	e8 96       	adiw	r28, 0x38	; 56
    3900:	0f b6       	in	r0, 0x3f	; 63
    3902:	f8 94       	cli
    3904:	de bf       	out	0x3e, r29	; 62
    3906:	0f be       	out	0x3f, r0	; 63
    3908:	cd bf       	out	0x3d, r28	; 61
    390a:	cf 91       	pop	r28
    390c:	df 91       	pop	r29
    390e:	08 95       	ret

00003910 <STEPPER_Unipolar_CCW>:
void STEPPER_Unipolar_CCW(void)
{
    3910:	df 93       	push	r29
    3912:	cf 93       	push	r28
    3914:	cd b7       	in	r28, 0x3d	; 61
    3916:	de b7       	in	r29, 0x3e	; 62
    3918:	e8 97       	sbiw	r28, 0x38	; 56
    391a:	0f b6       	in	r0, 0x3f	; 63
    391c:	f8 94       	cli
    391e:	de bf       	out	0x3e, r29	; 62
    3920:	0f be       	out	0x3f, r0	; 63
    3922:	cd bf       	out	0x3d, r28	; 61
	DIO_WritePin(COIL1A,HIGH);
    3924:	84 e1       	ldi	r24, 0x14	; 20
    3926:	61 e0       	ldi	r22, 0x01	; 1
    3928:	0e 94 f9 09 	call	0x13f2	; 0x13f2 <DIO_WritePin>
	DIO_WritePin(COIL1B,LOW);
    392c:	85 e1       	ldi	r24, 0x15	; 21
    392e:	60 e0       	ldi	r22, 0x00	; 0
    3930:	0e 94 f9 09 	call	0x13f2	; 0x13f2 <DIO_WritePin>
	DIO_WritePin(COIL2A,LOW);
    3934:	86 e1       	ldi	r24, 0x16	; 22
    3936:	60 e0       	ldi	r22, 0x00	; 0
    3938:	0e 94 f9 09 	call	0x13f2	; 0x13f2 <DIO_WritePin>
	DIO_WritePin(COIL2B,LOW);
    393c:	87 e1       	ldi	r24, 0x17	; 23
    393e:	60 e0       	ldi	r22, 0x00	; 0
    3940:	0e 94 f9 09 	call	0x13f2	; 0x13f2 <DIO_WritePin>
    3944:	80 e0       	ldi	r24, 0x00	; 0
    3946:	90 e0       	ldi	r25, 0x00	; 0
    3948:	aa ef       	ldi	r26, 0xFA	; 250
    394a:	b3 e4       	ldi	r27, 0x43	; 67
    394c:	8d ab       	std	Y+53, r24	; 0x35
    394e:	9e ab       	std	Y+54, r25	; 0x36
    3950:	af ab       	std	Y+55, r26	; 0x37
    3952:	b8 af       	std	Y+56, r27	; 0x38
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    3954:	6d a9       	ldd	r22, Y+53	; 0x35
    3956:	7e a9       	ldd	r23, Y+54	; 0x36
    3958:	8f a9       	ldd	r24, Y+55	; 0x37
    395a:	98 ad       	ldd	r25, Y+56	; 0x38
    395c:	20 e0       	ldi	r18, 0x00	; 0
    395e:	30 e0       	ldi	r19, 0x00	; 0
    3960:	4a ef       	ldi	r20, 0xFA	; 250
    3962:	54 e4       	ldi	r21, 0x44	; 68
    3964:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    3968:	dc 01       	movw	r26, r24
    396a:	cb 01       	movw	r24, r22
    396c:	89 ab       	std	Y+49, r24	; 0x31
    396e:	9a ab       	std	Y+50, r25	; 0x32
    3970:	ab ab       	std	Y+51, r26	; 0x33
    3972:	bc ab       	std	Y+52, r27	; 0x34
	if (__tmp < 1.0)
    3974:	69 a9       	ldd	r22, Y+49	; 0x31
    3976:	7a a9       	ldd	r23, Y+50	; 0x32
    3978:	8b a9       	ldd	r24, Y+51	; 0x33
    397a:	9c a9       	ldd	r25, Y+52	; 0x34
    397c:	20 e0       	ldi	r18, 0x00	; 0
    397e:	30 e0       	ldi	r19, 0x00	; 0
    3980:	40 e8       	ldi	r20, 0x80	; 128
    3982:	5f e3       	ldi	r21, 0x3F	; 63
    3984:	0e 94 79 03 	call	0x6f2	; 0x6f2 <__ltsf2>
    3988:	88 23       	and	r24, r24
    398a:	2c f4       	brge	.+10     	; 0x3996 <STEPPER_Unipolar_CCW+0x86>
		__ticks = 1;
    398c:	81 e0       	ldi	r24, 0x01	; 1
    398e:	90 e0       	ldi	r25, 0x00	; 0
    3990:	98 ab       	std	Y+48, r25	; 0x30
    3992:	8f a7       	std	Y+47, r24	; 0x2f
    3994:	3f c0       	rjmp	.+126    	; 0x3a14 <STEPPER_Unipolar_CCW+0x104>
	else if (__tmp > 65535)
    3996:	69 a9       	ldd	r22, Y+49	; 0x31
    3998:	7a a9       	ldd	r23, Y+50	; 0x32
    399a:	8b a9       	ldd	r24, Y+51	; 0x33
    399c:	9c a9       	ldd	r25, Y+52	; 0x34
    399e:	20 e0       	ldi	r18, 0x00	; 0
    39a0:	3f ef       	ldi	r19, 0xFF	; 255
    39a2:	4f e7       	ldi	r20, 0x7F	; 127
    39a4:	57 e4       	ldi	r21, 0x47	; 71
    39a6:	0e 94 19 03 	call	0x632	; 0x632 <__gtsf2>
    39aa:	18 16       	cp	r1, r24
    39ac:	4c f5       	brge	.+82     	; 0x3a00 <STEPPER_Unipolar_CCW+0xf0>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    39ae:	6d a9       	ldd	r22, Y+53	; 0x35
    39b0:	7e a9       	ldd	r23, Y+54	; 0x36
    39b2:	8f a9       	ldd	r24, Y+55	; 0x37
    39b4:	98 ad       	ldd	r25, Y+56	; 0x38
    39b6:	20 e0       	ldi	r18, 0x00	; 0
    39b8:	30 e0       	ldi	r19, 0x00	; 0
    39ba:	40 e2       	ldi	r20, 0x20	; 32
    39bc:	51 e4       	ldi	r21, 0x41	; 65
    39be:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    39c2:	dc 01       	movw	r26, r24
    39c4:	cb 01       	movw	r24, r22
    39c6:	bc 01       	movw	r22, r24
    39c8:	cd 01       	movw	r24, r26
    39ca:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    39ce:	dc 01       	movw	r26, r24
    39d0:	cb 01       	movw	r24, r22
    39d2:	98 ab       	std	Y+48, r25	; 0x30
    39d4:	8f a7       	std	Y+47, r24	; 0x2f
    39d6:	0f c0       	rjmp	.+30     	; 0x39f6 <STEPPER_Unipolar_CCW+0xe6>
    39d8:	88 ec       	ldi	r24, 0xC8	; 200
    39da:	90 e0       	ldi	r25, 0x00	; 0
    39dc:	9e a7       	std	Y+46, r25	; 0x2e
    39de:	8d a7       	std	Y+45, r24	; 0x2d
    39e0:	8d a5       	ldd	r24, Y+45	; 0x2d
    39e2:	9e a5       	ldd	r25, Y+46	; 0x2e
    39e4:	01 97       	sbiw	r24, 0x01	; 1
    39e6:	f1 f7       	brne	.-4      	; 0x39e4 <STEPPER_Unipolar_CCW+0xd4>
    39e8:	9e a7       	std	Y+46, r25	; 0x2e
    39ea:	8d a7       	std	Y+45, r24	; 0x2d
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    39ec:	8f a5       	ldd	r24, Y+47	; 0x2f
    39ee:	98 a9       	ldd	r25, Y+48	; 0x30
    39f0:	01 97       	sbiw	r24, 0x01	; 1
    39f2:	98 ab       	std	Y+48, r25	; 0x30
    39f4:	8f a7       	std	Y+47, r24	; 0x2f
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    39f6:	8f a5       	ldd	r24, Y+47	; 0x2f
    39f8:	98 a9       	ldd	r25, Y+48	; 0x30
    39fa:	00 97       	sbiw	r24, 0x00	; 0
    39fc:	69 f7       	brne	.-38     	; 0x39d8 <STEPPER_Unipolar_CCW+0xc8>
    39fe:	14 c0       	rjmp	.+40     	; 0x3a28 <STEPPER_Unipolar_CCW+0x118>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    3a00:	69 a9       	ldd	r22, Y+49	; 0x31
    3a02:	7a a9       	ldd	r23, Y+50	; 0x32
    3a04:	8b a9       	ldd	r24, Y+51	; 0x33
    3a06:	9c a9       	ldd	r25, Y+52	; 0x34
    3a08:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    3a0c:	dc 01       	movw	r26, r24
    3a0e:	cb 01       	movw	r24, r22
    3a10:	98 ab       	std	Y+48, r25	; 0x30
    3a12:	8f a7       	std	Y+47, r24	; 0x2f
    3a14:	8f a5       	ldd	r24, Y+47	; 0x2f
    3a16:	98 a9       	ldd	r25, Y+48	; 0x30
    3a18:	9c a7       	std	Y+44, r25	; 0x2c
    3a1a:	8b a7       	std	Y+43, r24	; 0x2b
    3a1c:	8b a5       	ldd	r24, Y+43	; 0x2b
    3a1e:	9c a5       	ldd	r25, Y+44	; 0x2c
    3a20:	01 97       	sbiw	r24, 0x01	; 1
    3a22:	f1 f7       	brne	.-4      	; 0x3a20 <STEPPER_Unipolar_CCW+0x110>
    3a24:	9c a7       	std	Y+44, r25	; 0x2c
    3a26:	8b a7       	std	Y+43, r24	; 0x2b
	_delay_ms( DELAY );
	DIO_WritePin(COIL1A,LOW);
    3a28:	84 e1       	ldi	r24, 0x14	; 20
    3a2a:	60 e0       	ldi	r22, 0x00	; 0
    3a2c:	0e 94 f9 09 	call	0x13f2	; 0x13f2 <DIO_WritePin>
	DIO_WritePin(COIL1B,LOW);
    3a30:	85 e1       	ldi	r24, 0x15	; 21
    3a32:	60 e0       	ldi	r22, 0x00	; 0
    3a34:	0e 94 f9 09 	call	0x13f2	; 0x13f2 <DIO_WritePin>
	DIO_WritePin(COIL2A,LOW);
    3a38:	86 e1       	ldi	r24, 0x16	; 22
    3a3a:	60 e0       	ldi	r22, 0x00	; 0
    3a3c:	0e 94 f9 09 	call	0x13f2	; 0x13f2 <DIO_WritePin>
	DIO_WritePin(COIL2B,HIGH);
    3a40:	87 e1       	ldi	r24, 0x17	; 23
    3a42:	61 e0       	ldi	r22, 0x01	; 1
    3a44:	0e 94 f9 09 	call	0x13f2	; 0x13f2 <DIO_WritePin>
    3a48:	80 e0       	ldi	r24, 0x00	; 0
    3a4a:	90 e0       	ldi	r25, 0x00	; 0
    3a4c:	aa ef       	ldi	r26, 0xFA	; 250
    3a4e:	b3 e4       	ldi	r27, 0x43	; 67
    3a50:	8f a3       	std	Y+39, r24	; 0x27
    3a52:	98 a7       	std	Y+40, r25	; 0x28
    3a54:	a9 a7       	std	Y+41, r26	; 0x29
    3a56:	ba a7       	std	Y+42, r27	; 0x2a
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    3a58:	6f a1       	ldd	r22, Y+39	; 0x27
    3a5a:	78 a5       	ldd	r23, Y+40	; 0x28
    3a5c:	89 a5       	ldd	r24, Y+41	; 0x29
    3a5e:	9a a5       	ldd	r25, Y+42	; 0x2a
    3a60:	20 e0       	ldi	r18, 0x00	; 0
    3a62:	30 e0       	ldi	r19, 0x00	; 0
    3a64:	4a ef       	ldi	r20, 0xFA	; 250
    3a66:	54 e4       	ldi	r21, 0x44	; 68
    3a68:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    3a6c:	dc 01       	movw	r26, r24
    3a6e:	cb 01       	movw	r24, r22
    3a70:	8b a3       	std	Y+35, r24	; 0x23
    3a72:	9c a3       	std	Y+36, r25	; 0x24
    3a74:	ad a3       	std	Y+37, r26	; 0x25
    3a76:	be a3       	std	Y+38, r27	; 0x26
	if (__tmp < 1.0)
    3a78:	6b a1       	ldd	r22, Y+35	; 0x23
    3a7a:	7c a1       	ldd	r23, Y+36	; 0x24
    3a7c:	8d a1       	ldd	r24, Y+37	; 0x25
    3a7e:	9e a1       	ldd	r25, Y+38	; 0x26
    3a80:	20 e0       	ldi	r18, 0x00	; 0
    3a82:	30 e0       	ldi	r19, 0x00	; 0
    3a84:	40 e8       	ldi	r20, 0x80	; 128
    3a86:	5f e3       	ldi	r21, 0x3F	; 63
    3a88:	0e 94 79 03 	call	0x6f2	; 0x6f2 <__ltsf2>
    3a8c:	88 23       	and	r24, r24
    3a8e:	2c f4       	brge	.+10     	; 0x3a9a <STEPPER_Unipolar_CCW+0x18a>
		__ticks = 1;
    3a90:	81 e0       	ldi	r24, 0x01	; 1
    3a92:	90 e0       	ldi	r25, 0x00	; 0
    3a94:	9a a3       	std	Y+34, r25	; 0x22
    3a96:	89 a3       	std	Y+33, r24	; 0x21
    3a98:	3f c0       	rjmp	.+126    	; 0x3b18 <STEPPER_Unipolar_CCW+0x208>
	else if (__tmp > 65535)
    3a9a:	6b a1       	ldd	r22, Y+35	; 0x23
    3a9c:	7c a1       	ldd	r23, Y+36	; 0x24
    3a9e:	8d a1       	ldd	r24, Y+37	; 0x25
    3aa0:	9e a1       	ldd	r25, Y+38	; 0x26
    3aa2:	20 e0       	ldi	r18, 0x00	; 0
    3aa4:	3f ef       	ldi	r19, 0xFF	; 255
    3aa6:	4f e7       	ldi	r20, 0x7F	; 127
    3aa8:	57 e4       	ldi	r21, 0x47	; 71
    3aaa:	0e 94 19 03 	call	0x632	; 0x632 <__gtsf2>
    3aae:	18 16       	cp	r1, r24
    3ab0:	4c f5       	brge	.+82     	; 0x3b04 <STEPPER_Unipolar_CCW+0x1f4>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    3ab2:	6f a1       	ldd	r22, Y+39	; 0x27
    3ab4:	78 a5       	ldd	r23, Y+40	; 0x28
    3ab6:	89 a5       	ldd	r24, Y+41	; 0x29
    3ab8:	9a a5       	ldd	r25, Y+42	; 0x2a
    3aba:	20 e0       	ldi	r18, 0x00	; 0
    3abc:	30 e0       	ldi	r19, 0x00	; 0
    3abe:	40 e2       	ldi	r20, 0x20	; 32
    3ac0:	51 e4       	ldi	r21, 0x41	; 65
    3ac2:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    3ac6:	dc 01       	movw	r26, r24
    3ac8:	cb 01       	movw	r24, r22
    3aca:	bc 01       	movw	r22, r24
    3acc:	cd 01       	movw	r24, r26
    3ace:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    3ad2:	dc 01       	movw	r26, r24
    3ad4:	cb 01       	movw	r24, r22
    3ad6:	9a a3       	std	Y+34, r25	; 0x22
    3ad8:	89 a3       	std	Y+33, r24	; 0x21
    3ada:	0f c0       	rjmp	.+30     	; 0x3afa <STEPPER_Unipolar_CCW+0x1ea>
    3adc:	88 ec       	ldi	r24, 0xC8	; 200
    3ade:	90 e0       	ldi	r25, 0x00	; 0
    3ae0:	98 a3       	std	Y+32, r25	; 0x20
    3ae2:	8f 8f       	std	Y+31, r24	; 0x1f
    3ae4:	8f 8d       	ldd	r24, Y+31	; 0x1f
    3ae6:	98 a1       	ldd	r25, Y+32	; 0x20
    3ae8:	01 97       	sbiw	r24, 0x01	; 1
    3aea:	f1 f7       	brne	.-4      	; 0x3ae8 <STEPPER_Unipolar_CCW+0x1d8>
    3aec:	98 a3       	std	Y+32, r25	; 0x20
    3aee:	8f 8f       	std	Y+31, r24	; 0x1f
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    3af0:	89 a1       	ldd	r24, Y+33	; 0x21
    3af2:	9a a1       	ldd	r25, Y+34	; 0x22
    3af4:	01 97       	sbiw	r24, 0x01	; 1
    3af6:	9a a3       	std	Y+34, r25	; 0x22
    3af8:	89 a3       	std	Y+33, r24	; 0x21
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    3afa:	89 a1       	ldd	r24, Y+33	; 0x21
    3afc:	9a a1       	ldd	r25, Y+34	; 0x22
    3afe:	00 97       	sbiw	r24, 0x00	; 0
    3b00:	69 f7       	brne	.-38     	; 0x3adc <STEPPER_Unipolar_CCW+0x1cc>
    3b02:	14 c0       	rjmp	.+40     	; 0x3b2c <STEPPER_Unipolar_CCW+0x21c>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    3b04:	6b a1       	ldd	r22, Y+35	; 0x23
    3b06:	7c a1       	ldd	r23, Y+36	; 0x24
    3b08:	8d a1       	ldd	r24, Y+37	; 0x25
    3b0a:	9e a1       	ldd	r25, Y+38	; 0x26
    3b0c:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    3b10:	dc 01       	movw	r26, r24
    3b12:	cb 01       	movw	r24, r22
    3b14:	9a a3       	std	Y+34, r25	; 0x22
    3b16:	89 a3       	std	Y+33, r24	; 0x21
    3b18:	89 a1       	ldd	r24, Y+33	; 0x21
    3b1a:	9a a1       	ldd	r25, Y+34	; 0x22
    3b1c:	9e 8f       	std	Y+30, r25	; 0x1e
    3b1e:	8d 8f       	std	Y+29, r24	; 0x1d
    3b20:	8d 8d       	ldd	r24, Y+29	; 0x1d
    3b22:	9e 8d       	ldd	r25, Y+30	; 0x1e
    3b24:	01 97       	sbiw	r24, 0x01	; 1
    3b26:	f1 f7       	brne	.-4      	; 0x3b24 <STEPPER_Unipolar_CCW+0x214>
    3b28:	9e 8f       	std	Y+30, r25	; 0x1e
    3b2a:	8d 8f       	std	Y+29, r24	; 0x1d
	_delay_ms( DELAY );
	DIO_WritePin(COIL1A,LOW);
    3b2c:	84 e1       	ldi	r24, 0x14	; 20
    3b2e:	60 e0       	ldi	r22, 0x00	; 0
    3b30:	0e 94 f9 09 	call	0x13f2	; 0x13f2 <DIO_WritePin>
	DIO_WritePin(COIL1B,LOW);
    3b34:	85 e1       	ldi	r24, 0x15	; 21
    3b36:	60 e0       	ldi	r22, 0x00	; 0
    3b38:	0e 94 f9 09 	call	0x13f2	; 0x13f2 <DIO_WritePin>
	DIO_WritePin(COIL2A,HIGH);
    3b3c:	86 e1       	ldi	r24, 0x16	; 22
    3b3e:	61 e0       	ldi	r22, 0x01	; 1
    3b40:	0e 94 f9 09 	call	0x13f2	; 0x13f2 <DIO_WritePin>
	DIO_WritePin(COIL2B,LOW);
    3b44:	87 e1       	ldi	r24, 0x17	; 23
    3b46:	60 e0       	ldi	r22, 0x00	; 0
    3b48:	0e 94 f9 09 	call	0x13f2	; 0x13f2 <DIO_WritePin>
    3b4c:	80 e0       	ldi	r24, 0x00	; 0
    3b4e:	90 e0       	ldi	r25, 0x00	; 0
    3b50:	aa ef       	ldi	r26, 0xFA	; 250
    3b52:	b3 e4       	ldi	r27, 0x43	; 67
    3b54:	89 8f       	std	Y+25, r24	; 0x19
    3b56:	9a 8f       	std	Y+26, r25	; 0x1a
    3b58:	ab 8f       	std	Y+27, r26	; 0x1b
    3b5a:	bc 8f       	std	Y+28, r27	; 0x1c
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    3b5c:	69 8d       	ldd	r22, Y+25	; 0x19
    3b5e:	7a 8d       	ldd	r23, Y+26	; 0x1a
    3b60:	8b 8d       	ldd	r24, Y+27	; 0x1b
    3b62:	9c 8d       	ldd	r25, Y+28	; 0x1c
    3b64:	20 e0       	ldi	r18, 0x00	; 0
    3b66:	30 e0       	ldi	r19, 0x00	; 0
    3b68:	4a ef       	ldi	r20, 0xFA	; 250
    3b6a:	54 e4       	ldi	r21, 0x44	; 68
    3b6c:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    3b70:	dc 01       	movw	r26, r24
    3b72:	cb 01       	movw	r24, r22
    3b74:	8d 8b       	std	Y+21, r24	; 0x15
    3b76:	9e 8b       	std	Y+22, r25	; 0x16
    3b78:	af 8b       	std	Y+23, r26	; 0x17
    3b7a:	b8 8f       	std	Y+24, r27	; 0x18
	if (__tmp < 1.0)
    3b7c:	6d 89       	ldd	r22, Y+21	; 0x15
    3b7e:	7e 89       	ldd	r23, Y+22	; 0x16
    3b80:	8f 89       	ldd	r24, Y+23	; 0x17
    3b82:	98 8d       	ldd	r25, Y+24	; 0x18
    3b84:	20 e0       	ldi	r18, 0x00	; 0
    3b86:	30 e0       	ldi	r19, 0x00	; 0
    3b88:	40 e8       	ldi	r20, 0x80	; 128
    3b8a:	5f e3       	ldi	r21, 0x3F	; 63
    3b8c:	0e 94 79 03 	call	0x6f2	; 0x6f2 <__ltsf2>
    3b90:	88 23       	and	r24, r24
    3b92:	2c f4       	brge	.+10     	; 0x3b9e <STEPPER_Unipolar_CCW+0x28e>
		__ticks = 1;
    3b94:	81 e0       	ldi	r24, 0x01	; 1
    3b96:	90 e0       	ldi	r25, 0x00	; 0
    3b98:	9c 8b       	std	Y+20, r25	; 0x14
    3b9a:	8b 8b       	std	Y+19, r24	; 0x13
    3b9c:	3f c0       	rjmp	.+126    	; 0x3c1c <STEPPER_Unipolar_CCW+0x30c>
	else if (__tmp > 65535)
    3b9e:	6d 89       	ldd	r22, Y+21	; 0x15
    3ba0:	7e 89       	ldd	r23, Y+22	; 0x16
    3ba2:	8f 89       	ldd	r24, Y+23	; 0x17
    3ba4:	98 8d       	ldd	r25, Y+24	; 0x18
    3ba6:	20 e0       	ldi	r18, 0x00	; 0
    3ba8:	3f ef       	ldi	r19, 0xFF	; 255
    3baa:	4f e7       	ldi	r20, 0x7F	; 127
    3bac:	57 e4       	ldi	r21, 0x47	; 71
    3bae:	0e 94 19 03 	call	0x632	; 0x632 <__gtsf2>
    3bb2:	18 16       	cp	r1, r24
    3bb4:	4c f5       	brge	.+82     	; 0x3c08 <STEPPER_Unipolar_CCW+0x2f8>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    3bb6:	69 8d       	ldd	r22, Y+25	; 0x19
    3bb8:	7a 8d       	ldd	r23, Y+26	; 0x1a
    3bba:	8b 8d       	ldd	r24, Y+27	; 0x1b
    3bbc:	9c 8d       	ldd	r25, Y+28	; 0x1c
    3bbe:	20 e0       	ldi	r18, 0x00	; 0
    3bc0:	30 e0       	ldi	r19, 0x00	; 0
    3bc2:	40 e2       	ldi	r20, 0x20	; 32
    3bc4:	51 e4       	ldi	r21, 0x41	; 65
    3bc6:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    3bca:	dc 01       	movw	r26, r24
    3bcc:	cb 01       	movw	r24, r22
    3bce:	bc 01       	movw	r22, r24
    3bd0:	cd 01       	movw	r24, r26
    3bd2:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    3bd6:	dc 01       	movw	r26, r24
    3bd8:	cb 01       	movw	r24, r22
    3bda:	9c 8b       	std	Y+20, r25	; 0x14
    3bdc:	8b 8b       	std	Y+19, r24	; 0x13
    3bde:	0f c0       	rjmp	.+30     	; 0x3bfe <STEPPER_Unipolar_CCW+0x2ee>
    3be0:	88 ec       	ldi	r24, 0xC8	; 200
    3be2:	90 e0       	ldi	r25, 0x00	; 0
    3be4:	9a 8b       	std	Y+18, r25	; 0x12
    3be6:	89 8b       	std	Y+17, r24	; 0x11
    3be8:	89 89       	ldd	r24, Y+17	; 0x11
    3bea:	9a 89       	ldd	r25, Y+18	; 0x12
    3bec:	01 97       	sbiw	r24, 0x01	; 1
    3bee:	f1 f7       	brne	.-4      	; 0x3bec <STEPPER_Unipolar_CCW+0x2dc>
    3bf0:	9a 8b       	std	Y+18, r25	; 0x12
    3bf2:	89 8b       	std	Y+17, r24	; 0x11
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    3bf4:	8b 89       	ldd	r24, Y+19	; 0x13
    3bf6:	9c 89       	ldd	r25, Y+20	; 0x14
    3bf8:	01 97       	sbiw	r24, 0x01	; 1
    3bfa:	9c 8b       	std	Y+20, r25	; 0x14
    3bfc:	8b 8b       	std	Y+19, r24	; 0x13
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    3bfe:	8b 89       	ldd	r24, Y+19	; 0x13
    3c00:	9c 89       	ldd	r25, Y+20	; 0x14
    3c02:	00 97       	sbiw	r24, 0x00	; 0
    3c04:	69 f7       	brne	.-38     	; 0x3be0 <STEPPER_Unipolar_CCW+0x2d0>
    3c06:	14 c0       	rjmp	.+40     	; 0x3c30 <STEPPER_Unipolar_CCW+0x320>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    3c08:	6d 89       	ldd	r22, Y+21	; 0x15
    3c0a:	7e 89       	ldd	r23, Y+22	; 0x16
    3c0c:	8f 89       	ldd	r24, Y+23	; 0x17
    3c0e:	98 8d       	ldd	r25, Y+24	; 0x18
    3c10:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    3c14:	dc 01       	movw	r26, r24
    3c16:	cb 01       	movw	r24, r22
    3c18:	9c 8b       	std	Y+20, r25	; 0x14
    3c1a:	8b 8b       	std	Y+19, r24	; 0x13
    3c1c:	8b 89       	ldd	r24, Y+19	; 0x13
    3c1e:	9c 89       	ldd	r25, Y+20	; 0x14
    3c20:	98 8b       	std	Y+16, r25	; 0x10
    3c22:	8f 87       	std	Y+15, r24	; 0x0f
    3c24:	8f 85       	ldd	r24, Y+15	; 0x0f
    3c26:	98 89       	ldd	r25, Y+16	; 0x10
    3c28:	01 97       	sbiw	r24, 0x01	; 1
    3c2a:	f1 f7       	brne	.-4      	; 0x3c28 <STEPPER_Unipolar_CCW+0x318>
    3c2c:	98 8b       	std	Y+16, r25	; 0x10
    3c2e:	8f 87       	std	Y+15, r24	; 0x0f
	_delay_ms( DELAY );
	DIO_WritePin(COIL1A,LOW);
    3c30:	84 e1       	ldi	r24, 0x14	; 20
    3c32:	60 e0       	ldi	r22, 0x00	; 0
    3c34:	0e 94 f9 09 	call	0x13f2	; 0x13f2 <DIO_WritePin>
	DIO_WritePin(COIL1B,HIGH);
    3c38:	85 e1       	ldi	r24, 0x15	; 21
    3c3a:	61 e0       	ldi	r22, 0x01	; 1
    3c3c:	0e 94 f9 09 	call	0x13f2	; 0x13f2 <DIO_WritePin>
	DIO_WritePin(COIL2A,LOW);
    3c40:	86 e1       	ldi	r24, 0x16	; 22
    3c42:	60 e0       	ldi	r22, 0x00	; 0
    3c44:	0e 94 f9 09 	call	0x13f2	; 0x13f2 <DIO_WritePin>
	DIO_WritePin(COIL2B,LOW);
    3c48:	87 e1       	ldi	r24, 0x17	; 23
    3c4a:	60 e0       	ldi	r22, 0x00	; 0
    3c4c:	0e 94 f9 09 	call	0x13f2	; 0x13f2 <DIO_WritePin>
    3c50:	80 e0       	ldi	r24, 0x00	; 0
    3c52:	90 e0       	ldi	r25, 0x00	; 0
    3c54:	aa ef       	ldi	r26, 0xFA	; 250
    3c56:	b3 e4       	ldi	r27, 0x43	; 67
    3c58:	8b 87       	std	Y+11, r24	; 0x0b
    3c5a:	9c 87       	std	Y+12, r25	; 0x0c
    3c5c:	ad 87       	std	Y+13, r26	; 0x0d
    3c5e:	be 87       	std	Y+14, r27	; 0x0e
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    3c60:	6b 85       	ldd	r22, Y+11	; 0x0b
    3c62:	7c 85       	ldd	r23, Y+12	; 0x0c
    3c64:	8d 85       	ldd	r24, Y+13	; 0x0d
    3c66:	9e 85       	ldd	r25, Y+14	; 0x0e
    3c68:	20 e0       	ldi	r18, 0x00	; 0
    3c6a:	30 e0       	ldi	r19, 0x00	; 0
    3c6c:	4a ef       	ldi	r20, 0xFA	; 250
    3c6e:	54 e4       	ldi	r21, 0x44	; 68
    3c70:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    3c74:	dc 01       	movw	r26, r24
    3c76:	cb 01       	movw	r24, r22
    3c78:	8f 83       	std	Y+7, r24	; 0x07
    3c7a:	98 87       	std	Y+8, r25	; 0x08
    3c7c:	a9 87       	std	Y+9, r26	; 0x09
    3c7e:	ba 87       	std	Y+10, r27	; 0x0a
	if (__tmp < 1.0)
    3c80:	6f 81       	ldd	r22, Y+7	; 0x07
    3c82:	78 85       	ldd	r23, Y+8	; 0x08
    3c84:	89 85       	ldd	r24, Y+9	; 0x09
    3c86:	9a 85       	ldd	r25, Y+10	; 0x0a
    3c88:	20 e0       	ldi	r18, 0x00	; 0
    3c8a:	30 e0       	ldi	r19, 0x00	; 0
    3c8c:	40 e8       	ldi	r20, 0x80	; 128
    3c8e:	5f e3       	ldi	r21, 0x3F	; 63
    3c90:	0e 94 79 03 	call	0x6f2	; 0x6f2 <__ltsf2>
    3c94:	88 23       	and	r24, r24
    3c96:	2c f4       	brge	.+10     	; 0x3ca2 <STEPPER_Unipolar_CCW+0x392>
		__ticks = 1;
    3c98:	81 e0       	ldi	r24, 0x01	; 1
    3c9a:	90 e0       	ldi	r25, 0x00	; 0
    3c9c:	9e 83       	std	Y+6, r25	; 0x06
    3c9e:	8d 83       	std	Y+5, r24	; 0x05
    3ca0:	3f c0       	rjmp	.+126    	; 0x3d20 <STEPPER_Unipolar_CCW+0x410>
	else if (__tmp > 65535)
    3ca2:	6f 81       	ldd	r22, Y+7	; 0x07
    3ca4:	78 85       	ldd	r23, Y+8	; 0x08
    3ca6:	89 85       	ldd	r24, Y+9	; 0x09
    3ca8:	9a 85       	ldd	r25, Y+10	; 0x0a
    3caa:	20 e0       	ldi	r18, 0x00	; 0
    3cac:	3f ef       	ldi	r19, 0xFF	; 255
    3cae:	4f e7       	ldi	r20, 0x7F	; 127
    3cb0:	57 e4       	ldi	r21, 0x47	; 71
    3cb2:	0e 94 19 03 	call	0x632	; 0x632 <__gtsf2>
    3cb6:	18 16       	cp	r1, r24
    3cb8:	4c f5       	brge	.+82     	; 0x3d0c <STEPPER_Unipolar_CCW+0x3fc>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    3cba:	6b 85       	ldd	r22, Y+11	; 0x0b
    3cbc:	7c 85       	ldd	r23, Y+12	; 0x0c
    3cbe:	8d 85       	ldd	r24, Y+13	; 0x0d
    3cc0:	9e 85       	ldd	r25, Y+14	; 0x0e
    3cc2:	20 e0       	ldi	r18, 0x00	; 0
    3cc4:	30 e0       	ldi	r19, 0x00	; 0
    3cc6:	40 e2       	ldi	r20, 0x20	; 32
    3cc8:	51 e4       	ldi	r21, 0x41	; 65
    3cca:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    3cce:	dc 01       	movw	r26, r24
    3cd0:	cb 01       	movw	r24, r22
    3cd2:	bc 01       	movw	r22, r24
    3cd4:	cd 01       	movw	r24, r26
    3cd6:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    3cda:	dc 01       	movw	r26, r24
    3cdc:	cb 01       	movw	r24, r22
    3cde:	9e 83       	std	Y+6, r25	; 0x06
    3ce0:	8d 83       	std	Y+5, r24	; 0x05
    3ce2:	0f c0       	rjmp	.+30     	; 0x3d02 <STEPPER_Unipolar_CCW+0x3f2>
    3ce4:	88 ec       	ldi	r24, 0xC8	; 200
    3ce6:	90 e0       	ldi	r25, 0x00	; 0
    3ce8:	9c 83       	std	Y+4, r25	; 0x04
    3cea:	8b 83       	std	Y+3, r24	; 0x03
    3cec:	8b 81       	ldd	r24, Y+3	; 0x03
    3cee:	9c 81       	ldd	r25, Y+4	; 0x04
    3cf0:	01 97       	sbiw	r24, 0x01	; 1
    3cf2:	f1 f7       	brne	.-4      	; 0x3cf0 <STEPPER_Unipolar_CCW+0x3e0>
    3cf4:	9c 83       	std	Y+4, r25	; 0x04
    3cf6:	8b 83       	std	Y+3, r24	; 0x03
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    3cf8:	8d 81       	ldd	r24, Y+5	; 0x05
    3cfa:	9e 81       	ldd	r25, Y+6	; 0x06
    3cfc:	01 97       	sbiw	r24, 0x01	; 1
    3cfe:	9e 83       	std	Y+6, r25	; 0x06
    3d00:	8d 83       	std	Y+5, r24	; 0x05
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    3d02:	8d 81       	ldd	r24, Y+5	; 0x05
    3d04:	9e 81       	ldd	r25, Y+6	; 0x06
    3d06:	00 97       	sbiw	r24, 0x00	; 0
    3d08:	69 f7       	brne	.-38     	; 0x3ce4 <STEPPER_Unipolar_CCW+0x3d4>
    3d0a:	14 c0       	rjmp	.+40     	; 0x3d34 <STEPPER_Unipolar_CCW+0x424>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    3d0c:	6f 81       	ldd	r22, Y+7	; 0x07
    3d0e:	78 85       	ldd	r23, Y+8	; 0x08
    3d10:	89 85       	ldd	r24, Y+9	; 0x09
    3d12:	9a 85       	ldd	r25, Y+10	; 0x0a
    3d14:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    3d18:	dc 01       	movw	r26, r24
    3d1a:	cb 01       	movw	r24, r22
    3d1c:	9e 83       	std	Y+6, r25	; 0x06
    3d1e:	8d 83       	std	Y+5, r24	; 0x05
    3d20:	8d 81       	ldd	r24, Y+5	; 0x05
    3d22:	9e 81       	ldd	r25, Y+6	; 0x06
    3d24:	9a 83       	std	Y+2, r25	; 0x02
    3d26:	89 83       	std	Y+1, r24	; 0x01
    3d28:	89 81       	ldd	r24, Y+1	; 0x01
    3d2a:	9a 81       	ldd	r25, Y+2	; 0x02
    3d2c:	01 97       	sbiw	r24, 0x01	; 1
    3d2e:	f1 f7       	brne	.-4      	; 0x3d2c <STEPPER_Unipolar_CCW+0x41c>
    3d30:	9a 83       	std	Y+2, r25	; 0x02
    3d32:	89 83       	std	Y+1, r24	; 0x01
	_delay_ms( DELAY );


}
    3d34:	e8 96       	adiw	r28, 0x38	; 56
    3d36:	0f b6       	in	r0, 0x3f	; 63
    3d38:	f8 94       	cli
    3d3a:	de bf       	out	0x3e, r29	; 62
    3d3c:	0f be       	out	0x3f, r0	; 63
    3d3e:	cd bf       	out	0x3d, r28	; 61
    3d40:	cf 91       	pop	r28
    3d42:	df 91       	pop	r29
    3d44:	08 95       	ret

00003d46 <STEPPER_Unipolar_CW_HS>:

void STEPPER_Unipolar_CW_HS(void)
{
    3d46:	0f 93       	push	r16
    3d48:	1f 93       	push	r17
    3d4a:	df 93       	push	r29
    3d4c:	cf 93       	push	r28
    3d4e:	cd b7       	in	r28, 0x3d	; 61
    3d50:	de b7       	in	r29, 0x3e	; 62
    3d52:	c0 57       	subi	r28, 0x70	; 112
    3d54:	d0 40       	sbci	r29, 0x00	; 0
    3d56:	0f b6       	in	r0, 0x3f	; 63
    3d58:	f8 94       	cli
    3d5a:	de bf       	out	0x3e, r29	; 62
    3d5c:	0f be       	out	0x3f, r0	; 63
    3d5e:	cd bf       	out	0x3d, r28	; 61
	DIO_WritePin(COIL1A,HIGH);
    3d60:	84 e1       	ldi	r24, 0x14	; 20
    3d62:	61 e0       	ldi	r22, 0x01	; 1
    3d64:	0e 94 f9 09 	call	0x13f2	; 0x13f2 <DIO_WritePin>
	DIO_WritePin(COIL1B,LOW);
    3d68:	85 e1       	ldi	r24, 0x15	; 21
    3d6a:	60 e0       	ldi	r22, 0x00	; 0
    3d6c:	0e 94 f9 09 	call	0x13f2	; 0x13f2 <DIO_WritePin>
	DIO_WritePin(COIL2A,LOW);
    3d70:	86 e1       	ldi	r24, 0x16	; 22
    3d72:	60 e0       	ldi	r22, 0x00	; 0
    3d74:	0e 94 f9 09 	call	0x13f2	; 0x13f2 <DIO_WritePin>
	DIO_WritePin(COIL2B,LOW);
    3d78:	87 e1       	ldi	r24, 0x17	; 23
    3d7a:	60 e0       	ldi	r22, 0x00	; 0
    3d7c:	0e 94 f9 09 	call	0x13f2	; 0x13f2 <DIO_WritePin>
    3d80:	fe 01       	movw	r30, r28
    3d82:	e3 59       	subi	r30, 0x93	; 147
    3d84:	ff 4f       	sbci	r31, 0xFF	; 255
    3d86:	80 e0       	ldi	r24, 0x00	; 0
    3d88:	90 e0       	ldi	r25, 0x00	; 0
    3d8a:	aa ef       	ldi	r26, 0xFA	; 250
    3d8c:	b3 e4       	ldi	r27, 0x43	; 67
    3d8e:	80 83       	st	Z, r24
    3d90:	91 83       	std	Z+1, r25	; 0x01
    3d92:	a2 83       	std	Z+2, r26	; 0x02
    3d94:	b3 83       	std	Z+3, r27	; 0x03
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    3d96:	8e 01       	movw	r16, r28
    3d98:	07 59       	subi	r16, 0x97	; 151
    3d9a:	1f 4f       	sbci	r17, 0xFF	; 255
    3d9c:	fe 01       	movw	r30, r28
    3d9e:	e3 59       	subi	r30, 0x93	; 147
    3da0:	ff 4f       	sbci	r31, 0xFF	; 255
    3da2:	60 81       	ld	r22, Z
    3da4:	71 81       	ldd	r23, Z+1	; 0x01
    3da6:	82 81       	ldd	r24, Z+2	; 0x02
    3da8:	93 81       	ldd	r25, Z+3	; 0x03
    3daa:	20 e0       	ldi	r18, 0x00	; 0
    3dac:	30 e0       	ldi	r19, 0x00	; 0
    3dae:	4a ef       	ldi	r20, 0xFA	; 250
    3db0:	54 e4       	ldi	r21, 0x44	; 68
    3db2:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    3db6:	dc 01       	movw	r26, r24
    3db8:	cb 01       	movw	r24, r22
    3dba:	f8 01       	movw	r30, r16
    3dbc:	80 83       	st	Z, r24
    3dbe:	91 83       	std	Z+1, r25	; 0x01
    3dc0:	a2 83       	std	Z+2, r26	; 0x02
    3dc2:	b3 83       	std	Z+3, r27	; 0x03
	if (__tmp < 1.0)
    3dc4:	fe 01       	movw	r30, r28
    3dc6:	e7 59       	subi	r30, 0x97	; 151
    3dc8:	ff 4f       	sbci	r31, 0xFF	; 255
    3dca:	60 81       	ld	r22, Z
    3dcc:	71 81       	ldd	r23, Z+1	; 0x01
    3dce:	82 81       	ldd	r24, Z+2	; 0x02
    3dd0:	93 81       	ldd	r25, Z+3	; 0x03
    3dd2:	20 e0       	ldi	r18, 0x00	; 0
    3dd4:	30 e0       	ldi	r19, 0x00	; 0
    3dd6:	40 e8       	ldi	r20, 0x80	; 128
    3dd8:	5f e3       	ldi	r21, 0x3F	; 63
    3dda:	0e 94 79 03 	call	0x6f2	; 0x6f2 <__ltsf2>
    3dde:	88 23       	and	r24, r24
    3de0:	44 f4       	brge	.+16     	; 0x3df2 <STEPPER_Unipolar_CW_HS+0xac>
		__ticks = 1;
    3de2:	fe 01       	movw	r30, r28
    3de4:	e9 59       	subi	r30, 0x99	; 153
    3de6:	ff 4f       	sbci	r31, 0xFF	; 255
    3de8:	81 e0       	ldi	r24, 0x01	; 1
    3dea:	90 e0       	ldi	r25, 0x00	; 0
    3dec:	91 83       	std	Z+1, r25	; 0x01
    3dee:	80 83       	st	Z, r24
    3df0:	64 c0       	rjmp	.+200    	; 0x3eba <STEPPER_Unipolar_CW_HS+0x174>
	else if (__tmp > 65535)
    3df2:	fe 01       	movw	r30, r28
    3df4:	e7 59       	subi	r30, 0x97	; 151
    3df6:	ff 4f       	sbci	r31, 0xFF	; 255
    3df8:	60 81       	ld	r22, Z
    3dfa:	71 81       	ldd	r23, Z+1	; 0x01
    3dfc:	82 81       	ldd	r24, Z+2	; 0x02
    3dfe:	93 81       	ldd	r25, Z+3	; 0x03
    3e00:	20 e0       	ldi	r18, 0x00	; 0
    3e02:	3f ef       	ldi	r19, 0xFF	; 255
    3e04:	4f e7       	ldi	r20, 0x7F	; 127
    3e06:	57 e4       	ldi	r21, 0x47	; 71
    3e08:	0e 94 19 03 	call	0x632	; 0x632 <__gtsf2>
    3e0c:	18 16       	cp	r1, r24
    3e0e:	0c f0       	brlt	.+2      	; 0x3e12 <STEPPER_Unipolar_CW_HS+0xcc>
    3e10:	43 c0       	rjmp	.+134    	; 0x3e98 <STEPPER_Unipolar_CW_HS+0x152>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    3e12:	fe 01       	movw	r30, r28
    3e14:	e3 59       	subi	r30, 0x93	; 147
    3e16:	ff 4f       	sbci	r31, 0xFF	; 255
    3e18:	60 81       	ld	r22, Z
    3e1a:	71 81       	ldd	r23, Z+1	; 0x01
    3e1c:	82 81       	ldd	r24, Z+2	; 0x02
    3e1e:	93 81       	ldd	r25, Z+3	; 0x03
    3e20:	20 e0       	ldi	r18, 0x00	; 0
    3e22:	30 e0       	ldi	r19, 0x00	; 0
    3e24:	40 e2       	ldi	r20, 0x20	; 32
    3e26:	51 e4       	ldi	r21, 0x41	; 65
    3e28:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    3e2c:	dc 01       	movw	r26, r24
    3e2e:	cb 01       	movw	r24, r22
    3e30:	8e 01       	movw	r16, r28
    3e32:	09 59       	subi	r16, 0x99	; 153
    3e34:	1f 4f       	sbci	r17, 0xFF	; 255
    3e36:	bc 01       	movw	r22, r24
    3e38:	cd 01       	movw	r24, r26
    3e3a:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    3e3e:	dc 01       	movw	r26, r24
    3e40:	cb 01       	movw	r24, r22
    3e42:	f8 01       	movw	r30, r16
    3e44:	91 83       	std	Z+1, r25	; 0x01
    3e46:	80 83       	st	Z, r24
    3e48:	1f c0       	rjmp	.+62     	; 0x3e88 <STEPPER_Unipolar_CW_HS+0x142>
    3e4a:	fe 01       	movw	r30, r28
    3e4c:	eb 59       	subi	r30, 0x9B	; 155
    3e4e:	ff 4f       	sbci	r31, 0xFF	; 255
    3e50:	88 ec       	ldi	r24, 0xC8	; 200
    3e52:	90 e0       	ldi	r25, 0x00	; 0
    3e54:	91 83       	std	Z+1, r25	; 0x01
    3e56:	80 83       	st	Z, r24
    3e58:	fe 01       	movw	r30, r28
    3e5a:	eb 59       	subi	r30, 0x9B	; 155
    3e5c:	ff 4f       	sbci	r31, 0xFF	; 255
    3e5e:	80 81       	ld	r24, Z
    3e60:	91 81       	ldd	r25, Z+1	; 0x01
    3e62:	01 97       	sbiw	r24, 0x01	; 1
    3e64:	f1 f7       	brne	.-4      	; 0x3e62 <STEPPER_Unipolar_CW_HS+0x11c>
    3e66:	fe 01       	movw	r30, r28
    3e68:	eb 59       	subi	r30, 0x9B	; 155
    3e6a:	ff 4f       	sbci	r31, 0xFF	; 255
    3e6c:	91 83       	std	Z+1, r25	; 0x01
    3e6e:	80 83       	st	Z, r24
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    3e70:	de 01       	movw	r26, r28
    3e72:	a9 59       	subi	r26, 0x99	; 153
    3e74:	bf 4f       	sbci	r27, 0xFF	; 255
    3e76:	fe 01       	movw	r30, r28
    3e78:	e9 59       	subi	r30, 0x99	; 153
    3e7a:	ff 4f       	sbci	r31, 0xFF	; 255
    3e7c:	80 81       	ld	r24, Z
    3e7e:	91 81       	ldd	r25, Z+1	; 0x01
    3e80:	01 97       	sbiw	r24, 0x01	; 1
    3e82:	11 96       	adiw	r26, 0x01	; 1
    3e84:	9c 93       	st	X, r25
    3e86:	8e 93       	st	-X, r24
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    3e88:	fe 01       	movw	r30, r28
    3e8a:	e9 59       	subi	r30, 0x99	; 153
    3e8c:	ff 4f       	sbci	r31, 0xFF	; 255
    3e8e:	80 81       	ld	r24, Z
    3e90:	91 81       	ldd	r25, Z+1	; 0x01
    3e92:	00 97       	sbiw	r24, 0x00	; 0
    3e94:	d1 f6       	brne	.-76     	; 0x3e4a <STEPPER_Unipolar_CW_HS+0x104>
    3e96:	27 c0       	rjmp	.+78     	; 0x3ee6 <STEPPER_Unipolar_CW_HS+0x1a0>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    3e98:	8e 01       	movw	r16, r28
    3e9a:	09 59       	subi	r16, 0x99	; 153
    3e9c:	1f 4f       	sbci	r17, 0xFF	; 255
    3e9e:	fe 01       	movw	r30, r28
    3ea0:	e7 59       	subi	r30, 0x97	; 151
    3ea2:	ff 4f       	sbci	r31, 0xFF	; 255
    3ea4:	60 81       	ld	r22, Z
    3ea6:	71 81       	ldd	r23, Z+1	; 0x01
    3ea8:	82 81       	ldd	r24, Z+2	; 0x02
    3eaa:	93 81       	ldd	r25, Z+3	; 0x03
    3eac:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    3eb0:	dc 01       	movw	r26, r24
    3eb2:	cb 01       	movw	r24, r22
    3eb4:	f8 01       	movw	r30, r16
    3eb6:	91 83       	std	Z+1, r25	; 0x01
    3eb8:	80 83       	st	Z, r24
    3eba:	de 01       	movw	r26, r28
    3ebc:	ad 59       	subi	r26, 0x9D	; 157
    3ebe:	bf 4f       	sbci	r27, 0xFF	; 255
    3ec0:	fe 01       	movw	r30, r28
    3ec2:	e9 59       	subi	r30, 0x99	; 153
    3ec4:	ff 4f       	sbci	r31, 0xFF	; 255
    3ec6:	80 81       	ld	r24, Z
    3ec8:	91 81       	ldd	r25, Z+1	; 0x01
    3eca:	8d 93       	st	X+, r24
    3ecc:	9c 93       	st	X, r25
    3ece:	fe 01       	movw	r30, r28
    3ed0:	ed 59       	subi	r30, 0x9D	; 157
    3ed2:	ff 4f       	sbci	r31, 0xFF	; 255
    3ed4:	80 81       	ld	r24, Z
    3ed6:	91 81       	ldd	r25, Z+1	; 0x01
    3ed8:	01 97       	sbiw	r24, 0x01	; 1
    3eda:	f1 f7       	brne	.-4      	; 0x3ed8 <STEPPER_Unipolar_CW_HS+0x192>
    3edc:	fe 01       	movw	r30, r28
    3ede:	ed 59       	subi	r30, 0x9D	; 157
    3ee0:	ff 4f       	sbci	r31, 0xFF	; 255
    3ee2:	91 83       	std	Z+1, r25	; 0x01
    3ee4:	80 83       	st	Z, r24
	_delay_ms( DELAY );
	DIO_WritePin(COIL1A,HIGH);
    3ee6:	84 e1       	ldi	r24, 0x14	; 20
    3ee8:	61 e0       	ldi	r22, 0x01	; 1
    3eea:	0e 94 f9 09 	call	0x13f2	; 0x13f2 <DIO_WritePin>
	DIO_WritePin(COIL1B,HIGH);
    3eee:	85 e1       	ldi	r24, 0x15	; 21
    3ef0:	61 e0       	ldi	r22, 0x01	; 1
    3ef2:	0e 94 f9 09 	call	0x13f2	; 0x13f2 <DIO_WritePin>
	DIO_WritePin(COIL2A,LOW);
    3ef6:	86 e1       	ldi	r24, 0x16	; 22
    3ef8:	60 e0       	ldi	r22, 0x00	; 0
    3efa:	0e 94 f9 09 	call	0x13f2	; 0x13f2 <DIO_WritePin>
	DIO_WritePin(COIL2B,LOW);
    3efe:	87 e1       	ldi	r24, 0x17	; 23
    3f00:	60 e0       	ldi	r22, 0x00	; 0
    3f02:	0e 94 f9 09 	call	0x13f2	; 0x13f2 <DIO_WritePin>
    3f06:	fe 01       	movw	r30, r28
    3f08:	e1 5a       	subi	r30, 0xA1	; 161
    3f0a:	ff 4f       	sbci	r31, 0xFF	; 255
    3f0c:	80 e0       	ldi	r24, 0x00	; 0
    3f0e:	90 e0       	ldi	r25, 0x00	; 0
    3f10:	aa ef       	ldi	r26, 0xFA	; 250
    3f12:	b3 e4       	ldi	r27, 0x43	; 67
    3f14:	80 83       	st	Z, r24
    3f16:	91 83       	std	Z+1, r25	; 0x01
    3f18:	a2 83       	std	Z+2, r26	; 0x02
    3f1a:	b3 83       	std	Z+3, r27	; 0x03
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    3f1c:	8e 01       	movw	r16, r28
    3f1e:	05 5a       	subi	r16, 0xA5	; 165
    3f20:	1f 4f       	sbci	r17, 0xFF	; 255
    3f22:	fe 01       	movw	r30, r28
    3f24:	e1 5a       	subi	r30, 0xA1	; 161
    3f26:	ff 4f       	sbci	r31, 0xFF	; 255
    3f28:	60 81       	ld	r22, Z
    3f2a:	71 81       	ldd	r23, Z+1	; 0x01
    3f2c:	82 81       	ldd	r24, Z+2	; 0x02
    3f2e:	93 81       	ldd	r25, Z+3	; 0x03
    3f30:	20 e0       	ldi	r18, 0x00	; 0
    3f32:	30 e0       	ldi	r19, 0x00	; 0
    3f34:	4a ef       	ldi	r20, 0xFA	; 250
    3f36:	54 e4       	ldi	r21, 0x44	; 68
    3f38:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    3f3c:	dc 01       	movw	r26, r24
    3f3e:	cb 01       	movw	r24, r22
    3f40:	f8 01       	movw	r30, r16
    3f42:	80 83       	st	Z, r24
    3f44:	91 83       	std	Z+1, r25	; 0x01
    3f46:	a2 83       	std	Z+2, r26	; 0x02
    3f48:	b3 83       	std	Z+3, r27	; 0x03
	if (__tmp < 1.0)
    3f4a:	fe 01       	movw	r30, r28
    3f4c:	e5 5a       	subi	r30, 0xA5	; 165
    3f4e:	ff 4f       	sbci	r31, 0xFF	; 255
    3f50:	60 81       	ld	r22, Z
    3f52:	71 81       	ldd	r23, Z+1	; 0x01
    3f54:	82 81       	ldd	r24, Z+2	; 0x02
    3f56:	93 81       	ldd	r25, Z+3	; 0x03
    3f58:	20 e0       	ldi	r18, 0x00	; 0
    3f5a:	30 e0       	ldi	r19, 0x00	; 0
    3f5c:	40 e8       	ldi	r20, 0x80	; 128
    3f5e:	5f e3       	ldi	r21, 0x3F	; 63
    3f60:	0e 94 79 03 	call	0x6f2	; 0x6f2 <__ltsf2>
    3f64:	88 23       	and	r24, r24
    3f66:	44 f4       	brge	.+16     	; 0x3f78 <STEPPER_Unipolar_CW_HS+0x232>
		__ticks = 1;
    3f68:	fe 01       	movw	r30, r28
    3f6a:	e7 5a       	subi	r30, 0xA7	; 167
    3f6c:	ff 4f       	sbci	r31, 0xFF	; 255
    3f6e:	81 e0       	ldi	r24, 0x01	; 1
    3f70:	90 e0       	ldi	r25, 0x00	; 0
    3f72:	91 83       	std	Z+1, r25	; 0x01
    3f74:	80 83       	st	Z, r24
    3f76:	64 c0       	rjmp	.+200    	; 0x4040 <STEPPER_Unipolar_CW_HS+0x2fa>
	else if (__tmp > 65535)
    3f78:	fe 01       	movw	r30, r28
    3f7a:	e5 5a       	subi	r30, 0xA5	; 165
    3f7c:	ff 4f       	sbci	r31, 0xFF	; 255
    3f7e:	60 81       	ld	r22, Z
    3f80:	71 81       	ldd	r23, Z+1	; 0x01
    3f82:	82 81       	ldd	r24, Z+2	; 0x02
    3f84:	93 81       	ldd	r25, Z+3	; 0x03
    3f86:	20 e0       	ldi	r18, 0x00	; 0
    3f88:	3f ef       	ldi	r19, 0xFF	; 255
    3f8a:	4f e7       	ldi	r20, 0x7F	; 127
    3f8c:	57 e4       	ldi	r21, 0x47	; 71
    3f8e:	0e 94 19 03 	call	0x632	; 0x632 <__gtsf2>
    3f92:	18 16       	cp	r1, r24
    3f94:	0c f0       	brlt	.+2      	; 0x3f98 <STEPPER_Unipolar_CW_HS+0x252>
    3f96:	43 c0       	rjmp	.+134    	; 0x401e <STEPPER_Unipolar_CW_HS+0x2d8>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    3f98:	fe 01       	movw	r30, r28
    3f9a:	e1 5a       	subi	r30, 0xA1	; 161
    3f9c:	ff 4f       	sbci	r31, 0xFF	; 255
    3f9e:	60 81       	ld	r22, Z
    3fa0:	71 81       	ldd	r23, Z+1	; 0x01
    3fa2:	82 81       	ldd	r24, Z+2	; 0x02
    3fa4:	93 81       	ldd	r25, Z+3	; 0x03
    3fa6:	20 e0       	ldi	r18, 0x00	; 0
    3fa8:	30 e0       	ldi	r19, 0x00	; 0
    3faa:	40 e2       	ldi	r20, 0x20	; 32
    3fac:	51 e4       	ldi	r21, 0x41	; 65
    3fae:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    3fb2:	dc 01       	movw	r26, r24
    3fb4:	cb 01       	movw	r24, r22
    3fb6:	8e 01       	movw	r16, r28
    3fb8:	07 5a       	subi	r16, 0xA7	; 167
    3fba:	1f 4f       	sbci	r17, 0xFF	; 255
    3fbc:	bc 01       	movw	r22, r24
    3fbe:	cd 01       	movw	r24, r26
    3fc0:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    3fc4:	dc 01       	movw	r26, r24
    3fc6:	cb 01       	movw	r24, r22
    3fc8:	f8 01       	movw	r30, r16
    3fca:	91 83       	std	Z+1, r25	; 0x01
    3fcc:	80 83       	st	Z, r24
    3fce:	1f c0       	rjmp	.+62     	; 0x400e <STEPPER_Unipolar_CW_HS+0x2c8>
    3fd0:	fe 01       	movw	r30, r28
    3fd2:	e9 5a       	subi	r30, 0xA9	; 169
    3fd4:	ff 4f       	sbci	r31, 0xFF	; 255
    3fd6:	88 ec       	ldi	r24, 0xC8	; 200
    3fd8:	90 e0       	ldi	r25, 0x00	; 0
    3fda:	91 83       	std	Z+1, r25	; 0x01
    3fdc:	80 83       	st	Z, r24
    3fde:	fe 01       	movw	r30, r28
    3fe0:	e9 5a       	subi	r30, 0xA9	; 169
    3fe2:	ff 4f       	sbci	r31, 0xFF	; 255
    3fe4:	80 81       	ld	r24, Z
    3fe6:	91 81       	ldd	r25, Z+1	; 0x01
    3fe8:	01 97       	sbiw	r24, 0x01	; 1
    3fea:	f1 f7       	brne	.-4      	; 0x3fe8 <STEPPER_Unipolar_CW_HS+0x2a2>
    3fec:	fe 01       	movw	r30, r28
    3fee:	e9 5a       	subi	r30, 0xA9	; 169
    3ff0:	ff 4f       	sbci	r31, 0xFF	; 255
    3ff2:	91 83       	std	Z+1, r25	; 0x01
    3ff4:	80 83       	st	Z, r24
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    3ff6:	de 01       	movw	r26, r28
    3ff8:	a7 5a       	subi	r26, 0xA7	; 167
    3ffa:	bf 4f       	sbci	r27, 0xFF	; 255
    3ffc:	fe 01       	movw	r30, r28
    3ffe:	e7 5a       	subi	r30, 0xA7	; 167
    4000:	ff 4f       	sbci	r31, 0xFF	; 255
    4002:	80 81       	ld	r24, Z
    4004:	91 81       	ldd	r25, Z+1	; 0x01
    4006:	01 97       	sbiw	r24, 0x01	; 1
    4008:	11 96       	adiw	r26, 0x01	; 1
    400a:	9c 93       	st	X, r25
    400c:	8e 93       	st	-X, r24
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    400e:	fe 01       	movw	r30, r28
    4010:	e7 5a       	subi	r30, 0xA7	; 167
    4012:	ff 4f       	sbci	r31, 0xFF	; 255
    4014:	80 81       	ld	r24, Z
    4016:	91 81       	ldd	r25, Z+1	; 0x01
    4018:	00 97       	sbiw	r24, 0x00	; 0
    401a:	d1 f6       	brne	.-76     	; 0x3fd0 <STEPPER_Unipolar_CW_HS+0x28a>
    401c:	27 c0       	rjmp	.+78     	; 0x406c <STEPPER_Unipolar_CW_HS+0x326>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    401e:	8e 01       	movw	r16, r28
    4020:	07 5a       	subi	r16, 0xA7	; 167
    4022:	1f 4f       	sbci	r17, 0xFF	; 255
    4024:	fe 01       	movw	r30, r28
    4026:	e5 5a       	subi	r30, 0xA5	; 165
    4028:	ff 4f       	sbci	r31, 0xFF	; 255
    402a:	60 81       	ld	r22, Z
    402c:	71 81       	ldd	r23, Z+1	; 0x01
    402e:	82 81       	ldd	r24, Z+2	; 0x02
    4030:	93 81       	ldd	r25, Z+3	; 0x03
    4032:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    4036:	dc 01       	movw	r26, r24
    4038:	cb 01       	movw	r24, r22
    403a:	f8 01       	movw	r30, r16
    403c:	91 83       	std	Z+1, r25	; 0x01
    403e:	80 83       	st	Z, r24
    4040:	de 01       	movw	r26, r28
    4042:	ab 5a       	subi	r26, 0xAB	; 171
    4044:	bf 4f       	sbci	r27, 0xFF	; 255
    4046:	fe 01       	movw	r30, r28
    4048:	e7 5a       	subi	r30, 0xA7	; 167
    404a:	ff 4f       	sbci	r31, 0xFF	; 255
    404c:	80 81       	ld	r24, Z
    404e:	91 81       	ldd	r25, Z+1	; 0x01
    4050:	8d 93       	st	X+, r24
    4052:	9c 93       	st	X, r25
    4054:	fe 01       	movw	r30, r28
    4056:	eb 5a       	subi	r30, 0xAB	; 171
    4058:	ff 4f       	sbci	r31, 0xFF	; 255
    405a:	80 81       	ld	r24, Z
    405c:	91 81       	ldd	r25, Z+1	; 0x01
    405e:	01 97       	sbiw	r24, 0x01	; 1
    4060:	f1 f7       	brne	.-4      	; 0x405e <STEPPER_Unipolar_CW_HS+0x318>
    4062:	fe 01       	movw	r30, r28
    4064:	eb 5a       	subi	r30, 0xAB	; 171
    4066:	ff 4f       	sbci	r31, 0xFF	; 255
    4068:	91 83       	std	Z+1, r25	; 0x01
    406a:	80 83       	st	Z, r24
	_delay_ms( DELAY );
	DIO_WritePin(COIL1A,LOW);
    406c:	84 e1       	ldi	r24, 0x14	; 20
    406e:	60 e0       	ldi	r22, 0x00	; 0
    4070:	0e 94 f9 09 	call	0x13f2	; 0x13f2 <DIO_WritePin>
	DIO_WritePin(COIL1B,HIGH);
    4074:	85 e1       	ldi	r24, 0x15	; 21
    4076:	61 e0       	ldi	r22, 0x01	; 1
    4078:	0e 94 f9 09 	call	0x13f2	; 0x13f2 <DIO_WritePin>
	DIO_WritePin(COIL2A,LOW);
    407c:	86 e1       	ldi	r24, 0x16	; 22
    407e:	60 e0       	ldi	r22, 0x00	; 0
    4080:	0e 94 f9 09 	call	0x13f2	; 0x13f2 <DIO_WritePin>
	DIO_WritePin(COIL2B,LOW);
    4084:	87 e1       	ldi	r24, 0x17	; 23
    4086:	60 e0       	ldi	r22, 0x00	; 0
    4088:	0e 94 f9 09 	call	0x13f2	; 0x13f2 <DIO_WritePin>
    408c:	fe 01       	movw	r30, r28
    408e:	ef 5a       	subi	r30, 0xAF	; 175
    4090:	ff 4f       	sbci	r31, 0xFF	; 255
    4092:	80 e0       	ldi	r24, 0x00	; 0
    4094:	90 e0       	ldi	r25, 0x00	; 0
    4096:	aa ef       	ldi	r26, 0xFA	; 250
    4098:	b3 e4       	ldi	r27, 0x43	; 67
    409a:	80 83       	st	Z, r24
    409c:	91 83       	std	Z+1, r25	; 0x01
    409e:	a2 83       	std	Z+2, r26	; 0x02
    40a0:	b3 83       	std	Z+3, r27	; 0x03
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    40a2:	8e 01       	movw	r16, r28
    40a4:	03 5b       	subi	r16, 0xB3	; 179
    40a6:	1f 4f       	sbci	r17, 0xFF	; 255
    40a8:	fe 01       	movw	r30, r28
    40aa:	ef 5a       	subi	r30, 0xAF	; 175
    40ac:	ff 4f       	sbci	r31, 0xFF	; 255
    40ae:	60 81       	ld	r22, Z
    40b0:	71 81       	ldd	r23, Z+1	; 0x01
    40b2:	82 81       	ldd	r24, Z+2	; 0x02
    40b4:	93 81       	ldd	r25, Z+3	; 0x03
    40b6:	20 e0       	ldi	r18, 0x00	; 0
    40b8:	30 e0       	ldi	r19, 0x00	; 0
    40ba:	4a ef       	ldi	r20, 0xFA	; 250
    40bc:	54 e4       	ldi	r21, 0x44	; 68
    40be:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    40c2:	dc 01       	movw	r26, r24
    40c4:	cb 01       	movw	r24, r22
    40c6:	f8 01       	movw	r30, r16
    40c8:	80 83       	st	Z, r24
    40ca:	91 83       	std	Z+1, r25	; 0x01
    40cc:	a2 83       	std	Z+2, r26	; 0x02
    40ce:	b3 83       	std	Z+3, r27	; 0x03
	if (__tmp < 1.0)
    40d0:	fe 01       	movw	r30, r28
    40d2:	e3 5b       	subi	r30, 0xB3	; 179
    40d4:	ff 4f       	sbci	r31, 0xFF	; 255
    40d6:	60 81       	ld	r22, Z
    40d8:	71 81       	ldd	r23, Z+1	; 0x01
    40da:	82 81       	ldd	r24, Z+2	; 0x02
    40dc:	93 81       	ldd	r25, Z+3	; 0x03
    40de:	20 e0       	ldi	r18, 0x00	; 0
    40e0:	30 e0       	ldi	r19, 0x00	; 0
    40e2:	40 e8       	ldi	r20, 0x80	; 128
    40e4:	5f e3       	ldi	r21, 0x3F	; 63
    40e6:	0e 94 79 03 	call	0x6f2	; 0x6f2 <__ltsf2>
    40ea:	88 23       	and	r24, r24
    40ec:	44 f4       	brge	.+16     	; 0x40fe <STEPPER_Unipolar_CW_HS+0x3b8>
		__ticks = 1;
    40ee:	fe 01       	movw	r30, r28
    40f0:	e5 5b       	subi	r30, 0xB5	; 181
    40f2:	ff 4f       	sbci	r31, 0xFF	; 255
    40f4:	81 e0       	ldi	r24, 0x01	; 1
    40f6:	90 e0       	ldi	r25, 0x00	; 0
    40f8:	91 83       	std	Z+1, r25	; 0x01
    40fa:	80 83       	st	Z, r24
    40fc:	64 c0       	rjmp	.+200    	; 0x41c6 <STEPPER_Unipolar_CW_HS+0x480>
	else if (__tmp > 65535)
    40fe:	fe 01       	movw	r30, r28
    4100:	e3 5b       	subi	r30, 0xB3	; 179
    4102:	ff 4f       	sbci	r31, 0xFF	; 255
    4104:	60 81       	ld	r22, Z
    4106:	71 81       	ldd	r23, Z+1	; 0x01
    4108:	82 81       	ldd	r24, Z+2	; 0x02
    410a:	93 81       	ldd	r25, Z+3	; 0x03
    410c:	20 e0       	ldi	r18, 0x00	; 0
    410e:	3f ef       	ldi	r19, 0xFF	; 255
    4110:	4f e7       	ldi	r20, 0x7F	; 127
    4112:	57 e4       	ldi	r21, 0x47	; 71
    4114:	0e 94 19 03 	call	0x632	; 0x632 <__gtsf2>
    4118:	18 16       	cp	r1, r24
    411a:	0c f0       	brlt	.+2      	; 0x411e <STEPPER_Unipolar_CW_HS+0x3d8>
    411c:	43 c0       	rjmp	.+134    	; 0x41a4 <STEPPER_Unipolar_CW_HS+0x45e>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    411e:	fe 01       	movw	r30, r28
    4120:	ef 5a       	subi	r30, 0xAF	; 175
    4122:	ff 4f       	sbci	r31, 0xFF	; 255
    4124:	60 81       	ld	r22, Z
    4126:	71 81       	ldd	r23, Z+1	; 0x01
    4128:	82 81       	ldd	r24, Z+2	; 0x02
    412a:	93 81       	ldd	r25, Z+3	; 0x03
    412c:	20 e0       	ldi	r18, 0x00	; 0
    412e:	30 e0       	ldi	r19, 0x00	; 0
    4130:	40 e2       	ldi	r20, 0x20	; 32
    4132:	51 e4       	ldi	r21, 0x41	; 65
    4134:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    4138:	dc 01       	movw	r26, r24
    413a:	cb 01       	movw	r24, r22
    413c:	8e 01       	movw	r16, r28
    413e:	05 5b       	subi	r16, 0xB5	; 181
    4140:	1f 4f       	sbci	r17, 0xFF	; 255
    4142:	bc 01       	movw	r22, r24
    4144:	cd 01       	movw	r24, r26
    4146:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    414a:	dc 01       	movw	r26, r24
    414c:	cb 01       	movw	r24, r22
    414e:	f8 01       	movw	r30, r16
    4150:	91 83       	std	Z+1, r25	; 0x01
    4152:	80 83       	st	Z, r24
    4154:	1f c0       	rjmp	.+62     	; 0x4194 <STEPPER_Unipolar_CW_HS+0x44e>
    4156:	fe 01       	movw	r30, r28
    4158:	e7 5b       	subi	r30, 0xB7	; 183
    415a:	ff 4f       	sbci	r31, 0xFF	; 255
    415c:	88 ec       	ldi	r24, 0xC8	; 200
    415e:	90 e0       	ldi	r25, 0x00	; 0
    4160:	91 83       	std	Z+1, r25	; 0x01
    4162:	80 83       	st	Z, r24
    4164:	fe 01       	movw	r30, r28
    4166:	e7 5b       	subi	r30, 0xB7	; 183
    4168:	ff 4f       	sbci	r31, 0xFF	; 255
    416a:	80 81       	ld	r24, Z
    416c:	91 81       	ldd	r25, Z+1	; 0x01
    416e:	01 97       	sbiw	r24, 0x01	; 1
    4170:	f1 f7       	brne	.-4      	; 0x416e <STEPPER_Unipolar_CW_HS+0x428>
    4172:	fe 01       	movw	r30, r28
    4174:	e7 5b       	subi	r30, 0xB7	; 183
    4176:	ff 4f       	sbci	r31, 0xFF	; 255
    4178:	91 83       	std	Z+1, r25	; 0x01
    417a:	80 83       	st	Z, r24
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    417c:	de 01       	movw	r26, r28
    417e:	a5 5b       	subi	r26, 0xB5	; 181
    4180:	bf 4f       	sbci	r27, 0xFF	; 255
    4182:	fe 01       	movw	r30, r28
    4184:	e5 5b       	subi	r30, 0xB5	; 181
    4186:	ff 4f       	sbci	r31, 0xFF	; 255
    4188:	80 81       	ld	r24, Z
    418a:	91 81       	ldd	r25, Z+1	; 0x01
    418c:	01 97       	sbiw	r24, 0x01	; 1
    418e:	11 96       	adiw	r26, 0x01	; 1
    4190:	9c 93       	st	X, r25
    4192:	8e 93       	st	-X, r24
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    4194:	fe 01       	movw	r30, r28
    4196:	e5 5b       	subi	r30, 0xB5	; 181
    4198:	ff 4f       	sbci	r31, 0xFF	; 255
    419a:	80 81       	ld	r24, Z
    419c:	91 81       	ldd	r25, Z+1	; 0x01
    419e:	00 97       	sbiw	r24, 0x00	; 0
    41a0:	d1 f6       	brne	.-76     	; 0x4156 <STEPPER_Unipolar_CW_HS+0x410>
    41a2:	27 c0       	rjmp	.+78     	; 0x41f2 <STEPPER_Unipolar_CW_HS+0x4ac>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    41a4:	8e 01       	movw	r16, r28
    41a6:	05 5b       	subi	r16, 0xB5	; 181
    41a8:	1f 4f       	sbci	r17, 0xFF	; 255
    41aa:	fe 01       	movw	r30, r28
    41ac:	e3 5b       	subi	r30, 0xB3	; 179
    41ae:	ff 4f       	sbci	r31, 0xFF	; 255
    41b0:	60 81       	ld	r22, Z
    41b2:	71 81       	ldd	r23, Z+1	; 0x01
    41b4:	82 81       	ldd	r24, Z+2	; 0x02
    41b6:	93 81       	ldd	r25, Z+3	; 0x03
    41b8:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    41bc:	dc 01       	movw	r26, r24
    41be:	cb 01       	movw	r24, r22
    41c0:	f8 01       	movw	r30, r16
    41c2:	91 83       	std	Z+1, r25	; 0x01
    41c4:	80 83       	st	Z, r24
    41c6:	de 01       	movw	r26, r28
    41c8:	a9 5b       	subi	r26, 0xB9	; 185
    41ca:	bf 4f       	sbci	r27, 0xFF	; 255
    41cc:	fe 01       	movw	r30, r28
    41ce:	e5 5b       	subi	r30, 0xB5	; 181
    41d0:	ff 4f       	sbci	r31, 0xFF	; 255
    41d2:	80 81       	ld	r24, Z
    41d4:	91 81       	ldd	r25, Z+1	; 0x01
    41d6:	8d 93       	st	X+, r24
    41d8:	9c 93       	st	X, r25
    41da:	fe 01       	movw	r30, r28
    41dc:	e9 5b       	subi	r30, 0xB9	; 185
    41de:	ff 4f       	sbci	r31, 0xFF	; 255
    41e0:	80 81       	ld	r24, Z
    41e2:	91 81       	ldd	r25, Z+1	; 0x01
    41e4:	01 97       	sbiw	r24, 0x01	; 1
    41e6:	f1 f7       	brne	.-4      	; 0x41e4 <STEPPER_Unipolar_CW_HS+0x49e>
    41e8:	fe 01       	movw	r30, r28
    41ea:	e9 5b       	subi	r30, 0xB9	; 185
    41ec:	ff 4f       	sbci	r31, 0xFF	; 255
    41ee:	91 83       	std	Z+1, r25	; 0x01
    41f0:	80 83       	st	Z, r24
	_delay_ms( DELAY );
	DIO_WritePin(COIL1A,LOW);
    41f2:	84 e1       	ldi	r24, 0x14	; 20
    41f4:	60 e0       	ldi	r22, 0x00	; 0
    41f6:	0e 94 f9 09 	call	0x13f2	; 0x13f2 <DIO_WritePin>
	DIO_WritePin(COIL1B,HIGH);
    41fa:	85 e1       	ldi	r24, 0x15	; 21
    41fc:	61 e0       	ldi	r22, 0x01	; 1
    41fe:	0e 94 f9 09 	call	0x13f2	; 0x13f2 <DIO_WritePin>
	DIO_WritePin(COIL2A,HIGH);
    4202:	86 e1       	ldi	r24, 0x16	; 22
    4204:	61 e0       	ldi	r22, 0x01	; 1
    4206:	0e 94 f9 09 	call	0x13f2	; 0x13f2 <DIO_WritePin>
	DIO_WritePin(COIL2B,LOW);
    420a:	87 e1       	ldi	r24, 0x17	; 23
    420c:	60 e0       	ldi	r22, 0x00	; 0
    420e:	0e 94 f9 09 	call	0x13f2	; 0x13f2 <DIO_WritePin>
    4212:	fe 01       	movw	r30, r28
    4214:	ed 5b       	subi	r30, 0xBD	; 189
    4216:	ff 4f       	sbci	r31, 0xFF	; 255
    4218:	80 e0       	ldi	r24, 0x00	; 0
    421a:	90 e0       	ldi	r25, 0x00	; 0
    421c:	aa ef       	ldi	r26, 0xFA	; 250
    421e:	b3 e4       	ldi	r27, 0x43	; 67
    4220:	80 83       	st	Z, r24
    4222:	91 83       	std	Z+1, r25	; 0x01
    4224:	a2 83       	std	Z+2, r26	; 0x02
    4226:	b3 83       	std	Z+3, r27	; 0x03
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    4228:	8e 01       	movw	r16, r28
    422a:	01 5c       	subi	r16, 0xC1	; 193
    422c:	1f 4f       	sbci	r17, 0xFF	; 255
    422e:	fe 01       	movw	r30, r28
    4230:	ed 5b       	subi	r30, 0xBD	; 189
    4232:	ff 4f       	sbci	r31, 0xFF	; 255
    4234:	60 81       	ld	r22, Z
    4236:	71 81       	ldd	r23, Z+1	; 0x01
    4238:	82 81       	ldd	r24, Z+2	; 0x02
    423a:	93 81       	ldd	r25, Z+3	; 0x03
    423c:	20 e0       	ldi	r18, 0x00	; 0
    423e:	30 e0       	ldi	r19, 0x00	; 0
    4240:	4a ef       	ldi	r20, 0xFA	; 250
    4242:	54 e4       	ldi	r21, 0x44	; 68
    4244:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    4248:	dc 01       	movw	r26, r24
    424a:	cb 01       	movw	r24, r22
    424c:	f8 01       	movw	r30, r16
    424e:	80 83       	st	Z, r24
    4250:	91 83       	std	Z+1, r25	; 0x01
    4252:	a2 83       	std	Z+2, r26	; 0x02
    4254:	b3 83       	std	Z+3, r27	; 0x03
	if (__tmp < 1.0)
    4256:	fe 01       	movw	r30, r28
    4258:	ff 96       	adiw	r30, 0x3f	; 63
    425a:	60 81       	ld	r22, Z
    425c:	71 81       	ldd	r23, Z+1	; 0x01
    425e:	82 81       	ldd	r24, Z+2	; 0x02
    4260:	93 81       	ldd	r25, Z+3	; 0x03
    4262:	20 e0       	ldi	r18, 0x00	; 0
    4264:	30 e0       	ldi	r19, 0x00	; 0
    4266:	40 e8       	ldi	r20, 0x80	; 128
    4268:	5f e3       	ldi	r21, 0x3F	; 63
    426a:	0e 94 79 03 	call	0x6f2	; 0x6f2 <__ltsf2>
    426e:	88 23       	and	r24, r24
    4270:	2c f4       	brge	.+10     	; 0x427c <STEPPER_Unipolar_CW_HS+0x536>
		__ticks = 1;
    4272:	81 e0       	ldi	r24, 0x01	; 1
    4274:	90 e0       	ldi	r25, 0x00	; 0
    4276:	9e af       	std	Y+62, r25	; 0x3e
    4278:	8d af       	std	Y+61, r24	; 0x3d
    427a:	46 c0       	rjmp	.+140    	; 0x4308 <STEPPER_Unipolar_CW_HS+0x5c2>
	else if (__tmp > 65535)
    427c:	fe 01       	movw	r30, r28
    427e:	ff 96       	adiw	r30, 0x3f	; 63
    4280:	60 81       	ld	r22, Z
    4282:	71 81       	ldd	r23, Z+1	; 0x01
    4284:	82 81       	ldd	r24, Z+2	; 0x02
    4286:	93 81       	ldd	r25, Z+3	; 0x03
    4288:	20 e0       	ldi	r18, 0x00	; 0
    428a:	3f ef       	ldi	r19, 0xFF	; 255
    428c:	4f e7       	ldi	r20, 0x7F	; 127
    428e:	57 e4       	ldi	r21, 0x47	; 71
    4290:	0e 94 19 03 	call	0x632	; 0x632 <__gtsf2>
    4294:	18 16       	cp	r1, r24
    4296:	64 f5       	brge	.+88     	; 0x42f0 <STEPPER_Unipolar_CW_HS+0x5aa>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    4298:	fe 01       	movw	r30, r28
    429a:	ed 5b       	subi	r30, 0xBD	; 189
    429c:	ff 4f       	sbci	r31, 0xFF	; 255
    429e:	60 81       	ld	r22, Z
    42a0:	71 81       	ldd	r23, Z+1	; 0x01
    42a2:	82 81       	ldd	r24, Z+2	; 0x02
    42a4:	93 81       	ldd	r25, Z+3	; 0x03
    42a6:	20 e0       	ldi	r18, 0x00	; 0
    42a8:	30 e0       	ldi	r19, 0x00	; 0
    42aa:	40 e2       	ldi	r20, 0x20	; 32
    42ac:	51 e4       	ldi	r21, 0x41	; 65
    42ae:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    42b2:	dc 01       	movw	r26, r24
    42b4:	cb 01       	movw	r24, r22
    42b6:	bc 01       	movw	r22, r24
    42b8:	cd 01       	movw	r24, r26
    42ba:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    42be:	dc 01       	movw	r26, r24
    42c0:	cb 01       	movw	r24, r22
    42c2:	9e af       	std	Y+62, r25	; 0x3e
    42c4:	8d af       	std	Y+61, r24	; 0x3d
    42c6:	0f c0       	rjmp	.+30     	; 0x42e6 <STEPPER_Unipolar_CW_HS+0x5a0>
    42c8:	88 ec       	ldi	r24, 0xC8	; 200
    42ca:	90 e0       	ldi	r25, 0x00	; 0
    42cc:	9c af       	std	Y+60, r25	; 0x3c
    42ce:	8b af       	std	Y+59, r24	; 0x3b
    42d0:	8b ad       	ldd	r24, Y+59	; 0x3b
    42d2:	9c ad       	ldd	r25, Y+60	; 0x3c
    42d4:	01 97       	sbiw	r24, 0x01	; 1
    42d6:	f1 f7       	brne	.-4      	; 0x42d4 <STEPPER_Unipolar_CW_HS+0x58e>
    42d8:	9c af       	std	Y+60, r25	; 0x3c
    42da:	8b af       	std	Y+59, r24	; 0x3b
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    42dc:	8d ad       	ldd	r24, Y+61	; 0x3d
    42de:	9e ad       	ldd	r25, Y+62	; 0x3e
    42e0:	01 97       	sbiw	r24, 0x01	; 1
    42e2:	9e af       	std	Y+62, r25	; 0x3e
    42e4:	8d af       	std	Y+61, r24	; 0x3d
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    42e6:	8d ad       	ldd	r24, Y+61	; 0x3d
    42e8:	9e ad       	ldd	r25, Y+62	; 0x3e
    42ea:	00 97       	sbiw	r24, 0x00	; 0
    42ec:	69 f7       	brne	.-38     	; 0x42c8 <STEPPER_Unipolar_CW_HS+0x582>
    42ee:	16 c0       	rjmp	.+44     	; 0x431c <STEPPER_Unipolar_CW_HS+0x5d6>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    42f0:	fe 01       	movw	r30, r28
    42f2:	ff 96       	adiw	r30, 0x3f	; 63
    42f4:	60 81       	ld	r22, Z
    42f6:	71 81       	ldd	r23, Z+1	; 0x01
    42f8:	82 81       	ldd	r24, Z+2	; 0x02
    42fa:	93 81       	ldd	r25, Z+3	; 0x03
    42fc:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    4300:	dc 01       	movw	r26, r24
    4302:	cb 01       	movw	r24, r22
    4304:	9e af       	std	Y+62, r25	; 0x3e
    4306:	8d af       	std	Y+61, r24	; 0x3d
    4308:	8d ad       	ldd	r24, Y+61	; 0x3d
    430a:	9e ad       	ldd	r25, Y+62	; 0x3e
    430c:	9a af       	std	Y+58, r25	; 0x3a
    430e:	89 af       	std	Y+57, r24	; 0x39
    4310:	89 ad       	ldd	r24, Y+57	; 0x39
    4312:	9a ad       	ldd	r25, Y+58	; 0x3a
    4314:	01 97       	sbiw	r24, 0x01	; 1
    4316:	f1 f7       	brne	.-4      	; 0x4314 <STEPPER_Unipolar_CW_HS+0x5ce>
    4318:	9a af       	std	Y+58, r25	; 0x3a
    431a:	89 af       	std	Y+57, r24	; 0x39
	_delay_ms( DELAY );
	DIO_WritePin(COIL1A,LOW);
    431c:	84 e1       	ldi	r24, 0x14	; 20
    431e:	60 e0       	ldi	r22, 0x00	; 0
    4320:	0e 94 f9 09 	call	0x13f2	; 0x13f2 <DIO_WritePin>
	DIO_WritePin(COIL1B,LOW);
    4324:	85 e1       	ldi	r24, 0x15	; 21
    4326:	60 e0       	ldi	r22, 0x00	; 0
    4328:	0e 94 f9 09 	call	0x13f2	; 0x13f2 <DIO_WritePin>
	DIO_WritePin(COIL2A,HIGH);
    432c:	86 e1       	ldi	r24, 0x16	; 22
    432e:	61 e0       	ldi	r22, 0x01	; 1
    4330:	0e 94 f9 09 	call	0x13f2	; 0x13f2 <DIO_WritePin>
	DIO_WritePin(COIL2B,LOW);
    4334:	87 e1       	ldi	r24, 0x17	; 23
    4336:	60 e0       	ldi	r22, 0x00	; 0
    4338:	0e 94 f9 09 	call	0x13f2	; 0x13f2 <DIO_WritePin>
    433c:	80 e0       	ldi	r24, 0x00	; 0
    433e:	90 e0       	ldi	r25, 0x00	; 0
    4340:	aa ef       	ldi	r26, 0xFA	; 250
    4342:	b3 e4       	ldi	r27, 0x43	; 67
    4344:	8d ab       	std	Y+53, r24	; 0x35
    4346:	9e ab       	std	Y+54, r25	; 0x36
    4348:	af ab       	std	Y+55, r26	; 0x37
    434a:	b8 af       	std	Y+56, r27	; 0x38
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    434c:	6d a9       	ldd	r22, Y+53	; 0x35
    434e:	7e a9       	ldd	r23, Y+54	; 0x36
    4350:	8f a9       	ldd	r24, Y+55	; 0x37
    4352:	98 ad       	ldd	r25, Y+56	; 0x38
    4354:	20 e0       	ldi	r18, 0x00	; 0
    4356:	30 e0       	ldi	r19, 0x00	; 0
    4358:	4a ef       	ldi	r20, 0xFA	; 250
    435a:	54 e4       	ldi	r21, 0x44	; 68
    435c:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    4360:	dc 01       	movw	r26, r24
    4362:	cb 01       	movw	r24, r22
    4364:	89 ab       	std	Y+49, r24	; 0x31
    4366:	9a ab       	std	Y+50, r25	; 0x32
    4368:	ab ab       	std	Y+51, r26	; 0x33
    436a:	bc ab       	std	Y+52, r27	; 0x34
	if (__tmp < 1.0)
    436c:	69 a9       	ldd	r22, Y+49	; 0x31
    436e:	7a a9       	ldd	r23, Y+50	; 0x32
    4370:	8b a9       	ldd	r24, Y+51	; 0x33
    4372:	9c a9       	ldd	r25, Y+52	; 0x34
    4374:	20 e0       	ldi	r18, 0x00	; 0
    4376:	30 e0       	ldi	r19, 0x00	; 0
    4378:	40 e8       	ldi	r20, 0x80	; 128
    437a:	5f e3       	ldi	r21, 0x3F	; 63
    437c:	0e 94 79 03 	call	0x6f2	; 0x6f2 <__ltsf2>
    4380:	88 23       	and	r24, r24
    4382:	2c f4       	brge	.+10     	; 0x438e <STEPPER_Unipolar_CW_HS+0x648>
		__ticks = 1;
    4384:	81 e0       	ldi	r24, 0x01	; 1
    4386:	90 e0       	ldi	r25, 0x00	; 0
    4388:	98 ab       	std	Y+48, r25	; 0x30
    438a:	8f a7       	std	Y+47, r24	; 0x2f
    438c:	3f c0       	rjmp	.+126    	; 0x440c <STEPPER_Unipolar_CW_HS+0x6c6>
	else if (__tmp > 65535)
    438e:	69 a9       	ldd	r22, Y+49	; 0x31
    4390:	7a a9       	ldd	r23, Y+50	; 0x32
    4392:	8b a9       	ldd	r24, Y+51	; 0x33
    4394:	9c a9       	ldd	r25, Y+52	; 0x34
    4396:	20 e0       	ldi	r18, 0x00	; 0
    4398:	3f ef       	ldi	r19, 0xFF	; 255
    439a:	4f e7       	ldi	r20, 0x7F	; 127
    439c:	57 e4       	ldi	r21, 0x47	; 71
    439e:	0e 94 19 03 	call	0x632	; 0x632 <__gtsf2>
    43a2:	18 16       	cp	r1, r24
    43a4:	4c f5       	brge	.+82     	; 0x43f8 <STEPPER_Unipolar_CW_HS+0x6b2>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    43a6:	6d a9       	ldd	r22, Y+53	; 0x35
    43a8:	7e a9       	ldd	r23, Y+54	; 0x36
    43aa:	8f a9       	ldd	r24, Y+55	; 0x37
    43ac:	98 ad       	ldd	r25, Y+56	; 0x38
    43ae:	20 e0       	ldi	r18, 0x00	; 0
    43b0:	30 e0       	ldi	r19, 0x00	; 0
    43b2:	40 e2       	ldi	r20, 0x20	; 32
    43b4:	51 e4       	ldi	r21, 0x41	; 65
    43b6:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    43ba:	dc 01       	movw	r26, r24
    43bc:	cb 01       	movw	r24, r22
    43be:	bc 01       	movw	r22, r24
    43c0:	cd 01       	movw	r24, r26
    43c2:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    43c6:	dc 01       	movw	r26, r24
    43c8:	cb 01       	movw	r24, r22
    43ca:	98 ab       	std	Y+48, r25	; 0x30
    43cc:	8f a7       	std	Y+47, r24	; 0x2f
    43ce:	0f c0       	rjmp	.+30     	; 0x43ee <STEPPER_Unipolar_CW_HS+0x6a8>
    43d0:	88 ec       	ldi	r24, 0xC8	; 200
    43d2:	90 e0       	ldi	r25, 0x00	; 0
    43d4:	9e a7       	std	Y+46, r25	; 0x2e
    43d6:	8d a7       	std	Y+45, r24	; 0x2d
    43d8:	8d a5       	ldd	r24, Y+45	; 0x2d
    43da:	9e a5       	ldd	r25, Y+46	; 0x2e
    43dc:	01 97       	sbiw	r24, 0x01	; 1
    43de:	f1 f7       	brne	.-4      	; 0x43dc <STEPPER_Unipolar_CW_HS+0x696>
    43e0:	9e a7       	std	Y+46, r25	; 0x2e
    43e2:	8d a7       	std	Y+45, r24	; 0x2d
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    43e4:	8f a5       	ldd	r24, Y+47	; 0x2f
    43e6:	98 a9       	ldd	r25, Y+48	; 0x30
    43e8:	01 97       	sbiw	r24, 0x01	; 1
    43ea:	98 ab       	std	Y+48, r25	; 0x30
    43ec:	8f a7       	std	Y+47, r24	; 0x2f
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    43ee:	8f a5       	ldd	r24, Y+47	; 0x2f
    43f0:	98 a9       	ldd	r25, Y+48	; 0x30
    43f2:	00 97       	sbiw	r24, 0x00	; 0
    43f4:	69 f7       	brne	.-38     	; 0x43d0 <STEPPER_Unipolar_CW_HS+0x68a>
    43f6:	14 c0       	rjmp	.+40     	; 0x4420 <STEPPER_Unipolar_CW_HS+0x6da>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    43f8:	69 a9       	ldd	r22, Y+49	; 0x31
    43fa:	7a a9       	ldd	r23, Y+50	; 0x32
    43fc:	8b a9       	ldd	r24, Y+51	; 0x33
    43fe:	9c a9       	ldd	r25, Y+52	; 0x34
    4400:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    4404:	dc 01       	movw	r26, r24
    4406:	cb 01       	movw	r24, r22
    4408:	98 ab       	std	Y+48, r25	; 0x30
    440a:	8f a7       	std	Y+47, r24	; 0x2f
    440c:	8f a5       	ldd	r24, Y+47	; 0x2f
    440e:	98 a9       	ldd	r25, Y+48	; 0x30
    4410:	9c a7       	std	Y+44, r25	; 0x2c
    4412:	8b a7       	std	Y+43, r24	; 0x2b
    4414:	8b a5       	ldd	r24, Y+43	; 0x2b
    4416:	9c a5       	ldd	r25, Y+44	; 0x2c
    4418:	01 97       	sbiw	r24, 0x01	; 1
    441a:	f1 f7       	brne	.-4      	; 0x4418 <STEPPER_Unipolar_CW_HS+0x6d2>
    441c:	9c a7       	std	Y+44, r25	; 0x2c
    441e:	8b a7       	std	Y+43, r24	; 0x2b
	_delay_ms( DELAY );
	DIO_WritePin(COIL1A,LOW);
    4420:	84 e1       	ldi	r24, 0x14	; 20
    4422:	60 e0       	ldi	r22, 0x00	; 0
    4424:	0e 94 f9 09 	call	0x13f2	; 0x13f2 <DIO_WritePin>
	DIO_WritePin(COIL1B,LOW);
    4428:	85 e1       	ldi	r24, 0x15	; 21
    442a:	60 e0       	ldi	r22, 0x00	; 0
    442c:	0e 94 f9 09 	call	0x13f2	; 0x13f2 <DIO_WritePin>
	DIO_WritePin(COIL2A,HIGH);
    4430:	86 e1       	ldi	r24, 0x16	; 22
    4432:	61 e0       	ldi	r22, 0x01	; 1
    4434:	0e 94 f9 09 	call	0x13f2	; 0x13f2 <DIO_WritePin>
	DIO_WritePin(COIL2B,HIGH);
    4438:	87 e1       	ldi	r24, 0x17	; 23
    443a:	61 e0       	ldi	r22, 0x01	; 1
    443c:	0e 94 f9 09 	call	0x13f2	; 0x13f2 <DIO_WritePin>
    4440:	80 e0       	ldi	r24, 0x00	; 0
    4442:	90 e0       	ldi	r25, 0x00	; 0
    4444:	aa ef       	ldi	r26, 0xFA	; 250
    4446:	b3 e4       	ldi	r27, 0x43	; 67
    4448:	8f a3       	std	Y+39, r24	; 0x27
    444a:	98 a7       	std	Y+40, r25	; 0x28
    444c:	a9 a7       	std	Y+41, r26	; 0x29
    444e:	ba a7       	std	Y+42, r27	; 0x2a
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    4450:	6f a1       	ldd	r22, Y+39	; 0x27
    4452:	78 a5       	ldd	r23, Y+40	; 0x28
    4454:	89 a5       	ldd	r24, Y+41	; 0x29
    4456:	9a a5       	ldd	r25, Y+42	; 0x2a
    4458:	20 e0       	ldi	r18, 0x00	; 0
    445a:	30 e0       	ldi	r19, 0x00	; 0
    445c:	4a ef       	ldi	r20, 0xFA	; 250
    445e:	54 e4       	ldi	r21, 0x44	; 68
    4460:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    4464:	dc 01       	movw	r26, r24
    4466:	cb 01       	movw	r24, r22
    4468:	8b a3       	std	Y+35, r24	; 0x23
    446a:	9c a3       	std	Y+36, r25	; 0x24
    446c:	ad a3       	std	Y+37, r26	; 0x25
    446e:	be a3       	std	Y+38, r27	; 0x26
	if (__tmp < 1.0)
    4470:	6b a1       	ldd	r22, Y+35	; 0x23
    4472:	7c a1       	ldd	r23, Y+36	; 0x24
    4474:	8d a1       	ldd	r24, Y+37	; 0x25
    4476:	9e a1       	ldd	r25, Y+38	; 0x26
    4478:	20 e0       	ldi	r18, 0x00	; 0
    447a:	30 e0       	ldi	r19, 0x00	; 0
    447c:	40 e8       	ldi	r20, 0x80	; 128
    447e:	5f e3       	ldi	r21, 0x3F	; 63
    4480:	0e 94 79 03 	call	0x6f2	; 0x6f2 <__ltsf2>
    4484:	88 23       	and	r24, r24
    4486:	2c f4       	brge	.+10     	; 0x4492 <STEPPER_Unipolar_CW_HS+0x74c>
		__ticks = 1;
    4488:	81 e0       	ldi	r24, 0x01	; 1
    448a:	90 e0       	ldi	r25, 0x00	; 0
    448c:	9a a3       	std	Y+34, r25	; 0x22
    448e:	89 a3       	std	Y+33, r24	; 0x21
    4490:	3f c0       	rjmp	.+126    	; 0x4510 <STEPPER_Unipolar_CW_HS+0x7ca>
	else if (__tmp > 65535)
    4492:	6b a1       	ldd	r22, Y+35	; 0x23
    4494:	7c a1       	ldd	r23, Y+36	; 0x24
    4496:	8d a1       	ldd	r24, Y+37	; 0x25
    4498:	9e a1       	ldd	r25, Y+38	; 0x26
    449a:	20 e0       	ldi	r18, 0x00	; 0
    449c:	3f ef       	ldi	r19, 0xFF	; 255
    449e:	4f e7       	ldi	r20, 0x7F	; 127
    44a0:	57 e4       	ldi	r21, 0x47	; 71
    44a2:	0e 94 19 03 	call	0x632	; 0x632 <__gtsf2>
    44a6:	18 16       	cp	r1, r24
    44a8:	4c f5       	brge	.+82     	; 0x44fc <STEPPER_Unipolar_CW_HS+0x7b6>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    44aa:	6f a1       	ldd	r22, Y+39	; 0x27
    44ac:	78 a5       	ldd	r23, Y+40	; 0x28
    44ae:	89 a5       	ldd	r24, Y+41	; 0x29
    44b0:	9a a5       	ldd	r25, Y+42	; 0x2a
    44b2:	20 e0       	ldi	r18, 0x00	; 0
    44b4:	30 e0       	ldi	r19, 0x00	; 0
    44b6:	40 e2       	ldi	r20, 0x20	; 32
    44b8:	51 e4       	ldi	r21, 0x41	; 65
    44ba:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    44be:	dc 01       	movw	r26, r24
    44c0:	cb 01       	movw	r24, r22
    44c2:	bc 01       	movw	r22, r24
    44c4:	cd 01       	movw	r24, r26
    44c6:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    44ca:	dc 01       	movw	r26, r24
    44cc:	cb 01       	movw	r24, r22
    44ce:	9a a3       	std	Y+34, r25	; 0x22
    44d0:	89 a3       	std	Y+33, r24	; 0x21
    44d2:	0f c0       	rjmp	.+30     	; 0x44f2 <STEPPER_Unipolar_CW_HS+0x7ac>
    44d4:	88 ec       	ldi	r24, 0xC8	; 200
    44d6:	90 e0       	ldi	r25, 0x00	; 0
    44d8:	98 a3       	std	Y+32, r25	; 0x20
    44da:	8f 8f       	std	Y+31, r24	; 0x1f
    44dc:	8f 8d       	ldd	r24, Y+31	; 0x1f
    44de:	98 a1       	ldd	r25, Y+32	; 0x20
    44e0:	01 97       	sbiw	r24, 0x01	; 1
    44e2:	f1 f7       	brne	.-4      	; 0x44e0 <STEPPER_Unipolar_CW_HS+0x79a>
    44e4:	98 a3       	std	Y+32, r25	; 0x20
    44e6:	8f 8f       	std	Y+31, r24	; 0x1f
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    44e8:	89 a1       	ldd	r24, Y+33	; 0x21
    44ea:	9a a1       	ldd	r25, Y+34	; 0x22
    44ec:	01 97       	sbiw	r24, 0x01	; 1
    44ee:	9a a3       	std	Y+34, r25	; 0x22
    44f0:	89 a3       	std	Y+33, r24	; 0x21
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    44f2:	89 a1       	ldd	r24, Y+33	; 0x21
    44f4:	9a a1       	ldd	r25, Y+34	; 0x22
    44f6:	00 97       	sbiw	r24, 0x00	; 0
    44f8:	69 f7       	brne	.-38     	; 0x44d4 <STEPPER_Unipolar_CW_HS+0x78e>
    44fa:	14 c0       	rjmp	.+40     	; 0x4524 <STEPPER_Unipolar_CW_HS+0x7de>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    44fc:	6b a1       	ldd	r22, Y+35	; 0x23
    44fe:	7c a1       	ldd	r23, Y+36	; 0x24
    4500:	8d a1       	ldd	r24, Y+37	; 0x25
    4502:	9e a1       	ldd	r25, Y+38	; 0x26
    4504:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    4508:	dc 01       	movw	r26, r24
    450a:	cb 01       	movw	r24, r22
    450c:	9a a3       	std	Y+34, r25	; 0x22
    450e:	89 a3       	std	Y+33, r24	; 0x21
    4510:	89 a1       	ldd	r24, Y+33	; 0x21
    4512:	9a a1       	ldd	r25, Y+34	; 0x22
    4514:	9e 8f       	std	Y+30, r25	; 0x1e
    4516:	8d 8f       	std	Y+29, r24	; 0x1d
    4518:	8d 8d       	ldd	r24, Y+29	; 0x1d
    451a:	9e 8d       	ldd	r25, Y+30	; 0x1e
    451c:	01 97       	sbiw	r24, 0x01	; 1
    451e:	f1 f7       	brne	.-4      	; 0x451c <STEPPER_Unipolar_CW_HS+0x7d6>
    4520:	9e 8f       	std	Y+30, r25	; 0x1e
    4522:	8d 8f       	std	Y+29, r24	; 0x1d
	_delay_ms( DELAY );
	DIO_WritePin(COIL1A,LOW);
    4524:	84 e1       	ldi	r24, 0x14	; 20
    4526:	60 e0       	ldi	r22, 0x00	; 0
    4528:	0e 94 f9 09 	call	0x13f2	; 0x13f2 <DIO_WritePin>
	DIO_WritePin(COIL1B,LOW);
    452c:	85 e1       	ldi	r24, 0x15	; 21
    452e:	60 e0       	ldi	r22, 0x00	; 0
    4530:	0e 94 f9 09 	call	0x13f2	; 0x13f2 <DIO_WritePin>
	DIO_WritePin(COIL2A,LOW);
    4534:	86 e1       	ldi	r24, 0x16	; 22
    4536:	60 e0       	ldi	r22, 0x00	; 0
    4538:	0e 94 f9 09 	call	0x13f2	; 0x13f2 <DIO_WritePin>
	DIO_WritePin(COIL2B,HIGH);
    453c:	87 e1       	ldi	r24, 0x17	; 23
    453e:	61 e0       	ldi	r22, 0x01	; 1
    4540:	0e 94 f9 09 	call	0x13f2	; 0x13f2 <DIO_WritePin>
    4544:	80 e0       	ldi	r24, 0x00	; 0
    4546:	90 e0       	ldi	r25, 0x00	; 0
    4548:	aa ef       	ldi	r26, 0xFA	; 250
    454a:	b3 e4       	ldi	r27, 0x43	; 67
    454c:	89 8f       	std	Y+25, r24	; 0x19
    454e:	9a 8f       	std	Y+26, r25	; 0x1a
    4550:	ab 8f       	std	Y+27, r26	; 0x1b
    4552:	bc 8f       	std	Y+28, r27	; 0x1c
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    4554:	69 8d       	ldd	r22, Y+25	; 0x19
    4556:	7a 8d       	ldd	r23, Y+26	; 0x1a
    4558:	8b 8d       	ldd	r24, Y+27	; 0x1b
    455a:	9c 8d       	ldd	r25, Y+28	; 0x1c
    455c:	20 e0       	ldi	r18, 0x00	; 0
    455e:	30 e0       	ldi	r19, 0x00	; 0
    4560:	4a ef       	ldi	r20, 0xFA	; 250
    4562:	54 e4       	ldi	r21, 0x44	; 68
    4564:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    4568:	dc 01       	movw	r26, r24
    456a:	cb 01       	movw	r24, r22
    456c:	8d 8b       	std	Y+21, r24	; 0x15
    456e:	9e 8b       	std	Y+22, r25	; 0x16
    4570:	af 8b       	std	Y+23, r26	; 0x17
    4572:	b8 8f       	std	Y+24, r27	; 0x18
	if (__tmp < 1.0)
    4574:	6d 89       	ldd	r22, Y+21	; 0x15
    4576:	7e 89       	ldd	r23, Y+22	; 0x16
    4578:	8f 89       	ldd	r24, Y+23	; 0x17
    457a:	98 8d       	ldd	r25, Y+24	; 0x18
    457c:	20 e0       	ldi	r18, 0x00	; 0
    457e:	30 e0       	ldi	r19, 0x00	; 0
    4580:	40 e8       	ldi	r20, 0x80	; 128
    4582:	5f e3       	ldi	r21, 0x3F	; 63
    4584:	0e 94 79 03 	call	0x6f2	; 0x6f2 <__ltsf2>
    4588:	88 23       	and	r24, r24
    458a:	2c f4       	brge	.+10     	; 0x4596 <STEPPER_Unipolar_CW_HS+0x850>
		__ticks = 1;
    458c:	81 e0       	ldi	r24, 0x01	; 1
    458e:	90 e0       	ldi	r25, 0x00	; 0
    4590:	9c 8b       	std	Y+20, r25	; 0x14
    4592:	8b 8b       	std	Y+19, r24	; 0x13
    4594:	3f c0       	rjmp	.+126    	; 0x4614 <STEPPER_Unipolar_CW_HS+0x8ce>
	else if (__tmp > 65535)
    4596:	6d 89       	ldd	r22, Y+21	; 0x15
    4598:	7e 89       	ldd	r23, Y+22	; 0x16
    459a:	8f 89       	ldd	r24, Y+23	; 0x17
    459c:	98 8d       	ldd	r25, Y+24	; 0x18
    459e:	20 e0       	ldi	r18, 0x00	; 0
    45a0:	3f ef       	ldi	r19, 0xFF	; 255
    45a2:	4f e7       	ldi	r20, 0x7F	; 127
    45a4:	57 e4       	ldi	r21, 0x47	; 71
    45a6:	0e 94 19 03 	call	0x632	; 0x632 <__gtsf2>
    45aa:	18 16       	cp	r1, r24
    45ac:	4c f5       	brge	.+82     	; 0x4600 <STEPPER_Unipolar_CW_HS+0x8ba>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    45ae:	69 8d       	ldd	r22, Y+25	; 0x19
    45b0:	7a 8d       	ldd	r23, Y+26	; 0x1a
    45b2:	8b 8d       	ldd	r24, Y+27	; 0x1b
    45b4:	9c 8d       	ldd	r25, Y+28	; 0x1c
    45b6:	20 e0       	ldi	r18, 0x00	; 0
    45b8:	30 e0       	ldi	r19, 0x00	; 0
    45ba:	40 e2       	ldi	r20, 0x20	; 32
    45bc:	51 e4       	ldi	r21, 0x41	; 65
    45be:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    45c2:	dc 01       	movw	r26, r24
    45c4:	cb 01       	movw	r24, r22
    45c6:	bc 01       	movw	r22, r24
    45c8:	cd 01       	movw	r24, r26
    45ca:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    45ce:	dc 01       	movw	r26, r24
    45d0:	cb 01       	movw	r24, r22
    45d2:	9c 8b       	std	Y+20, r25	; 0x14
    45d4:	8b 8b       	std	Y+19, r24	; 0x13
    45d6:	0f c0       	rjmp	.+30     	; 0x45f6 <STEPPER_Unipolar_CW_HS+0x8b0>
    45d8:	88 ec       	ldi	r24, 0xC8	; 200
    45da:	90 e0       	ldi	r25, 0x00	; 0
    45dc:	9a 8b       	std	Y+18, r25	; 0x12
    45de:	89 8b       	std	Y+17, r24	; 0x11
    45e0:	89 89       	ldd	r24, Y+17	; 0x11
    45e2:	9a 89       	ldd	r25, Y+18	; 0x12
    45e4:	01 97       	sbiw	r24, 0x01	; 1
    45e6:	f1 f7       	brne	.-4      	; 0x45e4 <STEPPER_Unipolar_CW_HS+0x89e>
    45e8:	9a 8b       	std	Y+18, r25	; 0x12
    45ea:	89 8b       	std	Y+17, r24	; 0x11
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    45ec:	8b 89       	ldd	r24, Y+19	; 0x13
    45ee:	9c 89       	ldd	r25, Y+20	; 0x14
    45f0:	01 97       	sbiw	r24, 0x01	; 1
    45f2:	9c 8b       	std	Y+20, r25	; 0x14
    45f4:	8b 8b       	std	Y+19, r24	; 0x13
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    45f6:	8b 89       	ldd	r24, Y+19	; 0x13
    45f8:	9c 89       	ldd	r25, Y+20	; 0x14
    45fa:	00 97       	sbiw	r24, 0x00	; 0
    45fc:	69 f7       	brne	.-38     	; 0x45d8 <STEPPER_Unipolar_CW_HS+0x892>
    45fe:	14 c0       	rjmp	.+40     	; 0x4628 <STEPPER_Unipolar_CW_HS+0x8e2>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    4600:	6d 89       	ldd	r22, Y+21	; 0x15
    4602:	7e 89       	ldd	r23, Y+22	; 0x16
    4604:	8f 89       	ldd	r24, Y+23	; 0x17
    4606:	98 8d       	ldd	r25, Y+24	; 0x18
    4608:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    460c:	dc 01       	movw	r26, r24
    460e:	cb 01       	movw	r24, r22
    4610:	9c 8b       	std	Y+20, r25	; 0x14
    4612:	8b 8b       	std	Y+19, r24	; 0x13
    4614:	8b 89       	ldd	r24, Y+19	; 0x13
    4616:	9c 89       	ldd	r25, Y+20	; 0x14
    4618:	98 8b       	std	Y+16, r25	; 0x10
    461a:	8f 87       	std	Y+15, r24	; 0x0f
    461c:	8f 85       	ldd	r24, Y+15	; 0x0f
    461e:	98 89       	ldd	r25, Y+16	; 0x10
    4620:	01 97       	sbiw	r24, 0x01	; 1
    4622:	f1 f7       	brne	.-4      	; 0x4620 <STEPPER_Unipolar_CW_HS+0x8da>
    4624:	98 8b       	std	Y+16, r25	; 0x10
    4626:	8f 87       	std	Y+15, r24	; 0x0f
	_delay_ms( DELAY );
	DIO_WritePin(COIL1A,HIGH);
    4628:	84 e1       	ldi	r24, 0x14	; 20
    462a:	61 e0       	ldi	r22, 0x01	; 1
    462c:	0e 94 f9 09 	call	0x13f2	; 0x13f2 <DIO_WritePin>
	DIO_WritePin(COIL1B,LOW);
    4630:	85 e1       	ldi	r24, 0x15	; 21
    4632:	60 e0       	ldi	r22, 0x00	; 0
    4634:	0e 94 f9 09 	call	0x13f2	; 0x13f2 <DIO_WritePin>
	DIO_WritePin(COIL2A,LOW);
    4638:	86 e1       	ldi	r24, 0x16	; 22
    463a:	60 e0       	ldi	r22, 0x00	; 0
    463c:	0e 94 f9 09 	call	0x13f2	; 0x13f2 <DIO_WritePin>
	DIO_WritePin(COIL2B,HIGH);
    4640:	87 e1       	ldi	r24, 0x17	; 23
    4642:	61 e0       	ldi	r22, 0x01	; 1
    4644:	0e 94 f9 09 	call	0x13f2	; 0x13f2 <DIO_WritePin>
    4648:	80 e0       	ldi	r24, 0x00	; 0
    464a:	90 e0       	ldi	r25, 0x00	; 0
    464c:	aa ef       	ldi	r26, 0xFA	; 250
    464e:	b3 e4       	ldi	r27, 0x43	; 67
    4650:	8b 87       	std	Y+11, r24	; 0x0b
    4652:	9c 87       	std	Y+12, r25	; 0x0c
    4654:	ad 87       	std	Y+13, r26	; 0x0d
    4656:	be 87       	std	Y+14, r27	; 0x0e
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    4658:	6b 85       	ldd	r22, Y+11	; 0x0b
    465a:	7c 85       	ldd	r23, Y+12	; 0x0c
    465c:	8d 85       	ldd	r24, Y+13	; 0x0d
    465e:	9e 85       	ldd	r25, Y+14	; 0x0e
    4660:	20 e0       	ldi	r18, 0x00	; 0
    4662:	30 e0       	ldi	r19, 0x00	; 0
    4664:	4a ef       	ldi	r20, 0xFA	; 250
    4666:	54 e4       	ldi	r21, 0x44	; 68
    4668:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    466c:	dc 01       	movw	r26, r24
    466e:	cb 01       	movw	r24, r22
    4670:	8f 83       	std	Y+7, r24	; 0x07
    4672:	98 87       	std	Y+8, r25	; 0x08
    4674:	a9 87       	std	Y+9, r26	; 0x09
    4676:	ba 87       	std	Y+10, r27	; 0x0a
	if (__tmp < 1.0)
    4678:	6f 81       	ldd	r22, Y+7	; 0x07
    467a:	78 85       	ldd	r23, Y+8	; 0x08
    467c:	89 85       	ldd	r24, Y+9	; 0x09
    467e:	9a 85       	ldd	r25, Y+10	; 0x0a
    4680:	20 e0       	ldi	r18, 0x00	; 0
    4682:	30 e0       	ldi	r19, 0x00	; 0
    4684:	40 e8       	ldi	r20, 0x80	; 128
    4686:	5f e3       	ldi	r21, 0x3F	; 63
    4688:	0e 94 79 03 	call	0x6f2	; 0x6f2 <__ltsf2>
    468c:	88 23       	and	r24, r24
    468e:	2c f4       	brge	.+10     	; 0x469a <STEPPER_Unipolar_CW_HS+0x954>
		__ticks = 1;
    4690:	81 e0       	ldi	r24, 0x01	; 1
    4692:	90 e0       	ldi	r25, 0x00	; 0
    4694:	9e 83       	std	Y+6, r25	; 0x06
    4696:	8d 83       	std	Y+5, r24	; 0x05
    4698:	3f c0       	rjmp	.+126    	; 0x4718 <STEPPER_Unipolar_CW_HS+0x9d2>
	else if (__tmp > 65535)
    469a:	6f 81       	ldd	r22, Y+7	; 0x07
    469c:	78 85       	ldd	r23, Y+8	; 0x08
    469e:	89 85       	ldd	r24, Y+9	; 0x09
    46a0:	9a 85       	ldd	r25, Y+10	; 0x0a
    46a2:	20 e0       	ldi	r18, 0x00	; 0
    46a4:	3f ef       	ldi	r19, 0xFF	; 255
    46a6:	4f e7       	ldi	r20, 0x7F	; 127
    46a8:	57 e4       	ldi	r21, 0x47	; 71
    46aa:	0e 94 19 03 	call	0x632	; 0x632 <__gtsf2>
    46ae:	18 16       	cp	r1, r24
    46b0:	4c f5       	brge	.+82     	; 0x4704 <STEPPER_Unipolar_CW_HS+0x9be>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    46b2:	6b 85       	ldd	r22, Y+11	; 0x0b
    46b4:	7c 85       	ldd	r23, Y+12	; 0x0c
    46b6:	8d 85       	ldd	r24, Y+13	; 0x0d
    46b8:	9e 85       	ldd	r25, Y+14	; 0x0e
    46ba:	20 e0       	ldi	r18, 0x00	; 0
    46bc:	30 e0       	ldi	r19, 0x00	; 0
    46be:	40 e2       	ldi	r20, 0x20	; 32
    46c0:	51 e4       	ldi	r21, 0x41	; 65
    46c2:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    46c6:	dc 01       	movw	r26, r24
    46c8:	cb 01       	movw	r24, r22
    46ca:	bc 01       	movw	r22, r24
    46cc:	cd 01       	movw	r24, r26
    46ce:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    46d2:	dc 01       	movw	r26, r24
    46d4:	cb 01       	movw	r24, r22
    46d6:	9e 83       	std	Y+6, r25	; 0x06
    46d8:	8d 83       	std	Y+5, r24	; 0x05
    46da:	0f c0       	rjmp	.+30     	; 0x46fa <STEPPER_Unipolar_CW_HS+0x9b4>
    46dc:	88 ec       	ldi	r24, 0xC8	; 200
    46de:	90 e0       	ldi	r25, 0x00	; 0
    46e0:	9c 83       	std	Y+4, r25	; 0x04
    46e2:	8b 83       	std	Y+3, r24	; 0x03
    46e4:	8b 81       	ldd	r24, Y+3	; 0x03
    46e6:	9c 81       	ldd	r25, Y+4	; 0x04
    46e8:	01 97       	sbiw	r24, 0x01	; 1
    46ea:	f1 f7       	brne	.-4      	; 0x46e8 <STEPPER_Unipolar_CW_HS+0x9a2>
    46ec:	9c 83       	std	Y+4, r25	; 0x04
    46ee:	8b 83       	std	Y+3, r24	; 0x03
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    46f0:	8d 81       	ldd	r24, Y+5	; 0x05
    46f2:	9e 81       	ldd	r25, Y+6	; 0x06
    46f4:	01 97       	sbiw	r24, 0x01	; 1
    46f6:	9e 83       	std	Y+6, r25	; 0x06
    46f8:	8d 83       	std	Y+5, r24	; 0x05
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    46fa:	8d 81       	ldd	r24, Y+5	; 0x05
    46fc:	9e 81       	ldd	r25, Y+6	; 0x06
    46fe:	00 97       	sbiw	r24, 0x00	; 0
    4700:	69 f7       	brne	.-38     	; 0x46dc <STEPPER_Unipolar_CW_HS+0x996>
    4702:	14 c0       	rjmp	.+40     	; 0x472c <STEPPER_Unipolar_CW_HS+0x9e6>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    4704:	6f 81       	ldd	r22, Y+7	; 0x07
    4706:	78 85       	ldd	r23, Y+8	; 0x08
    4708:	89 85       	ldd	r24, Y+9	; 0x09
    470a:	9a 85       	ldd	r25, Y+10	; 0x0a
    470c:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    4710:	dc 01       	movw	r26, r24
    4712:	cb 01       	movw	r24, r22
    4714:	9e 83       	std	Y+6, r25	; 0x06
    4716:	8d 83       	std	Y+5, r24	; 0x05
    4718:	8d 81       	ldd	r24, Y+5	; 0x05
    471a:	9e 81       	ldd	r25, Y+6	; 0x06
    471c:	9a 83       	std	Y+2, r25	; 0x02
    471e:	89 83       	std	Y+1, r24	; 0x01
    4720:	89 81       	ldd	r24, Y+1	; 0x01
    4722:	9a 81       	ldd	r25, Y+2	; 0x02
    4724:	01 97       	sbiw	r24, 0x01	; 1
    4726:	f1 f7       	brne	.-4      	; 0x4724 <STEPPER_Unipolar_CW_HS+0x9de>
    4728:	9a 83       	std	Y+2, r25	; 0x02
    472a:	89 83       	std	Y+1, r24	; 0x01
	_delay_ms( DELAY );

}
    472c:	c0 59       	subi	r28, 0x90	; 144
    472e:	df 4f       	sbci	r29, 0xFF	; 255
    4730:	0f b6       	in	r0, 0x3f	; 63
    4732:	f8 94       	cli
    4734:	de bf       	out	0x3e, r29	; 62
    4736:	0f be       	out	0x3f, r0	; 63
    4738:	cd bf       	out	0x3d, r28	; 61
    473a:	cf 91       	pop	r28
    473c:	df 91       	pop	r29
    473e:	1f 91       	pop	r17
    4740:	0f 91       	pop	r16
    4742:	08 95       	ret

00004744 <STEPPER_Unipolar_CCW_HS>:
void STEPPER_Unipolar_CCW_HS(void)
{
    4744:	df 93       	push	r29
    4746:	cf 93       	push	r28
    4748:	cd b7       	in	r28, 0x3d	; 61
    474a:	de b7       	in	r29, 0x3e	; 62
    474c:	e8 97       	sbiw	r28, 0x38	; 56
    474e:	0f b6       	in	r0, 0x3f	; 63
    4750:	f8 94       	cli
    4752:	de bf       	out	0x3e, r29	; 62
    4754:	0f be       	out	0x3f, r0	; 63
    4756:	cd bf       	out	0x3d, r28	; 61
	DIO_WritePin(COIL1A,LOW);
    4758:	84 e1       	ldi	r24, 0x14	; 20
    475a:	60 e0       	ldi	r22, 0x00	; 0
    475c:	0e 94 f9 09 	call	0x13f2	; 0x13f2 <DIO_WritePin>
	DIO_WritePin(COIL1B,LOW);
    4760:	85 e1       	ldi	r24, 0x15	; 21
    4762:	60 e0       	ldi	r22, 0x00	; 0
    4764:	0e 94 f9 09 	call	0x13f2	; 0x13f2 <DIO_WritePin>
	DIO_WritePin(COIL2A,LOW);
    4768:	86 e1       	ldi	r24, 0x16	; 22
    476a:	60 e0       	ldi	r22, 0x00	; 0
    476c:	0e 94 f9 09 	call	0x13f2	; 0x13f2 <DIO_WritePin>
	DIO_WritePin(COIL2B,HIGH);
    4770:	87 e1       	ldi	r24, 0x17	; 23
    4772:	61 e0       	ldi	r22, 0x01	; 1
    4774:	0e 94 f9 09 	call	0x13f2	; 0x13f2 <DIO_WritePin>
    4778:	80 e0       	ldi	r24, 0x00	; 0
    477a:	90 e0       	ldi	r25, 0x00	; 0
    477c:	aa ef       	ldi	r26, 0xFA	; 250
    477e:	b3 e4       	ldi	r27, 0x43	; 67
    4780:	8d ab       	std	Y+53, r24	; 0x35
    4782:	9e ab       	std	Y+54, r25	; 0x36
    4784:	af ab       	std	Y+55, r26	; 0x37
    4786:	b8 af       	std	Y+56, r27	; 0x38
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    4788:	6d a9       	ldd	r22, Y+53	; 0x35
    478a:	7e a9       	ldd	r23, Y+54	; 0x36
    478c:	8f a9       	ldd	r24, Y+55	; 0x37
    478e:	98 ad       	ldd	r25, Y+56	; 0x38
    4790:	20 e0       	ldi	r18, 0x00	; 0
    4792:	30 e0       	ldi	r19, 0x00	; 0
    4794:	4a ef       	ldi	r20, 0xFA	; 250
    4796:	54 e4       	ldi	r21, 0x44	; 68
    4798:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    479c:	dc 01       	movw	r26, r24
    479e:	cb 01       	movw	r24, r22
    47a0:	89 ab       	std	Y+49, r24	; 0x31
    47a2:	9a ab       	std	Y+50, r25	; 0x32
    47a4:	ab ab       	std	Y+51, r26	; 0x33
    47a6:	bc ab       	std	Y+52, r27	; 0x34
	if (__tmp < 1.0)
    47a8:	69 a9       	ldd	r22, Y+49	; 0x31
    47aa:	7a a9       	ldd	r23, Y+50	; 0x32
    47ac:	8b a9       	ldd	r24, Y+51	; 0x33
    47ae:	9c a9       	ldd	r25, Y+52	; 0x34
    47b0:	20 e0       	ldi	r18, 0x00	; 0
    47b2:	30 e0       	ldi	r19, 0x00	; 0
    47b4:	40 e8       	ldi	r20, 0x80	; 128
    47b6:	5f e3       	ldi	r21, 0x3F	; 63
    47b8:	0e 94 79 03 	call	0x6f2	; 0x6f2 <__ltsf2>
    47bc:	88 23       	and	r24, r24
    47be:	2c f4       	brge	.+10     	; 0x47ca <STEPPER_Unipolar_CCW_HS+0x86>
		__ticks = 1;
    47c0:	81 e0       	ldi	r24, 0x01	; 1
    47c2:	90 e0       	ldi	r25, 0x00	; 0
    47c4:	98 ab       	std	Y+48, r25	; 0x30
    47c6:	8f a7       	std	Y+47, r24	; 0x2f
    47c8:	3f c0       	rjmp	.+126    	; 0x4848 <STEPPER_Unipolar_CCW_HS+0x104>
	else if (__tmp > 65535)
    47ca:	69 a9       	ldd	r22, Y+49	; 0x31
    47cc:	7a a9       	ldd	r23, Y+50	; 0x32
    47ce:	8b a9       	ldd	r24, Y+51	; 0x33
    47d0:	9c a9       	ldd	r25, Y+52	; 0x34
    47d2:	20 e0       	ldi	r18, 0x00	; 0
    47d4:	3f ef       	ldi	r19, 0xFF	; 255
    47d6:	4f e7       	ldi	r20, 0x7F	; 127
    47d8:	57 e4       	ldi	r21, 0x47	; 71
    47da:	0e 94 19 03 	call	0x632	; 0x632 <__gtsf2>
    47de:	18 16       	cp	r1, r24
    47e0:	4c f5       	brge	.+82     	; 0x4834 <STEPPER_Unipolar_CCW_HS+0xf0>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    47e2:	6d a9       	ldd	r22, Y+53	; 0x35
    47e4:	7e a9       	ldd	r23, Y+54	; 0x36
    47e6:	8f a9       	ldd	r24, Y+55	; 0x37
    47e8:	98 ad       	ldd	r25, Y+56	; 0x38
    47ea:	20 e0       	ldi	r18, 0x00	; 0
    47ec:	30 e0       	ldi	r19, 0x00	; 0
    47ee:	40 e2       	ldi	r20, 0x20	; 32
    47f0:	51 e4       	ldi	r21, 0x41	; 65
    47f2:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    47f6:	dc 01       	movw	r26, r24
    47f8:	cb 01       	movw	r24, r22
    47fa:	bc 01       	movw	r22, r24
    47fc:	cd 01       	movw	r24, r26
    47fe:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    4802:	dc 01       	movw	r26, r24
    4804:	cb 01       	movw	r24, r22
    4806:	98 ab       	std	Y+48, r25	; 0x30
    4808:	8f a7       	std	Y+47, r24	; 0x2f
    480a:	0f c0       	rjmp	.+30     	; 0x482a <STEPPER_Unipolar_CCW_HS+0xe6>
    480c:	88 ec       	ldi	r24, 0xC8	; 200
    480e:	90 e0       	ldi	r25, 0x00	; 0
    4810:	9e a7       	std	Y+46, r25	; 0x2e
    4812:	8d a7       	std	Y+45, r24	; 0x2d
    4814:	8d a5       	ldd	r24, Y+45	; 0x2d
    4816:	9e a5       	ldd	r25, Y+46	; 0x2e
    4818:	01 97       	sbiw	r24, 0x01	; 1
    481a:	f1 f7       	brne	.-4      	; 0x4818 <STEPPER_Unipolar_CCW_HS+0xd4>
    481c:	9e a7       	std	Y+46, r25	; 0x2e
    481e:	8d a7       	std	Y+45, r24	; 0x2d
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    4820:	8f a5       	ldd	r24, Y+47	; 0x2f
    4822:	98 a9       	ldd	r25, Y+48	; 0x30
    4824:	01 97       	sbiw	r24, 0x01	; 1
    4826:	98 ab       	std	Y+48, r25	; 0x30
    4828:	8f a7       	std	Y+47, r24	; 0x2f
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    482a:	8f a5       	ldd	r24, Y+47	; 0x2f
    482c:	98 a9       	ldd	r25, Y+48	; 0x30
    482e:	00 97       	sbiw	r24, 0x00	; 0
    4830:	69 f7       	brne	.-38     	; 0x480c <STEPPER_Unipolar_CCW_HS+0xc8>
    4832:	14 c0       	rjmp	.+40     	; 0x485c <STEPPER_Unipolar_CCW_HS+0x118>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    4834:	69 a9       	ldd	r22, Y+49	; 0x31
    4836:	7a a9       	ldd	r23, Y+50	; 0x32
    4838:	8b a9       	ldd	r24, Y+51	; 0x33
    483a:	9c a9       	ldd	r25, Y+52	; 0x34
    483c:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    4840:	dc 01       	movw	r26, r24
    4842:	cb 01       	movw	r24, r22
    4844:	98 ab       	std	Y+48, r25	; 0x30
    4846:	8f a7       	std	Y+47, r24	; 0x2f
    4848:	8f a5       	ldd	r24, Y+47	; 0x2f
    484a:	98 a9       	ldd	r25, Y+48	; 0x30
    484c:	9c a7       	std	Y+44, r25	; 0x2c
    484e:	8b a7       	std	Y+43, r24	; 0x2b
    4850:	8b a5       	ldd	r24, Y+43	; 0x2b
    4852:	9c a5       	ldd	r25, Y+44	; 0x2c
    4854:	01 97       	sbiw	r24, 0x01	; 1
    4856:	f1 f7       	brne	.-4      	; 0x4854 <STEPPER_Unipolar_CCW_HS+0x110>
    4858:	9c a7       	std	Y+44, r25	; 0x2c
    485a:	8b a7       	std	Y+43, r24	; 0x2b
	_delay_ms( DELAY );
	DIO_WritePin(COIL1A,LOW);
    485c:	84 e1       	ldi	r24, 0x14	; 20
    485e:	60 e0       	ldi	r22, 0x00	; 0
    4860:	0e 94 f9 09 	call	0x13f2	; 0x13f2 <DIO_WritePin>
	DIO_WritePin(COIL1B,LOW);
    4864:	85 e1       	ldi	r24, 0x15	; 21
    4866:	60 e0       	ldi	r22, 0x00	; 0
    4868:	0e 94 f9 09 	call	0x13f2	; 0x13f2 <DIO_WritePin>
	DIO_WritePin(COIL2A,HIGH);
    486c:	86 e1       	ldi	r24, 0x16	; 22
    486e:	61 e0       	ldi	r22, 0x01	; 1
    4870:	0e 94 f9 09 	call	0x13f2	; 0x13f2 <DIO_WritePin>
	DIO_WritePin(COIL2B,LOW);
    4874:	87 e1       	ldi	r24, 0x17	; 23
    4876:	60 e0       	ldi	r22, 0x00	; 0
    4878:	0e 94 f9 09 	call	0x13f2	; 0x13f2 <DIO_WritePin>
    487c:	80 e0       	ldi	r24, 0x00	; 0
    487e:	90 e0       	ldi	r25, 0x00	; 0
    4880:	aa ef       	ldi	r26, 0xFA	; 250
    4882:	b3 e4       	ldi	r27, 0x43	; 67
    4884:	8f a3       	std	Y+39, r24	; 0x27
    4886:	98 a7       	std	Y+40, r25	; 0x28
    4888:	a9 a7       	std	Y+41, r26	; 0x29
    488a:	ba a7       	std	Y+42, r27	; 0x2a
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    488c:	6f a1       	ldd	r22, Y+39	; 0x27
    488e:	78 a5       	ldd	r23, Y+40	; 0x28
    4890:	89 a5       	ldd	r24, Y+41	; 0x29
    4892:	9a a5       	ldd	r25, Y+42	; 0x2a
    4894:	20 e0       	ldi	r18, 0x00	; 0
    4896:	30 e0       	ldi	r19, 0x00	; 0
    4898:	4a ef       	ldi	r20, 0xFA	; 250
    489a:	54 e4       	ldi	r21, 0x44	; 68
    489c:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    48a0:	dc 01       	movw	r26, r24
    48a2:	cb 01       	movw	r24, r22
    48a4:	8b a3       	std	Y+35, r24	; 0x23
    48a6:	9c a3       	std	Y+36, r25	; 0x24
    48a8:	ad a3       	std	Y+37, r26	; 0x25
    48aa:	be a3       	std	Y+38, r27	; 0x26
	if (__tmp < 1.0)
    48ac:	6b a1       	ldd	r22, Y+35	; 0x23
    48ae:	7c a1       	ldd	r23, Y+36	; 0x24
    48b0:	8d a1       	ldd	r24, Y+37	; 0x25
    48b2:	9e a1       	ldd	r25, Y+38	; 0x26
    48b4:	20 e0       	ldi	r18, 0x00	; 0
    48b6:	30 e0       	ldi	r19, 0x00	; 0
    48b8:	40 e8       	ldi	r20, 0x80	; 128
    48ba:	5f e3       	ldi	r21, 0x3F	; 63
    48bc:	0e 94 79 03 	call	0x6f2	; 0x6f2 <__ltsf2>
    48c0:	88 23       	and	r24, r24
    48c2:	2c f4       	brge	.+10     	; 0x48ce <STEPPER_Unipolar_CCW_HS+0x18a>
		__ticks = 1;
    48c4:	81 e0       	ldi	r24, 0x01	; 1
    48c6:	90 e0       	ldi	r25, 0x00	; 0
    48c8:	9a a3       	std	Y+34, r25	; 0x22
    48ca:	89 a3       	std	Y+33, r24	; 0x21
    48cc:	3f c0       	rjmp	.+126    	; 0x494c <STEPPER_Unipolar_CCW_HS+0x208>
	else if (__tmp > 65535)
    48ce:	6b a1       	ldd	r22, Y+35	; 0x23
    48d0:	7c a1       	ldd	r23, Y+36	; 0x24
    48d2:	8d a1       	ldd	r24, Y+37	; 0x25
    48d4:	9e a1       	ldd	r25, Y+38	; 0x26
    48d6:	20 e0       	ldi	r18, 0x00	; 0
    48d8:	3f ef       	ldi	r19, 0xFF	; 255
    48da:	4f e7       	ldi	r20, 0x7F	; 127
    48dc:	57 e4       	ldi	r21, 0x47	; 71
    48de:	0e 94 19 03 	call	0x632	; 0x632 <__gtsf2>
    48e2:	18 16       	cp	r1, r24
    48e4:	4c f5       	brge	.+82     	; 0x4938 <STEPPER_Unipolar_CCW_HS+0x1f4>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    48e6:	6f a1       	ldd	r22, Y+39	; 0x27
    48e8:	78 a5       	ldd	r23, Y+40	; 0x28
    48ea:	89 a5       	ldd	r24, Y+41	; 0x29
    48ec:	9a a5       	ldd	r25, Y+42	; 0x2a
    48ee:	20 e0       	ldi	r18, 0x00	; 0
    48f0:	30 e0       	ldi	r19, 0x00	; 0
    48f2:	40 e2       	ldi	r20, 0x20	; 32
    48f4:	51 e4       	ldi	r21, 0x41	; 65
    48f6:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    48fa:	dc 01       	movw	r26, r24
    48fc:	cb 01       	movw	r24, r22
    48fe:	bc 01       	movw	r22, r24
    4900:	cd 01       	movw	r24, r26
    4902:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    4906:	dc 01       	movw	r26, r24
    4908:	cb 01       	movw	r24, r22
    490a:	9a a3       	std	Y+34, r25	; 0x22
    490c:	89 a3       	std	Y+33, r24	; 0x21
    490e:	0f c0       	rjmp	.+30     	; 0x492e <STEPPER_Unipolar_CCW_HS+0x1ea>
    4910:	88 ec       	ldi	r24, 0xC8	; 200
    4912:	90 e0       	ldi	r25, 0x00	; 0
    4914:	98 a3       	std	Y+32, r25	; 0x20
    4916:	8f 8f       	std	Y+31, r24	; 0x1f
    4918:	8f 8d       	ldd	r24, Y+31	; 0x1f
    491a:	98 a1       	ldd	r25, Y+32	; 0x20
    491c:	01 97       	sbiw	r24, 0x01	; 1
    491e:	f1 f7       	brne	.-4      	; 0x491c <STEPPER_Unipolar_CCW_HS+0x1d8>
    4920:	98 a3       	std	Y+32, r25	; 0x20
    4922:	8f 8f       	std	Y+31, r24	; 0x1f
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    4924:	89 a1       	ldd	r24, Y+33	; 0x21
    4926:	9a a1       	ldd	r25, Y+34	; 0x22
    4928:	01 97       	sbiw	r24, 0x01	; 1
    492a:	9a a3       	std	Y+34, r25	; 0x22
    492c:	89 a3       	std	Y+33, r24	; 0x21
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    492e:	89 a1       	ldd	r24, Y+33	; 0x21
    4930:	9a a1       	ldd	r25, Y+34	; 0x22
    4932:	00 97       	sbiw	r24, 0x00	; 0
    4934:	69 f7       	brne	.-38     	; 0x4910 <STEPPER_Unipolar_CCW_HS+0x1cc>
    4936:	14 c0       	rjmp	.+40     	; 0x4960 <STEPPER_Unipolar_CCW_HS+0x21c>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    4938:	6b a1       	ldd	r22, Y+35	; 0x23
    493a:	7c a1       	ldd	r23, Y+36	; 0x24
    493c:	8d a1       	ldd	r24, Y+37	; 0x25
    493e:	9e a1       	ldd	r25, Y+38	; 0x26
    4940:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    4944:	dc 01       	movw	r26, r24
    4946:	cb 01       	movw	r24, r22
    4948:	9a a3       	std	Y+34, r25	; 0x22
    494a:	89 a3       	std	Y+33, r24	; 0x21
    494c:	89 a1       	ldd	r24, Y+33	; 0x21
    494e:	9a a1       	ldd	r25, Y+34	; 0x22
    4950:	9e 8f       	std	Y+30, r25	; 0x1e
    4952:	8d 8f       	std	Y+29, r24	; 0x1d
    4954:	8d 8d       	ldd	r24, Y+29	; 0x1d
    4956:	9e 8d       	ldd	r25, Y+30	; 0x1e
    4958:	01 97       	sbiw	r24, 0x01	; 1
    495a:	f1 f7       	brne	.-4      	; 0x4958 <STEPPER_Unipolar_CCW_HS+0x214>
    495c:	9e 8f       	std	Y+30, r25	; 0x1e
    495e:	8d 8f       	std	Y+29, r24	; 0x1d
	_delay_ms( DELAY );
	DIO_WritePin(COIL1A,LOW);
    4960:	84 e1       	ldi	r24, 0x14	; 20
    4962:	60 e0       	ldi	r22, 0x00	; 0
    4964:	0e 94 f9 09 	call	0x13f2	; 0x13f2 <DIO_WritePin>
	DIO_WritePin(COIL1B,HIGH);
    4968:	85 e1       	ldi	r24, 0x15	; 21
    496a:	61 e0       	ldi	r22, 0x01	; 1
    496c:	0e 94 f9 09 	call	0x13f2	; 0x13f2 <DIO_WritePin>
	DIO_WritePin(COIL2A,LOW);
    4970:	86 e1       	ldi	r24, 0x16	; 22
    4972:	60 e0       	ldi	r22, 0x00	; 0
    4974:	0e 94 f9 09 	call	0x13f2	; 0x13f2 <DIO_WritePin>
	DIO_WritePin(COIL2B,LOW);
    4978:	87 e1       	ldi	r24, 0x17	; 23
    497a:	60 e0       	ldi	r22, 0x00	; 0
    497c:	0e 94 f9 09 	call	0x13f2	; 0x13f2 <DIO_WritePin>
    4980:	80 e0       	ldi	r24, 0x00	; 0
    4982:	90 e0       	ldi	r25, 0x00	; 0
    4984:	aa ef       	ldi	r26, 0xFA	; 250
    4986:	b3 e4       	ldi	r27, 0x43	; 67
    4988:	89 8f       	std	Y+25, r24	; 0x19
    498a:	9a 8f       	std	Y+26, r25	; 0x1a
    498c:	ab 8f       	std	Y+27, r26	; 0x1b
    498e:	bc 8f       	std	Y+28, r27	; 0x1c
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    4990:	69 8d       	ldd	r22, Y+25	; 0x19
    4992:	7a 8d       	ldd	r23, Y+26	; 0x1a
    4994:	8b 8d       	ldd	r24, Y+27	; 0x1b
    4996:	9c 8d       	ldd	r25, Y+28	; 0x1c
    4998:	20 e0       	ldi	r18, 0x00	; 0
    499a:	30 e0       	ldi	r19, 0x00	; 0
    499c:	4a ef       	ldi	r20, 0xFA	; 250
    499e:	54 e4       	ldi	r21, 0x44	; 68
    49a0:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    49a4:	dc 01       	movw	r26, r24
    49a6:	cb 01       	movw	r24, r22
    49a8:	8d 8b       	std	Y+21, r24	; 0x15
    49aa:	9e 8b       	std	Y+22, r25	; 0x16
    49ac:	af 8b       	std	Y+23, r26	; 0x17
    49ae:	b8 8f       	std	Y+24, r27	; 0x18
	if (__tmp < 1.0)
    49b0:	6d 89       	ldd	r22, Y+21	; 0x15
    49b2:	7e 89       	ldd	r23, Y+22	; 0x16
    49b4:	8f 89       	ldd	r24, Y+23	; 0x17
    49b6:	98 8d       	ldd	r25, Y+24	; 0x18
    49b8:	20 e0       	ldi	r18, 0x00	; 0
    49ba:	30 e0       	ldi	r19, 0x00	; 0
    49bc:	40 e8       	ldi	r20, 0x80	; 128
    49be:	5f e3       	ldi	r21, 0x3F	; 63
    49c0:	0e 94 79 03 	call	0x6f2	; 0x6f2 <__ltsf2>
    49c4:	88 23       	and	r24, r24
    49c6:	2c f4       	brge	.+10     	; 0x49d2 <STEPPER_Unipolar_CCW_HS+0x28e>
		__ticks = 1;
    49c8:	81 e0       	ldi	r24, 0x01	; 1
    49ca:	90 e0       	ldi	r25, 0x00	; 0
    49cc:	9c 8b       	std	Y+20, r25	; 0x14
    49ce:	8b 8b       	std	Y+19, r24	; 0x13
    49d0:	3f c0       	rjmp	.+126    	; 0x4a50 <STEPPER_Unipolar_CCW_HS+0x30c>
	else if (__tmp > 65535)
    49d2:	6d 89       	ldd	r22, Y+21	; 0x15
    49d4:	7e 89       	ldd	r23, Y+22	; 0x16
    49d6:	8f 89       	ldd	r24, Y+23	; 0x17
    49d8:	98 8d       	ldd	r25, Y+24	; 0x18
    49da:	20 e0       	ldi	r18, 0x00	; 0
    49dc:	3f ef       	ldi	r19, 0xFF	; 255
    49de:	4f e7       	ldi	r20, 0x7F	; 127
    49e0:	57 e4       	ldi	r21, 0x47	; 71
    49e2:	0e 94 19 03 	call	0x632	; 0x632 <__gtsf2>
    49e6:	18 16       	cp	r1, r24
    49e8:	4c f5       	brge	.+82     	; 0x4a3c <STEPPER_Unipolar_CCW_HS+0x2f8>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    49ea:	69 8d       	ldd	r22, Y+25	; 0x19
    49ec:	7a 8d       	ldd	r23, Y+26	; 0x1a
    49ee:	8b 8d       	ldd	r24, Y+27	; 0x1b
    49f0:	9c 8d       	ldd	r25, Y+28	; 0x1c
    49f2:	20 e0       	ldi	r18, 0x00	; 0
    49f4:	30 e0       	ldi	r19, 0x00	; 0
    49f6:	40 e2       	ldi	r20, 0x20	; 32
    49f8:	51 e4       	ldi	r21, 0x41	; 65
    49fa:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    49fe:	dc 01       	movw	r26, r24
    4a00:	cb 01       	movw	r24, r22
    4a02:	bc 01       	movw	r22, r24
    4a04:	cd 01       	movw	r24, r26
    4a06:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    4a0a:	dc 01       	movw	r26, r24
    4a0c:	cb 01       	movw	r24, r22
    4a0e:	9c 8b       	std	Y+20, r25	; 0x14
    4a10:	8b 8b       	std	Y+19, r24	; 0x13
    4a12:	0f c0       	rjmp	.+30     	; 0x4a32 <STEPPER_Unipolar_CCW_HS+0x2ee>
    4a14:	88 ec       	ldi	r24, 0xC8	; 200
    4a16:	90 e0       	ldi	r25, 0x00	; 0
    4a18:	9a 8b       	std	Y+18, r25	; 0x12
    4a1a:	89 8b       	std	Y+17, r24	; 0x11
    4a1c:	89 89       	ldd	r24, Y+17	; 0x11
    4a1e:	9a 89       	ldd	r25, Y+18	; 0x12
    4a20:	01 97       	sbiw	r24, 0x01	; 1
    4a22:	f1 f7       	brne	.-4      	; 0x4a20 <STEPPER_Unipolar_CCW_HS+0x2dc>
    4a24:	9a 8b       	std	Y+18, r25	; 0x12
    4a26:	89 8b       	std	Y+17, r24	; 0x11
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    4a28:	8b 89       	ldd	r24, Y+19	; 0x13
    4a2a:	9c 89       	ldd	r25, Y+20	; 0x14
    4a2c:	01 97       	sbiw	r24, 0x01	; 1
    4a2e:	9c 8b       	std	Y+20, r25	; 0x14
    4a30:	8b 8b       	std	Y+19, r24	; 0x13
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    4a32:	8b 89       	ldd	r24, Y+19	; 0x13
    4a34:	9c 89       	ldd	r25, Y+20	; 0x14
    4a36:	00 97       	sbiw	r24, 0x00	; 0
    4a38:	69 f7       	brne	.-38     	; 0x4a14 <STEPPER_Unipolar_CCW_HS+0x2d0>
    4a3a:	14 c0       	rjmp	.+40     	; 0x4a64 <STEPPER_Unipolar_CCW_HS+0x320>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    4a3c:	6d 89       	ldd	r22, Y+21	; 0x15
    4a3e:	7e 89       	ldd	r23, Y+22	; 0x16
    4a40:	8f 89       	ldd	r24, Y+23	; 0x17
    4a42:	98 8d       	ldd	r25, Y+24	; 0x18
    4a44:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    4a48:	dc 01       	movw	r26, r24
    4a4a:	cb 01       	movw	r24, r22
    4a4c:	9c 8b       	std	Y+20, r25	; 0x14
    4a4e:	8b 8b       	std	Y+19, r24	; 0x13
    4a50:	8b 89       	ldd	r24, Y+19	; 0x13
    4a52:	9c 89       	ldd	r25, Y+20	; 0x14
    4a54:	98 8b       	std	Y+16, r25	; 0x10
    4a56:	8f 87       	std	Y+15, r24	; 0x0f
    4a58:	8f 85       	ldd	r24, Y+15	; 0x0f
    4a5a:	98 89       	ldd	r25, Y+16	; 0x10
    4a5c:	01 97       	sbiw	r24, 0x01	; 1
    4a5e:	f1 f7       	brne	.-4      	; 0x4a5c <STEPPER_Unipolar_CCW_HS+0x318>
    4a60:	98 8b       	std	Y+16, r25	; 0x10
    4a62:	8f 87       	std	Y+15, r24	; 0x0f
	_delay_ms( DELAY );
	DIO_WritePin(COIL1A,HIGH);
    4a64:	84 e1       	ldi	r24, 0x14	; 20
    4a66:	61 e0       	ldi	r22, 0x01	; 1
    4a68:	0e 94 f9 09 	call	0x13f2	; 0x13f2 <DIO_WritePin>
	DIO_WritePin(COIL1B,LOW);
    4a6c:	85 e1       	ldi	r24, 0x15	; 21
    4a6e:	60 e0       	ldi	r22, 0x00	; 0
    4a70:	0e 94 f9 09 	call	0x13f2	; 0x13f2 <DIO_WritePin>
	DIO_WritePin(COIL2A,LOW);
    4a74:	86 e1       	ldi	r24, 0x16	; 22
    4a76:	60 e0       	ldi	r22, 0x00	; 0
    4a78:	0e 94 f9 09 	call	0x13f2	; 0x13f2 <DIO_WritePin>
	DIO_WritePin(COIL2B,LOW);
    4a7c:	87 e1       	ldi	r24, 0x17	; 23
    4a7e:	60 e0       	ldi	r22, 0x00	; 0
    4a80:	0e 94 f9 09 	call	0x13f2	; 0x13f2 <DIO_WritePin>
    4a84:	80 e0       	ldi	r24, 0x00	; 0
    4a86:	90 e0       	ldi	r25, 0x00	; 0
    4a88:	aa ef       	ldi	r26, 0xFA	; 250
    4a8a:	b3 e4       	ldi	r27, 0x43	; 67
    4a8c:	8b 87       	std	Y+11, r24	; 0x0b
    4a8e:	9c 87       	std	Y+12, r25	; 0x0c
    4a90:	ad 87       	std	Y+13, r26	; 0x0d
    4a92:	be 87       	std	Y+14, r27	; 0x0e
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    4a94:	6b 85       	ldd	r22, Y+11	; 0x0b
    4a96:	7c 85       	ldd	r23, Y+12	; 0x0c
    4a98:	8d 85       	ldd	r24, Y+13	; 0x0d
    4a9a:	9e 85       	ldd	r25, Y+14	; 0x0e
    4a9c:	20 e0       	ldi	r18, 0x00	; 0
    4a9e:	30 e0       	ldi	r19, 0x00	; 0
    4aa0:	4a ef       	ldi	r20, 0xFA	; 250
    4aa2:	54 e4       	ldi	r21, 0x44	; 68
    4aa4:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    4aa8:	dc 01       	movw	r26, r24
    4aaa:	cb 01       	movw	r24, r22
    4aac:	8f 83       	std	Y+7, r24	; 0x07
    4aae:	98 87       	std	Y+8, r25	; 0x08
    4ab0:	a9 87       	std	Y+9, r26	; 0x09
    4ab2:	ba 87       	std	Y+10, r27	; 0x0a
	if (__tmp < 1.0)
    4ab4:	6f 81       	ldd	r22, Y+7	; 0x07
    4ab6:	78 85       	ldd	r23, Y+8	; 0x08
    4ab8:	89 85       	ldd	r24, Y+9	; 0x09
    4aba:	9a 85       	ldd	r25, Y+10	; 0x0a
    4abc:	20 e0       	ldi	r18, 0x00	; 0
    4abe:	30 e0       	ldi	r19, 0x00	; 0
    4ac0:	40 e8       	ldi	r20, 0x80	; 128
    4ac2:	5f e3       	ldi	r21, 0x3F	; 63
    4ac4:	0e 94 79 03 	call	0x6f2	; 0x6f2 <__ltsf2>
    4ac8:	88 23       	and	r24, r24
    4aca:	2c f4       	brge	.+10     	; 0x4ad6 <STEPPER_Unipolar_CCW_HS+0x392>
		__ticks = 1;
    4acc:	81 e0       	ldi	r24, 0x01	; 1
    4ace:	90 e0       	ldi	r25, 0x00	; 0
    4ad0:	9e 83       	std	Y+6, r25	; 0x06
    4ad2:	8d 83       	std	Y+5, r24	; 0x05
    4ad4:	3f c0       	rjmp	.+126    	; 0x4b54 <STEPPER_Unipolar_CCW_HS+0x410>
	else if (__tmp > 65535)
    4ad6:	6f 81       	ldd	r22, Y+7	; 0x07
    4ad8:	78 85       	ldd	r23, Y+8	; 0x08
    4ada:	89 85       	ldd	r24, Y+9	; 0x09
    4adc:	9a 85       	ldd	r25, Y+10	; 0x0a
    4ade:	20 e0       	ldi	r18, 0x00	; 0
    4ae0:	3f ef       	ldi	r19, 0xFF	; 255
    4ae2:	4f e7       	ldi	r20, 0x7F	; 127
    4ae4:	57 e4       	ldi	r21, 0x47	; 71
    4ae6:	0e 94 19 03 	call	0x632	; 0x632 <__gtsf2>
    4aea:	18 16       	cp	r1, r24
    4aec:	4c f5       	brge	.+82     	; 0x4b40 <STEPPER_Unipolar_CCW_HS+0x3fc>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    4aee:	6b 85       	ldd	r22, Y+11	; 0x0b
    4af0:	7c 85       	ldd	r23, Y+12	; 0x0c
    4af2:	8d 85       	ldd	r24, Y+13	; 0x0d
    4af4:	9e 85       	ldd	r25, Y+14	; 0x0e
    4af6:	20 e0       	ldi	r18, 0x00	; 0
    4af8:	30 e0       	ldi	r19, 0x00	; 0
    4afa:	40 e2       	ldi	r20, 0x20	; 32
    4afc:	51 e4       	ldi	r21, 0x41	; 65
    4afe:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    4b02:	dc 01       	movw	r26, r24
    4b04:	cb 01       	movw	r24, r22
    4b06:	bc 01       	movw	r22, r24
    4b08:	cd 01       	movw	r24, r26
    4b0a:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    4b0e:	dc 01       	movw	r26, r24
    4b10:	cb 01       	movw	r24, r22
    4b12:	9e 83       	std	Y+6, r25	; 0x06
    4b14:	8d 83       	std	Y+5, r24	; 0x05
    4b16:	0f c0       	rjmp	.+30     	; 0x4b36 <STEPPER_Unipolar_CCW_HS+0x3f2>
    4b18:	88 ec       	ldi	r24, 0xC8	; 200
    4b1a:	90 e0       	ldi	r25, 0x00	; 0
    4b1c:	9c 83       	std	Y+4, r25	; 0x04
    4b1e:	8b 83       	std	Y+3, r24	; 0x03
    4b20:	8b 81       	ldd	r24, Y+3	; 0x03
    4b22:	9c 81       	ldd	r25, Y+4	; 0x04
    4b24:	01 97       	sbiw	r24, 0x01	; 1
    4b26:	f1 f7       	brne	.-4      	; 0x4b24 <STEPPER_Unipolar_CCW_HS+0x3e0>
    4b28:	9c 83       	std	Y+4, r25	; 0x04
    4b2a:	8b 83       	std	Y+3, r24	; 0x03
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    4b2c:	8d 81       	ldd	r24, Y+5	; 0x05
    4b2e:	9e 81       	ldd	r25, Y+6	; 0x06
    4b30:	01 97       	sbiw	r24, 0x01	; 1
    4b32:	9e 83       	std	Y+6, r25	; 0x06
    4b34:	8d 83       	std	Y+5, r24	; 0x05
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    4b36:	8d 81       	ldd	r24, Y+5	; 0x05
    4b38:	9e 81       	ldd	r25, Y+6	; 0x06
    4b3a:	00 97       	sbiw	r24, 0x00	; 0
    4b3c:	69 f7       	brne	.-38     	; 0x4b18 <STEPPER_Unipolar_CCW_HS+0x3d4>
    4b3e:	14 c0       	rjmp	.+40     	; 0x4b68 <STEPPER_Unipolar_CCW_HS+0x424>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    4b40:	6f 81       	ldd	r22, Y+7	; 0x07
    4b42:	78 85       	ldd	r23, Y+8	; 0x08
    4b44:	89 85       	ldd	r24, Y+9	; 0x09
    4b46:	9a 85       	ldd	r25, Y+10	; 0x0a
    4b48:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    4b4c:	dc 01       	movw	r26, r24
    4b4e:	cb 01       	movw	r24, r22
    4b50:	9e 83       	std	Y+6, r25	; 0x06
    4b52:	8d 83       	std	Y+5, r24	; 0x05
    4b54:	8d 81       	ldd	r24, Y+5	; 0x05
    4b56:	9e 81       	ldd	r25, Y+6	; 0x06
    4b58:	9a 83       	std	Y+2, r25	; 0x02
    4b5a:	89 83       	std	Y+1, r24	; 0x01
    4b5c:	89 81       	ldd	r24, Y+1	; 0x01
    4b5e:	9a 81       	ldd	r25, Y+2	; 0x02
    4b60:	01 97       	sbiw	r24, 0x01	; 1
    4b62:	f1 f7       	brne	.-4      	; 0x4b60 <STEPPER_Unipolar_CCW_HS+0x41c>
    4b64:	9a 83       	std	Y+2, r25	; 0x02
    4b66:	89 83       	std	Y+1, r24	; 0x01
	_delay_ms( DELAY );

}
    4b68:	e8 96       	adiw	r28, 0x38	; 56
    4b6a:	0f b6       	in	r0, 0x3f	; 63
    4b6c:	f8 94       	cli
    4b6e:	de bf       	out	0x3e, r29	; 62
    4b70:	0f be       	out	0x3f, r0	; 63
    4b72:	cd bf       	out	0x3d, r28	; 61
    4b74:	cf 91       	pop	r28
    4b76:	df 91       	pop	r29
    4b78:	08 95       	ret

00004b7a <xCoRoutineCreate>:
static void prvCheckDelayedList( void );

/*-----------------------------------------------------------*/

signed portBASE_TYPE xCoRoutineCreate( crCOROUTINE_CODE pxCoRoutineCode, unsigned portBASE_TYPE uxPriority, unsigned portBASE_TYPE uxIndex )
{
    4b7a:	df 93       	push	r29
    4b7c:	cf 93       	push	r28
    4b7e:	cd b7       	in	r28, 0x3d	; 61
    4b80:	de b7       	in	r29, 0x3e	; 62
    4b82:	27 97       	sbiw	r28, 0x07	; 7
    4b84:	0f b6       	in	r0, 0x3f	; 63
    4b86:	f8 94       	cli
    4b88:	de bf       	out	0x3e, r29	; 62
    4b8a:	0f be       	out	0x3f, r0	; 63
    4b8c:	cd bf       	out	0x3d, r28	; 61
    4b8e:	9d 83       	std	Y+5, r25	; 0x05
    4b90:	8c 83       	std	Y+4, r24	; 0x04
    4b92:	6e 83       	std	Y+6, r22	; 0x06
    4b94:	4f 83       	std	Y+7, r20	; 0x07
signed portBASE_TYPE xReturn;
corCRCB *pxCoRoutine;

	/* Allocate the memory that will store the co-routine control block. */
	pxCoRoutine = ( corCRCB * ) pvPortMalloc( sizeof( corCRCB ) );
    4b96:	8a e1       	ldi	r24, 0x1A	; 26
    4b98:	90 e0       	ldi	r25, 0x00	; 0
    4b9a:	0e 94 95 28 	call	0x512a	; 0x512a <pvPortMalloc>
    4b9e:	9a 83       	std	Y+2, r25	; 0x02
    4ba0:	89 83       	std	Y+1, r24	; 0x01
	if( pxCoRoutine )
    4ba2:	89 81       	ldd	r24, Y+1	; 0x01
    4ba4:	9a 81       	ldd	r25, Y+2	; 0x02
    4ba6:	00 97       	sbiw	r24, 0x00	; 0
    4ba8:	09 f4       	brne	.+2      	; 0x4bac <xCoRoutineCreate+0x32>
    4baa:	6f c0       	rjmp	.+222    	; 0x4c8a <xCoRoutineCreate+0x110>
	{
		/* If pxCurrentCoRoutine is NULL then this is the first co-routine to
		be created and the co-routine data structures need initialising. */
		if( pxCurrentCoRoutine == NULL )
    4bac:	80 91 37 01 	lds	r24, 0x0137
    4bb0:	90 91 38 01 	lds	r25, 0x0138
    4bb4:	00 97       	sbiw	r24, 0x00	; 0
    4bb6:	41 f4       	brne	.+16     	; 0x4bc8 <xCoRoutineCreate+0x4e>
		{
			pxCurrentCoRoutine = pxCoRoutine;
    4bb8:	89 81       	ldd	r24, Y+1	; 0x01
    4bba:	9a 81       	ldd	r25, Y+2	; 0x02
    4bbc:	90 93 38 01 	sts	0x0138, r25
    4bc0:	80 93 37 01 	sts	0x0137, r24
			prvInitialiseCoRoutineLists();
    4bc4:	0e 94 24 28 	call	0x5048	; 0x5048 <prvInitialiseCoRoutineLists>
		}

		/* Check the priority is within limits. */
		if( uxPriority >= configMAX_CO_ROUTINE_PRIORITIES )
    4bc8:	8e 81       	ldd	r24, Y+6	; 0x06
    4bca:	82 30       	cpi	r24, 0x02	; 2
    4bcc:	10 f0       	brcs	.+4      	; 0x4bd2 <xCoRoutineCreate+0x58>
		{
			uxPriority = configMAX_CO_ROUTINE_PRIORITIES - 1;
    4bce:	81 e0       	ldi	r24, 0x01	; 1
    4bd0:	8e 83       	std	Y+6, r24	; 0x06
		}

		/* Fill out the co-routine control block from the function parameters. */
		pxCoRoutine->uxState = corINITIAL_STATE;
    4bd2:	e9 81       	ldd	r30, Y+1	; 0x01
    4bd4:	fa 81       	ldd	r31, Y+2	; 0x02
    4bd6:	11 8e       	std	Z+25, r1	; 0x19
    4bd8:	10 8e       	std	Z+24, r1	; 0x18
		pxCoRoutine->uxPriority = uxPriority;
    4bda:	e9 81       	ldd	r30, Y+1	; 0x01
    4bdc:	fa 81       	ldd	r31, Y+2	; 0x02
    4bde:	8e 81       	ldd	r24, Y+6	; 0x06
    4be0:	86 8b       	std	Z+22, r24	; 0x16
		pxCoRoutine->uxIndex = uxIndex;
    4be2:	e9 81       	ldd	r30, Y+1	; 0x01
    4be4:	fa 81       	ldd	r31, Y+2	; 0x02
    4be6:	8f 81       	ldd	r24, Y+7	; 0x07
    4be8:	87 8b       	std	Z+23, r24	; 0x17
		pxCoRoutine->pxCoRoutineFunction = pxCoRoutineCode;
    4bea:	e9 81       	ldd	r30, Y+1	; 0x01
    4bec:	fa 81       	ldd	r31, Y+2	; 0x02
    4bee:	8c 81       	ldd	r24, Y+4	; 0x04
    4bf0:	9d 81       	ldd	r25, Y+5	; 0x05
    4bf2:	91 83       	std	Z+1, r25	; 0x01
    4bf4:	80 83       	st	Z, r24

		/* Initialise all the other co-routine control block parameters. */
		vListInitialiseItem( &( pxCoRoutine->xGenericListItem ) );
    4bf6:	89 81       	ldd	r24, Y+1	; 0x01
    4bf8:	9a 81       	ldd	r25, Y+2	; 0x02
    4bfa:	02 96       	adiw	r24, 0x02	; 2
    4bfc:	0e 94 2b 29 	call	0x5256	; 0x5256 <vListInitialiseItem>
		vListInitialiseItem( &( pxCoRoutine->xEventListItem ) );
    4c00:	89 81       	ldd	r24, Y+1	; 0x01
    4c02:	9a 81       	ldd	r25, Y+2	; 0x02
    4c04:	0c 96       	adiw	r24, 0x0c	; 12
    4c06:	0e 94 2b 29 	call	0x5256	; 0x5256 <vListInitialiseItem>

		/* Set the co-routine control block as a link back from the xListItem.
		This is so we can get back to the containing CRCB from a generic item
		in a list. */
		listSET_LIST_ITEM_OWNER( &( pxCoRoutine->xGenericListItem ), pxCoRoutine );
    4c0a:	e9 81       	ldd	r30, Y+1	; 0x01
    4c0c:	fa 81       	ldd	r31, Y+2	; 0x02
    4c0e:	89 81       	ldd	r24, Y+1	; 0x01
    4c10:	9a 81       	ldd	r25, Y+2	; 0x02
    4c12:	91 87       	std	Z+9, r25	; 0x09
    4c14:	80 87       	std	Z+8, r24	; 0x08
		listSET_LIST_ITEM_OWNER( &( pxCoRoutine->xEventListItem ), pxCoRoutine );
    4c16:	e9 81       	ldd	r30, Y+1	; 0x01
    4c18:	fa 81       	ldd	r31, Y+2	; 0x02
    4c1a:	89 81       	ldd	r24, Y+1	; 0x01
    4c1c:	9a 81       	ldd	r25, Y+2	; 0x02
    4c1e:	93 8b       	std	Z+19, r25	; 0x13
    4c20:	82 8b       	std	Z+18, r24	; 0x12
	
		/* Event lists are always in priority order. */
		listSET_LIST_ITEM_VALUE( &( pxCoRoutine->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPriority );
    4c22:	8e 81       	ldd	r24, Y+6	; 0x06
    4c24:	28 2f       	mov	r18, r24
    4c26:	30 e0       	ldi	r19, 0x00	; 0
    4c28:	83 e0       	ldi	r24, 0x03	; 3
    4c2a:	90 e0       	ldi	r25, 0x00	; 0
    4c2c:	82 1b       	sub	r24, r18
    4c2e:	93 0b       	sbc	r25, r19
    4c30:	e9 81       	ldd	r30, Y+1	; 0x01
    4c32:	fa 81       	ldd	r31, Y+2	; 0x02
    4c34:	95 87       	std	Z+13, r25	; 0x0d
    4c36:	84 87       	std	Z+12, r24	; 0x0c
		
		/* Now the co-routine has been initialised it can be added to the ready
		list at the correct priority. */
		prvAddCoRoutineToReadyQueue( pxCoRoutine );
    4c38:	e9 81       	ldd	r30, Y+1	; 0x01
    4c3a:	fa 81       	ldd	r31, Y+2	; 0x02
    4c3c:	96 89       	ldd	r25, Z+22	; 0x16
    4c3e:	80 91 39 01 	lds	r24, 0x0139
    4c42:	89 17       	cp	r24, r25
    4c44:	28 f4       	brcc	.+10     	; 0x4c50 <xCoRoutineCreate+0xd6>
    4c46:	e9 81       	ldd	r30, Y+1	; 0x01
    4c48:	fa 81       	ldd	r31, Y+2	; 0x02
    4c4a:	86 89       	ldd	r24, Z+22	; 0x16
    4c4c:	80 93 39 01 	sts	0x0139, r24
    4c50:	e9 81       	ldd	r30, Y+1	; 0x01
    4c52:	fa 81       	ldd	r31, Y+2	; 0x02
    4c54:	86 89       	ldd	r24, Z+22	; 0x16
    4c56:	28 2f       	mov	r18, r24
    4c58:	30 e0       	ldi	r19, 0x00	; 0
    4c5a:	c9 01       	movw	r24, r18
    4c5c:	88 0f       	add	r24, r24
    4c5e:	99 1f       	adc	r25, r25
    4c60:	88 0f       	add	r24, r24
    4c62:	99 1f       	adc	r25, r25
    4c64:	88 0f       	add	r24, r24
    4c66:	99 1f       	adc	r25, r25
    4c68:	82 0f       	add	r24, r18
    4c6a:	93 1f       	adc	r25, r19
    4c6c:	ac 01       	movw	r20, r24
    4c6e:	40 5c       	subi	r20, 0xC0	; 192
    4c70:	5e 4f       	sbci	r21, 0xFE	; 254
    4c72:	89 81       	ldd	r24, Y+1	; 0x01
    4c74:	9a 81       	ldd	r25, Y+2	; 0x02
    4c76:	9c 01       	movw	r18, r24
    4c78:	2e 5f       	subi	r18, 0xFE	; 254
    4c7a:	3f 4f       	sbci	r19, 0xFF	; 255
    4c7c:	ca 01       	movw	r24, r20
    4c7e:	b9 01       	movw	r22, r18
    4c80:	0e 94 3b 29 	call	0x5276	; 0x5276 <vListInsertEnd>

		xReturn = pdPASS;
    4c84:	81 e0       	ldi	r24, 0x01	; 1
    4c86:	8b 83       	std	Y+3, r24	; 0x03
    4c88:	02 c0       	rjmp	.+4      	; 0x4c8e <xCoRoutineCreate+0x114>
	}
	else
	{		
		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
    4c8a:	8f ef       	ldi	r24, 0xFF	; 255
    4c8c:	8b 83       	std	Y+3, r24	; 0x03
	}
	
	return xReturn;	
    4c8e:	8b 81       	ldd	r24, Y+3	; 0x03
}
    4c90:	27 96       	adiw	r28, 0x07	; 7
    4c92:	0f b6       	in	r0, 0x3f	; 63
    4c94:	f8 94       	cli
    4c96:	de bf       	out	0x3e, r29	; 62
    4c98:	0f be       	out	0x3f, r0	; 63
    4c9a:	cd bf       	out	0x3d, r28	; 61
    4c9c:	cf 91       	pop	r28
    4c9e:	df 91       	pop	r29
    4ca0:	08 95       	ret

00004ca2 <vCoRoutineAddToDelayedList>:
/*-----------------------------------------------------------*/

void vCoRoutineAddToDelayedList( portTickType xTicksToDelay, xList *pxEventList )
{
    4ca2:	df 93       	push	r29
    4ca4:	cf 93       	push	r28
    4ca6:	00 d0       	rcall	.+0      	; 0x4ca8 <vCoRoutineAddToDelayedList+0x6>
    4ca8:	00 d0       	rcall	.+0      	; 0x4caa <vCoRoutineAddToDelayedList+0x8>
    4caa:	00 d0       	rcall	.+0      	; 0x4cac <vCoRoutineAddToDelayedList+0xa>
    4cac:	cd b7       	in	r28, 0x3d	; 61
    4cae:	de b7       	in	r29, 0x3e	; 62
    4cb0:	9c 83       	std	Y+4, r25	; 0x04
    4cb2:	8b 83       	std	Y+3, r24	; 0x03
    4cb4:	7e 83       	std	Y+6, r23	; 0x06
    4cb6:	6d 83       	std	Y+5, r22	; 0x05
portTickType xTimeToWake;

	/* Calculate the time to wake - this may overflow but this is
	not a problem. */
	xTimeToWake = xCoRoutineTickCount + xTicksToDelay;
    4cb8:	20 91 3a 01 	lds	r18, 0x013A
    4cbc:	30 91 3b 01 	lds	r19, 0x013B
    4cc0:	8b 81       	ldd	r24, Y+3	; 0x03
    4cc2:	9c 81       	ldd	r25, Y+4	; 0x04
    4cc4:	82 0f       	add	r24, r18
    4cc6:	93 1f       	adc	r25, r19
    4cc8:	9a 83       	std	Y+2, r25	; 0x02
    4cca:	89 83       	std	Y+1, r24	; 0x01

	/* We must remove ourselves from the ready list before adding
	ourselves to the blocked list as the same list item is used for
	both lists. */
	vListRemove( ( xListItem * ) &( pxCurrentCoRoutine->xGenericListItem ) );
    4ccc:	80 91 37 01 	lds	r24, 0x0137
    4cd0:	90 91 38 01 	lds	r25, 0x0138
    4cd4:	02 96       	adiw	r24, 0x02	; 2
    4cd6:	0e 94 f3 29 	call	0x53e6	; 0x53e6 <vListRemove>

	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentCoRoutine->xGenericListItem ), xTimeToWake );
    4cda:	e0 91 37 01 	lds	r30, 0x0137
    4cde:	f0 91 38 01 	lds	r31, 0x0138
    4ce2:	89 81       	ldd	r24, Y+1	; 0x01
    4ce4:	9a 81       	ldd	r25, Y+2	; 0x02
    4ce6:	93 83       	std	Z+3, r25	; 0x03
    4ce8:	82 83       	std	Z+2, r24	; 0x02

	if( xTimeToWake < xCoRoutineTickCount )
    4cea:	20 91 3a 01 	lds	r18, 0x013A
    4cee:	30 91 3b 01 	lds	r19, 0x013B
    4cf2:	89 81       	ldd	r24, Y+1	; 0x01
    4cf4:	9a 81       	ldd	r25, Y+2	; 0x02
    4cf6:	82 17       	cp	r24, r18
    4cf8:	93 07       	cpc	r25, r19
    4cfa:	70 f4       	brcc	.+28     	; 0x4d18 <vCoRoutineAddToDelayedList+0x76>
	{
		/* Wake time has overflowed.  Place this item in the
		overflow list. */
		vListInsert( ( xList * ) pxOverflowDelayedCoRoutineList, ( xListItem * ) &( pxCurrentCoRoutine->xGenericListItem ) );
    4cfc:	80 91 66 01 	lds	r24, 0x0166
    4d00:	90 91 67 01 	lds	r25, 0x0167
    4d04:	20 91 37 01 	lds	r18, 0x0137
    4d08:	30 91 38 01 	lds	r19, 0x0138
    4d0c:	2e 5f       	subi	r18, 0xFE	; 254
    4d0e:	3f 4f       	sbci	r19, 0xFF	; 255
    4d10:	b9 01       	movw	r22, r18
    4d12:	0e 94 87 29 	call	0x530e	; 0x530e <vListInsert>
    4d16:	0d c0       	rjmp	.+26     	; 0x4d32 <vCoRoutineAddToDelayedList+0x90>
	}
	else
	{
		/* The wake time has not overflowed, so we can use the
		current block list. */
		vListInsert( ( xList * ) pxDelayedCoRoutineList, ( xListItem * ) &( pxCurrentCoRoutine->xGenericListItem ) );
    4d18:	80 91 64 01 	lds	r24, 0x0164
    4d1c:	90 91 65 01 	lds	r25, 0x0165
    4d20:	20 91 37 01 	lds	r18, 0x0137
    4d24:	30 91 38 01 	lds	r19, 0x0138
    4d28:	2e 5f       	subi	r18, 0xFE	; 254
    4d2a:	3f 4f       	sbci	r19, 0xFF	; 255
    4d2c:	b9 01       	movw	r22, r18
    4d2e:	0e 94 87 29 	call	0x530e	; 0x530e <vListInsert>
	}

	if( pxEventList )
    4d32:	8d 81       	ldd	r24, Y+5	; 0x05
    4d34:	9e 81       	ldd	r25, Y+6	; 0x06
    4d36:	00 97       	sbiw	r24, 0x00	; 0
    4d38:	61 f0       	breq	.+24     	; 0x4d52 <vCoRoutineAddToDelayedList+0xb0>
	{
		/* Also add the co-routine to an event list.  If this is done then the
		function must be called with interrupts disabled. */
		vListInsert( pxEventList, &( pxCurrentCoRoutine->xEventListItem ) );
    4d3a:	80 91 37 01 	lds	r24, 0x0137
    4d3e:	90 91 38 01 	lds	r25, 0x0138
    4d42:	9c 01       	movw	r18, r24
    4d44:	24 5f       	subi	r18, 0xF4	; 244
    4d46:	3f 4f       	sbci	r19, 0xFF	; 255
    4d48:	8d 81       	ldd	r24, Y+5	; 0x05
    4d4a:	9e 81       	ldd	r25, Y+6	; 0x06
    4d4c:	b9 01       	movw	r22, r18
    4d4e:	0e 94 87 29 	call	0x530e	; 0x530e <vListInsert>
	}
}
    4d52:	26 96       	adiw	r28, 0x06	; 6
    4d54:	0f b6       	in	r0, 0x3f	; 63
    4d56:	f8 94       	cli
    4d58:	de bf       	out	0x3e, r29	; 62
    4d5a:	0f be       	out	0x3f, r0	; 63
    4d5c:	cd bf       	out	0x3d, r28	; 61
    4d5e:	cf 91       	pop	r28
    4d60:	df 91       	pop	r29
    4d62:	08 95       	ret

00004d64 <prvCheckPendingReadyList>:
/*-----------------------------------------------------------*/

static void prvCheckPendingReadyList( void )
{
    4d64:	df 93       	push	r29
    4d66:	cf 93       	push	r28
    4d68:	00 d0       	rcall	.+0      	; 0x4d6a <prvCheckPendingReadyList+0x6>
    4d6a:	cd b7       	in	r28, 0x3d	; 61
    4d6c:	de b7       	in	r29, 0x3e	; 62
    4d6e:	3a c0       	rjmp	.+116    	; 0x4de4 <prvCheckPendingReadyList+0x80>
	while( listLIST_IS_EMPTY( &xPendingReadyCoRoutineList ) == pdFALSE )
	{
		corCRCB *pxUnblockedCRCB;

		/* The pending ready list can be accessed by an ISR. */
		portDISABLE_INTERRUPTS();
    4d70:	f8 94       	cli
		{	
			pxUnblockedCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( (&xPendingReadyCoRoutineList) );			
    4d72:	e0 91 6d 01 	lds	r30, 0x016D
    4d76:	f0 91 6e 01 	lds	r31, 0x016E
    4d7a:	86 81       	ldd	r24, Z+6	; 0x06
    4d7c:	97 81       	ldd	r25, Z+7	; 0x07
    4d7e:	9a 83       	std	Y+2, r25	; 0x02
    4d80:	89 83       	std	Y+1, r24	; 0x01
			vListRemove( &( pxUnblockedCRCB->xEventListItem ) );
    4d82:	89 81       	ldd	r24, Y+1	; 0x01
    4d84:	9a 81       	ldd	r25, Y+2	; 0x02
    4d86:	0c 96       	adiw	r24, 0x0c	; 12
    4d88:	0e 94 f3 29 	call	0x53e6	; 0x53e6 <vListRemove>
		}
		portENABLE_INTERRUPTS();
    4d8c:	78 94       	sei

		vListRemove( &( pxUnblockedCRCB->xGenericListItem ) );
    4d8e:	89 81       	ldd	r24, Y+1	; 0x01
    4d90:	9a 81       	ldd	r25, Y+2	; 0x02
    4d92:	02 96       	adiw	r24, 0x02	; 2
    4d94:	0e 94 f3 29 	call	0x53e6	; 0x53e6 <vListRemove>
		prvAddCoRoutineToReadyQueue( pxUnblockedCRCB );	
    4d98:	e9 81       	ldd	r30, Y+1	; 0x01
    4d9a:	fa 81       	ldd	r31, Y+2	; 0x02
    4d9c:	96 89       	ldd	r25, Z+22	; 0x16
    4d9e:	80 91 39 01 	lds	r24, 0x0139
    4da2:	89 17       	cp	r24, r25
    4da4:	28 f4       	brcc	.+10     	; 0x4db0 <prvCheckPendingReadyList+0x4c>
    4da6:	e9 81       	ldd	r30, Y+1	; 0x01
    4da8:	fa 81       	ldd	r31, Y+2	; 0x02
    4daa:	86 89       	ldd	r24, Z+22	; 0x16
    4dac:	80 93 39 01 	sts	0x0139, r24
    4db0:	e9 81       	ldd	r30, Y+1	; 0x01
    4db2:	fa 81       	ldd	r31, Y+2	; 0x02
    4db4:	86 89       	ldd	r24, Z+22	; 0x16
    4db6:	28 2f       	mov	r18, r24
    4db8:	30 e0       	ldi	r19, 0x00	; 0
    4dba:	c9 01       	movw	r24, r18
    4dbc:	88 0f       	add	r24, r24
    4dbe:	99 1f       	adc	r25, r25
    4dc0:	88 0f       	add	r24, r24
    4dc2:	99 1f       	adc	r25, r25
    4dc4:	88 0f       	add	r24, r24
    4dc6:	99 1f       	adc	r25, r25
    4dc8:	82 0f       	add	r24, r18
    4dca:	93 1f       	adc	r25, r19
    4dcc:	ac 01       	movw	r20, r24
    4dce:	40 5c       	subi	r20, 0xC0	; 192
    4dd0:	5e 4f       	sbci	r21, 0xFE	; 254
    4dd2:	89 81       	ldd	r24, Y+1	; 0x01
    4dd4:	9a 81       	ldd	r25, Y+2	; 0x02
    4dd6:	9c 01       	movw	r18, r24
    4dd8:	2e 5f       	subi	r18, 0xFE	; 254
    4dda:	3f 4f       	sbci	r19, 0xFF	; 255
    4ddc:	ca 01       	movw	r24, r20
    4dde:	b9 01       	movw	r22, r18
    4de0:	0e 94 3b 29 	call	0x5276	; 0x5276 <vListInsertEnd>
static void prvCheckPendingReadyList( void )
{
	/* Are there any co-routines waiting to get moved to the ready list?  These
	are co-routines that have been readied by an ISR.  The ISR cannot access
	the	ready lists itself. */
	while( listLIST_IS_EMPTY( &xPendingReadyCoRoutineList ) == pdFALSE )
    4de4:	80 91 68 01 	lds	r24, 0x0168
    4de8:	88 23       	and	r24, r24
    4dea:	09 f0       	breq	.+2      	; 0x4dee <prvCheckPendingReadyList+0x8a>
    4dec:	c1 cf       	rjmp	.-126    	; 0x4d70 <prvCheckPendingReadyList+0xc>
		portENABLE_INTERRUPTS();

		vListRemove( &( pxUnblockedCRCB->xGenericListItem ) );
		prvAddCoRoutineToReadyQueue( pxUnblockedCRCB );	
	}
}
    4dee:	0f 90       	pop	r0
    4df0:	0f 90       	pop	r0
    4df2:	cf 91       	pop	r28
    4df4:	df 91       	pop	r29
    4df6:	08 95       	ret

00004df8 <prvCheckDelayedList>:
/*-----------------------------------------------------------*/

static void prvCheckDelayedList( void )
{
    4df8:	df 93       	push	r29
    4dfa:	cf 93       	push	r28
    4dfc:	00 d0       	rcall	.+0      	; 0x4dfe <prvCheckDelayedList+0x6>
    4dfe:	00 d0       	rcall	.+0      	; 0x4e00 <prvCheckDelayedList+0x8>
    4e00:	cd b7       	in	r28, 0x3d	; 61
    4e02:	de b7       	in	r29, 0x3e	; 62
corCRCB *pxCRCB;

	xPassedTicks = xTaskGetTickCount() - xLastTickCount;
    4e04:	0e 94 80 34 	call	0x6900	; 0x6900 <xTaskGetTickCount>
    4e08:	20 91 3c 01 	lds	r18, 0x013C
    4e0c:	30 91 3d 01 	lds	r19, 0x013D
    4e10:	82 1b       	sub	r24, r18
    4e12:	93 0b       	sbc	r25, r19
    4e14:	90 93 3f 01 	sts	0x013F, r25
    4e18:	80 93 3e 01 	sts	0x013E, r24
    4e1c:	85 c0       	rjmp	.+266    	; 0x4f28 <prvCheckDelayedList+0x130>
	while( xPassedTicks )
	{
		xCoRoutineTickCount++;
    4e1e:	80 91 3a 01 	lds	r24, 0x013A
    4e22:	90 91 3b 01 	lds	r25, 0x013B
    4e26:	01 96       	adiw	r24, 0x01	; 1
    4e28:	90 93 3b 01 	sts	0x013B, r25
    4e2c:	80 93 3a 01 	sts	0x013A, r24
		xPassedTicks--;
    4e30:	80 91 3e 01 	lds	r24, 0x013E
    4e34:	90 91 3f 01 	lds	r25, 0x013F
    4e38:	01 97       	sbiw	r24, 0x01	; 1
    4e3a:	90 93 3f 01 	sts	0x013F, r25
    4e3e:	80 93 3e 01 	sts	0x013E, r24

		/* If the tick count has overflowed we need to swap the ready lists. */
		if( xCoRoutineTickCount == 0 )
    4e42:	80 91 3a 01 	lds	r24, 0x013A
    4e46:	90 91 3b 01 	lds	r25, 0x013B
    4e4a:	00 97       	sbiw	r24, 0x00	; 0
    4e4c:	09 f0       	breq	.+2      	; 0x4e50 <prvCheckDelayedList+0x58>
    4e4e:	64 c0       	rjmp	.+200    	; 0x4f18 <prvCheckDelayedList+0x120>
		{
			xList * pxTemp;

			/* Tick count has overflowed so we need to swap the delay lists.  If there are
			any items in pxDelayedCoRoutineList here then there is an error! */
			pxTemp = pxDelayedCoRoutineList;
    4e50:	80 91 64 01 	lds	r24, 0x0164
    4e54:	90 91 65 01 	lds	r25, 0x0165
    4e58:	9a 83       	std	Y+2, r25	; 0x02
    4e5a:	89 83       	std	Y+1, r24	; 0x01
			pxDelayedCoRoutineList = pxOverflowDelayedCoRoutineList;
    4e5c:	80 91 66 01 	lds	r24, 0x0166
    4e60:	90 91 67 01 	lds	r25, 0x0167
    4e64:	90 93 65 01 	sts	0x0165, r25
    4e68:	80 93 64 01 	sts	0x0164, r24
			pxOverflowDelayedCoRoutineList = pxTemp;
    4e6c:	89 81       	ldd	r24, Y+1	; 0x01
    4e6e:	9a 81       	ldd	r25, Y+2	; 0x02
    4e70:	90 93 67 01 	sts	0x0167, r25
    4e74:	80 93 66 01 	sts	0x0166, r24
    4e78:	4f c0       	rjmp	.+158    	; 0x4f18 <prvCheckDelayedList+0x120>
		}

		/* See if this tick has made a timeout expire. */
		while( listLIST_IS_EMPTY( pxDelayedCoRoutineList ) == pdFALSE )
		{
			pxCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedCoRoutineList );
    4e7a:	e0 91 64 01 	lds	r30, 0x0164
    4e7e:	f0 91 65 01 	lds	r31, 0x0165
    4e82:	05 80       	ldd	r0, Z+5	; 0x05
    4e84:	f6 81       	ldd	r31, Z+6	; 0x06
    4e86:	e0 2d       	mov	r30, r0
    4e88:	86 81       	ldd	r24, Z+6	; 0x06
    4e8a:	97 81       	ldd	r25, Z+7	; 0x07
    4e8c:	9c 83       	std	Y+4, r25	; 0x04
    4e8e:	8b 83       	std	Y+3, r24	; 0x03

			if( xCoRoutineTickCount < listGET_LIST_ITEM_VALUE( &( pxCRCB->xGenericListItem ) ) )				
    4e90:	eb 81       	ldd	r30, Y+3	; 0x03
    4e92:	fc 81       	ldd	r31, Y+4	; 0x04
    4e94:	22 81       	ldd	r18, Z+2	; 0x02
    4e96:	33 81       	ldd	r19, Z+3	; 0x03
    4e98:	80 91 3a 01 	lds	r24, 0x013A
    4e9c:	90 91 3b 01 	lds	r25, 0x013B
    4ea0:	82 17       	cp	r24, r18
    4ea2:	93 07       	cpc	r25, r19
    4ea4:	08 f4       	brcc	.+2      	; 0x4ea8 <prvCheckDelayedList+0xb0>
    4ea6:	40 c0       	rjmp	.+128    	; 0x4f28 <prvCheckDelayedList+0x130>
			{			
				/* Timeout not yet expired. */																			
				break;																				
			}																						

			portDISABLE_INTERRUPTS();
    4ea8:	f8 94       	cli
				/* The event could have occurred just before this critical
				section.  If this is the case then the generic list item will
				have been moved to the pending ready list and the following
				line is still valid.  Also the pvContainer parameter will have
				been set to NULL so the following lines are also valid. */
				vListRemove( &( pxCRCB->xGenericListItem ) );											
    4eaa:	8b 81       	ldd	r24, Y+3	; 0x03
    4eac:	9c 81       	ldd	r25, Y+4	; 0x04
    4eae:	02 96       	adiw	r24, 0x02	; 2
    4eb0:	0e 94 f3 29 	call	0x53e6	; 0x53e6 <vListRemove>

				/* Is the co-routine waiting on an event also? */												
				if( pxCRCB->xEventListItem.pvContainer )													
    4eb4:	eb 81       	ldd	r30, Y+3	; 0x03
    4eb6:	fc 81       	ldd	r31, Y+4	; 0x04
    4eb8:	84 89       	ldd	r24, Z+20	; 0x14
    4eba:	95 89       	ldd	r25, Z+21	; 0x15
    4ebc:	00 97       	sbiw	r24, 0x00	; 0
    4ebe:	29 f0       	breq	.+10     	; 0x4eca <prvCheckDelayedList+0xd2>
				{															
					vListRemove( &( pxCRCB->xEventListItem ) );											
    4ec0:	8b 81       	ldd	r24, Y+3	; 0x03
    4ec2:	9c 81       	ldd	r25, Y+4	; 0x04
    4ec4:	0c 96       	adiw	r24, 0x0c	; 12
    4ec6:	0e 94 f3 29 	call	0x53e6	; 0x53e6 <vListRemove>
				}
			}
			portENABLE_INTERRUPTS();
    4eca:	78 94       	sei

			prvAddCoRoutineToReadyQueue( pxCRCB );													
    4ecc:	eb 81       	ldd	r30, Y+3	; 0x03
    4ece:	fc 81       	ldd	r31, Y+4	; 0x04
    4ed0:	96 89       	ldd	r25, Z+22	; 0x16
    4ed2:	80 91 39 01 	lds	r24, 0x0139
    4ed6:	89 17       	cp	r24, r25
    4ed8:	28 f4       	brcc	.+10     	; 0x4ee4 <prvCheckDelayedList+0xec>
    4eda:	eb 81       	ldd	r30, Y+3	; 0x03
    4edc:	fc 81       	ldd	r31, Y+4	; 0x04
    4ede:	86 89       	ldd	r24, Z+22	; 0x16
    4ee0:	80 93 39 01 	sts	0x0139, r24
    4ee4:	eb 81       	ldd	r30, Y+3	; 0x03
    4ee6:	fc 81       	ldd	r31, Y+4	; 0x04
    4ee8:	86 89       	ldd	r24, Z+22	; 0x16
    4eea:	28 2f       	mov	r18, r24
    4eec:	30 e0       	ldi	r19, 0x00	; 0
    4eee:	c9 01       	movw	r24, r18
    4ef0:	88 0f       	add	r24, r24
    4ef2:	99 1f       	adc	r25, r25
    4ef4:	88 0f       	add	r24, r24
    4ef6:	99 1f       	adc	r25, r25
    4ef8:	88 0f       	add	r24, r24
    4efa:	99 1f       	adc	r25, r25
    4efc:	82 0f       	add	r24, r18
    4efe:	93 1f       	adc	r25, r19
    4f00:	ac 01       	movw	r20, r24
    4f02:	40 5c       	subi	r20, 0xC0	; 192
    4f04:	5e 4f       	sbci	r21, 0xFE	; 254
    4f06:	8b 81       	ldd	r24, Y+3	; 0x03
    4f08:	9c 81       	ldd	r25, Y+4	; 0x04
    4f0a:	9c 01       	movw	r18, r24
    4f0c:	2e 5f       	subi	r18, 0xFE	; 254
    4f0e:	3f 4f       	sbci	r19, 0xFF	; 255
    4f10:	ca 01       	movw	r24, r20
    4f12:	b9 01       	movw	r22, r18
    4f14:	0e 94 3b 29 	call	0x5276	; 0x5276 <vListInsertEnd>
			pxDelayedCoRoutineList = pxOverflowDelayedCoRoutineList;
			pxOverflowDelayedCoRoutineList = pxTemp;
		}

		/* See if this tick has made a timeout expire. */
		while( listLIST_IS_EMPTY( pxDelayedCoRoutineList ) == pdFALSE )
    4f18:	e0 91 64 01 	lds	r30, 0x0164
    4f1c:	f0 91 65 01 	lds	r31, 0x0165
    4f20:	80 81       	ld	r24, Z
    4f22:	88 23       	and	r24, r24
    4f24:	09 f0       	breq	.+2      	; 0x4f28 <prvCheckDelayedList+0x130>
    4f26:	a9 cf       	rjmp	.-174    	; 0x4e7a <prvCheckDelayedList+0x82>
static void prvCheckDelayedList( void )
{
corCRCB *pxCRCB;

	xPassedTicks = xTaskGetTickCount() - xLastTickCount;
	while( xPassedTicks )
    4f28:	80 91 3e 01 	lds	r24, 0x013E
    4f2c:	90 91 3f 01 	lds	r25, 0x013F
    4f30:	00 97       	sbiw	r24, 0x00	; 0
    4f32:	09 f0       	breq	.+2      	; 0x4f36 <prvCheckDelayedList+0x13e>
    4f34:	74 cf       	rjmp	.-280    	; 0x4e1e <prvCheckDelayedList+0x26>

			prvAddCoRoutineToReadyQueue( pxCRCB );													
		}																									
	}

	xLastTickCount = xCoRoutineTickCount;
    4f36:	80 91 3a 01 	lds	r24, 0x013A
    4f3a:	90 91 3b 01 	lds	r25, 0x013B
    4f3e:	90 93 3d 01 	sts	0x013D, r25
    4f42:	80 93 3c 01 	sts	0x013C, r24
}
    4f46:	0f 90       	pop	r0
    4f48:	0f 90       	pop	r0
    4f4a:	0f 90       	pop	r0
    4f4c:	0f 90       	pop	r0
    4f4e:	cf 91       	pop	r28
    4f50:	df 91       	pop	r29
    4f52:	08 95       	ret

00004f54 <vCoRoutineSchedule>:
/*-----------------------------------------------------------*/

void vCoRoutineSchedule( void )
{
    4f54:	df 93       	push	r29
    4f56:	cf 93       	push	r28
    4f58:	00 d0       	rcall	.+0      	; 0x4f5a <vCoRoutineSchedule+0x6>
    4f5a:	cd b7       	in	r28, 0x3d	; 61
    4f5c:	de b7       	in	r29, 0x3e	; 62
	/* See if any co-routines readied by events need moving to the ready lists. */
	prvCheckPendingReadyList();
    4f5e:	0e 94 b2 26 	call	0x4d64	; 0x4d64 <prvCheckPendingReadyList>

	/* See if any delayed co-routines have timed out. */
	prvCheckDelayedList();
    4f62:	0e 94 fc 26 	call	0x4df8	; 0x4df8 <prvCheckDelayedList>
    4f66:	0a c0       	rjmp	.+20     	; 0x4f7c <vCoRoutineSchedule+0x28>

	/* Find the highest priority queue that contains ready co-routines. */
	while( listLIST_IS_EMPTY( &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) ) )
	{
		if( uxTopCoRoutineReadyPriority == 0 )
    4f68:	80 91 39 01 	lds	r24, 0x0139
    4f6c:	88 23       	and	r24, r24
    4f6e:	09 f4       	brne	.+2      	; 0x4f72 <vCoRoutineSchedule+0x1e>
    4f70:	66 c0       	rjmp	.+204    	; 0x503e <vCoRoutineSchedule+0xea>
		{
			/* No more co-routines to check. */
			return;
		}
		--uxTopCoRoutineReadyPriority;
    4f72:	80 91 39 01 	lds	r24, 0x0139
    4f76:	81 50       	subi	r24, 0x01	; 1
    4f78:	80 93 39 01 	sts	0x0139, r24

	/* See if any delayed co-routines have timed out. */
	prvCheckDelayedList();

	/* Find the highest priority queue that contains ready co-routines. */
	while( listLIST_IS_EMPTY( &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) ) )
    4f7c:	80 91 39 01 	lds	r24, 0x0139
    4f80:	28 2f       	mov	r18, r24
    4f82:	30 e0       	ldi	r19, 0x00	; 0
    4f84:	c9 01       	movw	r24, r18
    4f86:	88 0f       	add	r24, r24
    4f88:	99 1f       	adc	r25, r25
    4f8a:	88 0f       	add	r24, r24
    4f8c:	99 1f       	adc	r25, r25
    4f8e:	88 0f       	add	r24, r24
    4f90:	99 1f       	adc	r25, r25
    4f92:	82 0f       	add	r24, r18
    4f94:	93 1f       	adc	r25, r19
    4f96:	fc 01       	movw	r30, r24
    4f98:	e0 5c       	subi	r30, 0xC0	; 192
    4f9a:	fe 4f       	sbci	r31, 0xFE	; 254
    4f9c:	80 81       	ld	r24, Z
    4f9e:	88 23       	and	r24, r24
    4fa0:	19 f3       	breq	.-58     	; 0x4f68 <vCoRoutineSchedule+0x14>
		--uxTopCoRoutineReadyPriority;
	}

	/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the co-routines
	 of the	same priority get an equal share of the processor time. */
	listGET_OWNER_OF_NEXT_ENTRY( pxCurrentCoRoutine, &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) );
    4fa2:	80 91 39 01 	lds	r24, 0x0139
    4fa6:	28 2f       	mov	r18, r24
    4fa8:	30 e0       	ldi	r19, 0x00	; 0
    4faa:	c9 01       	movw	r24, r18
    4fac:	88 0f       	add	r24, r24
    4fae:	99 1f       	adc	r25, r25
    4fb0:	88 0f       	add	r24, r24
    4fb2:	99 1f       	adc	r25, r25
    4fb4:	88 0f       	add	r24, r24
    4fb6:	99 1f       	adc	r25, r25
    4fb8:	82 0f       	add	r24, r18
    4fba:	93 1f       	adc	r25, r19
    4fbc:	80 5c       	subi	r24, 0xC0	; 192
    4fbe:	9e 4f       	sbci	r25, 0xFE	; 254
    4fc0:	9a 83       	std	Y+2, r25	; 0x02
    4fc2:	89 83       	std	Y+1, r24	; 0x01
    4fc4:	e9 81       	ldd	r30, Y+1	; 0x01
    4fc6:	fa 81       	ldd	r31, Y+2	; 0x02
    4fc8:	01 80       	ldd	r0, Z+1	; 0x01
    4fca:	f2 81       	ldd	r31, Z+2	; 0x02
    4fcc:	e0 2d       	mov	r30, r0
    4fce:	82 81       	ldd	r24, Z+2	; 0x02
    4fd0:	93 81       	ldd	r25, Z+3	; 0x03
    4fd2:	e9 81       	ldd	r30, Y+1	; 0x01
    4fd4:	fa 81       	ldd	r31, Y+2	; 0x02
    4fd6:	92 83       	std	Z+2, r25	; 0x02
    4fd8:	81 83       	std	Z+1, r24	; 0x01
    4fda:	e9 81       	ldd	r30, Y+1	; 0x01
    4fdc:	fa 81       	ldd	r31, Y+2	; 0x02
    4fde:	21 81       	ldd	r18, Z+1	; 0x01
    4fe0:	32 81       	ldd	r19, Z+2	; 0x02
    4fe2:	89 81       	ldd	r24, Y+1	; 0x01
    4fe4:	9a 81       	ldd	r25, Y+2	; 0x02
    4fe6:	03 96       	adiw	r24, 0x03	; 3
    4fe8:	28 17       	cp	r18, r24
    4fea:	39 07       	cpc	r19, r25
    4fec:	59 f4       	brne	.+22     	; 0x5004 <vCoRoutineSchedule+0xb0>
    4fee:	e9 81       	ldd	r30, Y+1	; 0x01
    4ff0:	fa 81       	ldd	r31, Y+2	; 0x02
    4ff2:	01 80       	ldd	r0, Z+1	; 0x01
    4ff4:	f2 81       	ldd	r31, Z+2	; 0x02
    4ff6:	e0 2d       	mov	r30, r0
    4ff8:	82 81       	ldd	r24, Z+2	; 0x02
    4ffa:	93 81       	ldd	r25, Z+3	; 0x03
    4ffc:	e9 81       	ldd	r30, Y+1	; 0x01
    4ffe:	fa 81       	ldd	r31, Y+2	; 0x02
    5000:	92 83       	std	Z+2, r25	; 0x02
    5002:	81 83       	std	Z+1, r24	; 0x01
    5004:	e9 81       	ldd	r30, Y+1	; 0x01
    5006:	fa 81       	ldd	r31, Y+2	; 0x02
    5008:	01 80       	ldd	r0, Z+1	; 0x01
    500a:	f2 81       	ldd	r31, Z+2	; 0x02
    500c:	e0 2d       	mov	r30, r0
    500e:	86 81       	ldd	r24, Z+6	; 0x06
    5010:	97 81       	ldd	r25, Z+7	; 0x07
    5012:	90 93 38 01 	sts	0x0138, r25
    5016:	80 93 37 01 	sts	0x0137, r24

	/* Call the co-routine. */
	( pxCurrentCoRoutine->pxCoRoutineFunction )( pxCurrentCoRoutine, pxCurrentCoRoutine->uxIndex );
    501a:	e0 91 37 01 	lds	r30, 0x0137
    501e:	f0 91 38 01 	lds	r31, 0x0138
    5022:	40 81       	ld	r20, Z
    5024:	51 81       	ldd	r21, Z+1	; 0x01
    5026:	80 91 37 01 	lds	r24, 0x0137
    502a:	90 91 38 01 	lds	r25, 0x0138
    502e:	e0 91 37 01 	lds	r30, 0x0137
    5032:	f0 91 38 01 	lds	r31, 0x0138
    5036:	27 89       	ldd	r18, Z+23	; 0x17
    5038:	62 2f       	mov	r22, r18
    503a:	fa 01       	movw	r30, r20
    503c:	09 95       	icall

	return;
}
    503e:	0f 90       	pop	r0
    5040:	0f 90       	pop	r0
    5042:	cf 91       	pop	r28
    5044:	df 91       	pop	r29
    5046:	08 95       	ret

00005048 <prvInitialiseCoRoutineLists>:
/*-----------------------------------------------------------*/

static void prvInitialiseCoRoutineLists( void )
{
    5048:	df 93       	push	r29
    504a:	cf 93       	push	r28
    504c:	0f 92       	push	r0
    504e:	cd b7       	in	r28, 0x3d	; 61
    5050:	de b7       	in	r29, 0x3e	; 62
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = 0; uxPriority < configMAX_CO_ROUTINE_PRIORITIES; uxPriority++ )
    5052:	19 82       	std	Y+1, r1	; 0x01
    5054:	13 c0       	rjmp	.+38     	; 0x507c <prvInitialiseCoRoutineLists+0x34>
	{
		vListInitialise( ( xList * ) &( pxReadyCoRoutineLists[ uxPriority ] ) );
    5056:	89 81       	ldd	r24, Y+1	; 0x01
    5058:	28 2f       	mov	r18, r24
    505a:	30 e0       	ldi	r19, 0x00	; 0
    505c:	c9 01       	movw	r24, r18
    505e:	88 0f       	add	r24, r24
    5060:	99 1f       	adc	r25, r25
    5062:	88 0f       	add	r24, r24
    5064:	99 1f       	adc	r25, r25
    5066:	88 0f       	add	r24, r24
    5068:	99 1f       	adc	r25, r25
    506a:	82 0f       	add	r24, r18
    506c:	93 1f       	adc	r25, r19
    506e:	80 5c       	subi	r24, 0xC0	; 192
    5070:	9e 4f       	sbci	r25, 0xFE	; 254
    5072:	0e 94 01 29 	call	0x5202	; 0x5202 <vListInitialise>

static void prvInitialiseCoRoutineLists( void )
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = 0; uxPriority < configMAX_CO_ROUTINE_PRIORITIES; uxPriority++ )
    5076:	89 81       	ldd	r24, Y+1	; 0x01
    5078:	8f 5f       	subi	r24, 0xFF	; 255
    507a:	89 83       	std	Y+1, r24	; 0x01
    507c:	89 81       	ldd	r24, Y+1	; 0x01
    507e:	82 30       	cpi	r24, 0x02	; 2
    5080:	50 f3       	brcs	.-44     	; 0x5056 <prvInitialiseCoRoutineLists+0xe>
	{
		vListInitialise( ( xList * ) &( pxReadyCoRoutineLists[ uxPriority ] ) );
	}

	vListInitialise( ( xList * ) &xDelayedCoRoutineList1 );
    5082:	82 e5       	ldi	r24, 0x52	; 82
    5084:	91 e0       	ldi	r25, 0x01	; 1
    5086:	0e 94 01 29 	call	0x5202	; 0x5202 <vListInitialise>
	vListInitialise( ( xList * ) &xDelayedCoRoutineList2 );
    508a:	8b e5       	ldi	r24, 0x5B	; 91
    508c:	91 e0       	ldi	r25, 0x01	; 1
    508e:	0e 94 01 29 	call	0x5202	; 0x5202 <vListInitialise>
	vListInitialise( ( xList * ) &xPendingReadyCoRoutineList );
    5092:	88 e6       	ldi	r24, 0x68	; 104
    5094:	91 e0       	ldi	r25, 0x01	; 1
    5096:	0e 94 01 29 	call	0x5202	; 0x5202 <vListInitialise>

	/* Start with pxDelayedCoRoutineList using list1 and the
	pxOverflowDelayedCoRoutineList using list2. */
	pxDelayedCoRoutineList = &xDelayedCoRoutineList1;
    509a:	82 e5       	ldi	r24, 0x52	; 82
    509c:	91 e0       	ldi	r25, 0x01	; 1
    509e:	90 93 65 01 	sts	0x0165, r25
    50a2:	80 93 64 01 	sts	0x0164, r24
	pxOverflowDelayedCoRoutineList = &xDelayedCoRoutineList2;
    50a6:	8b e5       	ldi	r24, 0x5B	; 91
    50a8:	91 e0       	ldi	r25, 0x01	; 1
    50aa:	90 93 67 01 	sts	0x0167, r25
    50ae:	80 93 66 01 	sts	0x0166, r24
}
    50b2:	0f 90       	pop	r0
    50b4:	cf 91       	pop	r28
    50b6:	df 91       	pop	r29
    50b8:	08 95       	ret

000050ba <xCoRoutineRemoveFromEventList>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xCoRoutineRemoveFromEventList( const xList *pxEventList )
{
    50ba:	df 93       	push	r29
    50bc:	cf 93       	push	r28
    50be:	00 d0       	rcall	.+0      	; 0x50c0 <xCoRoutineRemoveFromEventList+0x6>
    50c0:	00 d0       	rcall	.+0      	; 0x50c2 <xCoRoutineRemoveFromEventList+0x8>
    50c2:	0f 92       	push	r0
    50c4:	cd b7       	in	r28, 0x3d	; 61
    50c6:	de b7       	in	r29, 0x3e	; 62
    50c8:	9d 83       	std	Y+5, r25	; 0x05
    50ca:	8c 83       	std	Y+4, r24	; 0x04
signed portBASE_TYPE xReturn;

	/* This function is called from within an interrupt.  It can only access
	event lists and the pending ready list.  This function assumes that a
	check has already been made to ensure pxEventList is not empty. */
	pxUnblockedCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
    50cc:	ec 81       	ldd	r30, Y+4	; 0x04
    50ce:	fd 81       	ldd	r31, Y+5	; 0x05
    50d0:	05 80       	ldd	r0, Z+5	; 0x05
    50d2:	f6 81       	ldd	r31, Z+6	; 0x06
    50d4:	e0 2d       	mov	r30, r0
    50d6:	86 81       	ldd	r24, Z+6	; 0x06
    50d8:	97 81       	ldd	r25, Z+7	; 0x07
    50da:	9b 83       	std	Y+3, r25	; 0x03
    50dc:	8a 83       	std	Y+2, r24	; 0x02
	vListRemove( &( pxUnblockedCRCB->xEventListItem ) );
    50de:	8a 81       	ldd	r24, Y+2	; 0x02
    50e0:	9b 81       	ldd	r25, Y+3	; 0x03
    50e2:	0c 96       	adiw	r24, 0x0c	; 12
    50e4:	0e 94 f3 29 	call	0x53e6	; 0x53e6 <vListRemove>
	vListInsertEnd( ( xList * ) &( xPendingReadyCoRoutineList ), &( pxUnblockedCRCB->xEventListItem ) );
    50e8:	8a 81       	ldd	r24, Y+2	; 0x02
    50ea:	9b 81       	ldd	r25, Y+3	; 0x03
    50ec:	9c 01       	movw	r18, r24
    50ee:	24 5f       	subi	r18, 0xF4	; 244
    50f0:	3f 4f       	sbci	r19, 0xFF	; 255
    50f2:	88 e6       	ldi	r24, 0x68	; 104
    50f4:	91 e0       	ldi	r25, 0x01	; 1
    50f6:	b9 01       	movw	r22, r18
    50f8:	0e 94 3b 29 	call	0x5276	; 0x5276 <vListInsertEnd>

	if( pxUnblockedCRCB->uxPriority >= pxCurrentCoRoutine->uxPriority )
    50fc:	ea 81       	ldd	r30, Y+2	; 0x02
    50fe:	fb 81       	ldd	r31, Y+3	; 0x03
    5100:	96 89       	ldd	r25, Z+22	; 0x16
    5102:	e0 91 37 01 	lds	r30, 0x0137
    5106:	f0 91 38 01 	lds	r31, 0x0138
    510a:	86 89       	ldd	r24, Z+22	; 0x16
    510c:	98 17       	cp	r25, r24
    510e:	18 f0       	brcs	.+6      	; 0x5116 <xCoRoutineRemoveFromEventList+0x5c>
	{
		xReturn = pdTRUE;
    5110:	81 e0       	ldi	r24, 0x01	; 1
    5112:	89 83       	std	Y+1, r24	; 0x01
    5114:	01 c0       	rjmp	.+2      	; 0x5118 <xCoRoutineRemoveFromEventList+0x5e>
	}
	else
	{
		xReturn = pdFALSE;
    5116:	19 82       	std	Y+1, r1	; 0x01
	}

	return xReturn;
    5118:	89 81       	ldd	r24, Y+1	; 0x01
}
    511a:	0f 90       	pop	r0
    511c:	0f 90       	pop	r0
    511e:	0f 90       	pop	r0
    5120:	0f 90       	pop	r0
    5122:	0f 90       	pop	r0
    5124:	cf 91       	pop	r28
    5126:	df 91       	pop	r29
    5128:	08 95       	ret

0000512a <pvPortMalloc>:

static size_t xNextFreeByte = ( size_t ) 0;
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
    512a:	df 93       	push	r29
    512c:	cf 93       	push	r28
    512e:	00 d0       	rcall	.+0      	; 0x5130 <pvPortMalloc+0x6>
    5130:	00 d0       	rcall	.+0      	; 0x5132 <pvPortMalloc+0x8>
    5132:	cd b7       	in	r28, 0x3d	; 61
    5134:	de b7       	in	r29, 0x3e	; 62
    5136:	9c 83       	std	Y+4, r25	; 0x04
    5138:	8b 83       	std	Y+3, r24	; 0x03
void *pvReturn = NULL; 
    513a:	1a 82       	std	Y+2, r1	; 0x02
    513c:	19 82       	std	Y+1, r1	; 0x01
			/* Byte alignment required. */
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
		}
	#endif

	vTaskSuspendAll();
    513e:	0e 94 ea 33 	call	0x67d4	; 0x67d4 <vTaskSuspendAll>
	{
		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configTOTAL_HEAP_SIZE ) &&
    5142:	80 91 71 01 	lds	r24, 0x0171
    5146:	90 91 72 01 	lds	r25, 0x0172
    514a:	2b 81       	ldd	r18, Y+3	; 0x03
    514c:	3c 81       	ldd	r19, Y+4	; 0x04
    514e:	82 0f       	add	r24, r18
    5150:	93 1f       	adc	r25, r19
    5152:	23 e0       	ldi	r18, 0x03	; 3
    5154:	88 3e       	cpi	r24, 0xE8	; 232
    5156:	92 07       	cpc	r25, r18
    5158:	18 f5       	brcc	.+70     	; 0x51a0 <pvPortMalloc+0x76>
    515a:	20 91 71 01 	lds	r18, 0x0171
    515e:	30 91 72 01 	lds	r19, 0x0172
    5162:	8b 81       	ldd	r24, Y+3	; 0x03
    5164:	9c 81       	ldd	r25, Y+4	; 0x04
    5166:	28 0f       	add	r18, r24
    5168:	39 1f       	adc	r19, r25
    516a:	80 91 71 01 	lds	r24, 0x0171
    516e:	90 91 72 01 	lds	r25, 0x0172
    5172:	82 17       	cp	r24, r18
    5174:	93 07       	cpc	r25, r19
    5176:	a0 f4       	brcc	.+40     	; 0x51a0 <pvPortMalloc+0x76>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = &( xHeap.ucHeap[ xNextFreeByte ] );
    5178:	80 91 71 01 	lds	r24, 0x0171
    517c:	90 91 72 01 	lds	r25, 0x0172
    5180:	8d 58       	subi	r24, 0x8D	; 141
    5182:	9e 4f       	sbci	r25, 0xFE	; 254
    5184:	9a 83       	std	Y+2, r25	; 0x02
    5186:	89 83       	std	Y+1, r24	; 0x01
			xNextFreeByte += xWantedSize;			
    5188:	20 91 71 01 	lds	r18, 0x0171
    518c:	30 91 72 01 	lds	r19, 0x0172
    5190:	8b 81       	ldd	r24, Y+3	; 0x03
    5192:	9c 81       	ldd	r25, Y+4	; 0x04
    5194:	82 0f       	add	r24, r18
    5196:	93 1f       	adc	r25, r19
    5198:	90 93 72 01 	sts	0x0172, r25
    519c:	80 93 71 01 	sts	0x0171, r24
		}	
	}
	xTaskResumeAll();
    51a0:	0e 94 f6 33 	call	0x67ec	; 0x67ec <xTaskResumeAll>
			vApplicationMallocFailedHook();
		}
	}
	#endif	

	return pvReturn;
    51a4:	89 81       	ldd	r24, Y+1	; 0x01
    51a6:	9a 81       	ldd	r25, Y+2	; 0x02
}
    51a8:	0f 90       	pop	r0
    51aa:	0f 90       	pop	r0
    51ac:	0f 90       	pop	r0
    51ae:	0f 90       	pop	r0
    51b0:	cf 91       	pop	r28
    51b2:	df 91       	pop	r29
    51b4:	08 95       	ret

000051b6 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
    51b6:	df 93       	push	r29
    51b8:	cf 93       	push	r28
    51ba:	00 d0       	rcall	.+0      	; 0x51bc <vPortFree+0x6>
    51bc:	cd b7       	in	r28, 0x3d	; 61
    51be:	de b7       	in	r29, 0x3e	; 62
    51c0:	9a 83       	std	Y+2, r25	; 0x02
    51c2:	89 83       	std	Y+1, r24	; 0x01
	/* Memory cannot be freed using this scheme.  See heap_2.c and heap_3.c 
	for alternative implementations, and the memory management pages of 
	http://www.FreeRTOS.org for more information. */
	( void ) pv;
}
    51c4:	0f 90       	pop	r0
    51c6:	0f 90       	pop	r0
    51c8:	cf 91       	pop	r28
    51ca:	df 91       	pop	r29
    51cc:	08 95       	ret

000051ce <vPortInitialiseBlocks>:
/*-----------------------------------------------------------*/

void vPortInitialiseBlocks( void )
{
    51ce:	df 93       	push	r29
    51d0:	cf 93       	push	r28
    51d2:	cd b7       	in	r28, 0x3d	; 61
    51d4:	de b7       	in	r29, 0x3e	; 62
	/* Only required when static memory is not cleared. */
	xNextFreeByte = ( size_t ) 0;
    51d6:	10 92 72 01 	sts	0x0172, r1
    51da:	10 92 71 01 	sts	0x0171, r1
}
    51de:	cf 91       	pop	r28
    51e0:	df 91       	pop	r29
    51e2:	08 95       	ret

000051e4 <xPortGetFreeHeapSize>:
/*-----------------------------------------------------------*/

size_t xPortGetFreeHeapSize( void )
{
    51e4:	df 93       	push	r29
    51e6:	cf 93       	push	r28
    51e8:	cd b7       	in	r28, 0x3d	; 61
    51ea:	de b7       	in	r29, 0x3e	; 62
	return ( configTOTAL_HEAP_SIZE - xNextFreeByte );
    51ec:	20 91 71 01 	lds	r18, 0x0171
    51f0:	30 91 72 01 	lds	r19, 0x0172
    51f4:	88 ee       	ldi	r24, 0xE8	; 232
    51f6:	93 e0       	ldi	r25, 0x03	; 3
    51f8:	82 1b       	sub	r24, r18
    51fa:	93 0b       	sbc	r25, r19
}
    51fc:	cf 91       	pop	r28
    51fe:	df 91       	pop	r29
    5200:	08 95       	ret

00005202 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( xList *pxList )
{
    5202:	df 93       	push	r29
    5204:	cf 93       	push	r28
    5206:	00 d0       	rcall	.+0      	; 0x5208 <vListInitialise+0x6>
    5208:	cd b7       	in	r28, 0x3d	; 61
    520a:	de b7       	in	r29, 0x3e	; 62
    520c:	9a 83       	std	Y+2, r25	; 0x02
    520e:	89 83       	std	Y+1, r24	; 0x01
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( xListItem * ) &( pxList->xListEnd );
    5210:	89 81       	ldd	r24, Y+1	; 0x01
    5212:	9a 81       	ldd	r25, Y+2	; 0x02
    5214:	03 96       	adiw	r24, 0x03	; 3
    5216:	e9 81       	ldd	r30, Y+1	; 0x01
    5218:	fa 81       	ldd	r31, Y+2	; 0x02
    521a:	92 83       	std	Z+2, r25	; 0x02
    521c:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
    521e:	e9 81       	ldd	r30, Y+1	; 0x01
    5220:	fa 81       	ldd	r31, Y+2	; 0x02
    5222:	8f ef       	ldi	r24, 0xFF	; 255
    5224:	9f ef       	ldi	r25, 0xFF	; 255
    5226:	94 83       	std	Z+4, r25	; 0x04
    5228:	83 83       	std	Z+3, r24	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( xListItem * ) &( pxList->xListEnd );
    522a:	89 81       	ldd	r24, Y+1	; 0x01
    522c:	9a 81       	ldd	r25, Y+2	; 0x02
    522e:	03 96       	adiw	r24, 0x03	; 3
    5230:	e9 81       	ldd	r30, Y+1	; 0x01
    5232:	fa 81       	ldd	r31, Y+2	; 0x02
    5234:	96 83       	std	Z+6, r25	; 0x06
    5236:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( xListItem * ) &( pxList->xListEnd );
    5238:	89 81       	ldd	r24, Y+1	; 0x01
    523a:	9a 81       	ldd	r25, Y+2	; 0x02
    523c:	03 96       	adiw	r24, 0x03	; 3
    523e:	e9 81       	ldd	r30, Y+1	; 0x01
    5240:	fa 81       	ldd	r31, Y+2	; 0x02
    5242:	90 87       	std	Z+8, r25	; 0x08
    5244:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = ( unsigned portBASE_TYPE ) 0U;
    5246:	e9 81       	ldd	r30, Y+1	; 0x01
    5248:	fa 81       	ldd	r31, Y+2	; 0x02
    524a:	10 82       	st	Z, r1
}
    524c:	0f 90       	pop	r0
    524e:	0f 90       	pop	r0
    5250:	cf 91       	pop	r28
    5252:	df 91       	pop	r29
    5254:	08 95       	ret

00005256 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( xListItem *pxItem )
{
    5256:	df 93       	push	r29
    5258:	cf 93       	push	r28
    525a:	00 d0       	rcall	.+0      	; 0x525c <vListInitialiseItem+0x6>
    525c:	cd b7       	in	r28, 0x3d	; 61
    525e:	de b7       	in	r29, 0x3e	; 62
    5260:	9a 83       	std	Y+2, r25	; 0x02
    5262:	89 83       	std	Y+1, r24	; 0x01
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
    5264:	e9 81       	ldd	r30, Y+1	; 0x01
    5266:	fa 81       	ldd	r31, Y+2	; 0x02
    5268:	11 86       	std	Z+9, r1	; 0x09
    526a:	10 86       	std	Z+8, r1	; 0x08
}
    526c:	0f 90       	pop	r0
    526e:	0f 90       	pop	r0
    5270:	cf 91       	pop	r28
    5272:	df 91       	pop	r29
    5274:	08 95       	ret

00005276 <vListInsertEnd>:
/*-----------------------------------------------------------*/

void vListInsertEnd( xList *pxList, xListItem *pxNewListItem )
{
    5276:	df 93       	push	r29
    5278:	cf 93       	push	r28
    527a:	00 d0       	rcall	.+0      	; 0x527c <vListInsertEnd+0x6>
    527c:	00 d0       	rcall	.+0      	; 0x527e <vListInsertEnd+0x8>
    527e:	00 d0       	rcall	.+0      	; 0x5280 <vListInsertEnd+0xa>
    5280:	cd b7       	in	r28, 0x3d	; 61
    5282:	de b7       	in	r29, 0x3e	; 62
    5284:	9c 83       	std	Y+4, r25	; 0x04
    5286:	8b 83       	std	Y+3, r24	; 0x03
    5288:	7e 83       	std	Y+6, r23	; 0x06
    528a:	6d 83       	std	Y+5, r22	; 0x05

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	pvListGetOwnerOfNextEntry.  This means it has to be the item pointed to by
	the pxIndex member. */
	pxIndex = pxList->pxIndex;
    528c:	eb 81       	ldd	r30, Y+3	; 0x03
    528e:	fc 81       	ldd	r31, Y+4	; 0x04
    5290:	81 81       	ldd	r24, Z+1	; 0x01
    5292:	92 81       	ldd	r25, Z+2	; 0x02
    5294:	9a 83       	std	Y+2, r25	; 0x02
    5296:	89 83       	std	Y+1, r24	; 0x01

	pxNewListItem->pxNext = pxIndex->pxNext;
    5298:	e9 81       	ldd	r30, Y+1	; 0x01
    529a:	fa 81       	ldd	r31, Y+2	; 0x02
    529c:	82 81       	ldd	r24, Z+2	; 0x02
    529e:	93 81       	ldd	r25, Z+3	; 0x03
    52a0:	ed 81       	ldd	r30, Y+5	; 0x05
    52a2:	fe 81       	ldd	r31, Y+6	; 0x06
    52a4:	93 83       	std	Z+3, r25	; 0x03
    52a6:	82 83       	std	Z+2, r24	; 0x02
	pxNewListItem->pxPrevious = pxList->pxIndex;
    52a8:	eb 81       	ldd	r30, Y+3	; 0x03
    52aa:	fc 81       	ldd	r31, Y+4	; 0x04
    52ac:	81 81       	ldd	r24, Z+1	; 0x01
    52ae:	92 81       	ldd	r25, Z+2	; 0x02
    52b0:	ed 81       	ldd	r30, Y+5	; 0x05
    52b2:	fe 81       	ldd	r31, Y+6	; 0x06
    52b4:	95 83       	std	Z+5, r25	; 0x05
    52b6:	84 83       	std	Z+4, r24	; 0x04
	pxIndex->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
    52b8:	e9 81       	ldd	r30, Y+1	; 0x01
    52ba:	fa 81       	ldd	r31, Y+2	; 0x02
    52bc:	02 80       	ldd	r0, Z+2	; 0x02
    52be:	f3 81       	ldd	r31, Z+3	; 0x03
    52c0:	e0 2d       	mov	r30, r0
    52c2:	8d 81       	ldd	r24, Y+5	; 0x05
    52c4:	9e 81       	ldd	r25, Y+6	; 0x06
    52c6:	95 83       	std	Z+5, r25	; 0x05
    52c8:	84 83       	std	Z+4, r24	; 0x04
	pxIndex->pxNext = ( volatile xListItem * ) pxNewListItem;
    52ca:	8d 81       	ldd	r24, Y+5	; 0x05
    52cc:	9e 81       	ldd	r25, Y+6	; 0x06
    52ce:	e9 81       	ldd	r30, Y+1	; 0x01
    52d0:	fa 81       	ldd	r31, Y+2	; 0x02
    52d2:	93 83       	std	Z+3, r25	; 0x03
    52d4:	82 83       	std	Z+2, r24	; 0x02
	pxList->pxIndex = ( volatile xListItem * ) pxNewListItem;
    52d6:	8d 81       	ldd	r24, Y+5	; 0x05
    52d8:	9e 81       	ldd	r25, Y+6	; 0x06
    52da:	eb 81       	ldd	r30, Y+3	; 0x03
    52dc:	fc 81       	ldd	r31, Y+4	; 0x04
    52de:	92 83       	std	Z+2, r25	; 0x02
    52e0:	81 83       	std	Z+1, r24	; 0x01

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    52e2:	ed 81       	ldd	r30, Y+5	; 0x05
    52e4:	fe 81       	ldd	r31, Y+6	; 0x06
    52e6:	8b 81       	ldd	r24, Y+3	; 0x03
    52e8:	9c 81       	ldd	r25, Y+4	; 0x04
    52ea:	91 87       	std	Z+9, r25	; 0x09
    52ec:	80 87       	std	Z+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
    52ee:	eb 81       	ldd	r30, Y+3	; 0x03
    52f0:	fc 81       	ldd	r31, Y+4	; 0x04
    52f2:	80 81       	ld	r24, Z
    52f4:	8f 5f       	subi	r24, 0xFF	; 255
    52f6:	eb 81       	ldd	r30, Y+3	; 0x03
    52f8:	fc 81       	ldd	r31, Y+4	; 0x04
    52fa:	80 83       	st	Z, r24
}
    52fc:	26 96       	adiw	r28, 0x06	; 6
    52fe:	0f b6       	in	r0, 0x3f	; 63
    5300:	f8 94       	cli
    5302:	de bf       	out	0x3e, r29	; 62
    5304:	0f be       	out	0x3f, r0	; 63
    5306:	cd bf       	out	0x3d, r28	; 61
    5308:	cf 91       	pop	r28
    530a:	df 91       	pop	r29
    530c:	08 95       	ret

0000530e <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( xList *pxList, xListItem *pxNewListItem )
{
    530e:	df 93       	push	r29
    5310:	cf 93       	push	r28
    5312:	cd b7       	in	r28, 0x3d	; 61
    5314:	de b7       	in	r29, 0x3e	; 62
    5316:	28 97       	sbiw	r28, 0x08	; 8
    5318:	0f b6       	in	r0, 0x3f	; 63
    531a:	f8 94       	cli
    531c:	de bf       	out	0x3e, r29	; 62
    531e:	0f be       	out	0x3f, r0	; 63
    5320:	cd bf       	out	0x3d, r28	; 61
    5322:	9e 83       	std	Y+6, r25	; 0x06
    5324:	8d 83       	std	Y+5, r24	; 0x05
    5326:	78 87       	std	Y+8, r23	; 0x08
    5328:	6f 83       	std	Y+7, r22	; 0x07
volatile xListItem *pxIterator;
portTickType xValueOfInsertion;

	/* Insert the new list item into the list, sorted in ulListItem order. */
	xValueOfInsertion = pxNewListItem->xItemValue;
    532a:	ef 81       	ldd	r30, Y+7	; 0x07
    532c:	f8 85       	ldd	r31, Y+8	; 0x08
    532e:	80 81       	ld	r24, Z
    5330:	91 81       	ldd	r25, Z+1	; 0x01
    5332:	9a 83       	std	Y+2, r25	; 0x02
    5334:	89 83       	std	Y+1, r24	; 0x01
	are stored in ready lists (all of which have the same ulListItem value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
    5336:	89 81       	ldd	r24, Y+1	; 0x01
    5338:	9a 81       	ldd	r25, Y+2	; 0x02
    533a:	2f ef       	ldi	r18, 0xFF	; 255
    533c:	8f 3f       	cpi	r24, 0xFF	; 255
    533e:	92 07       	cpc	r25, r18
    5340:	39 f4       	brne	.+14     	; 0x5350 <vListInsert+0x42>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
    5342:	ed 81       	ldd	r30, Y+5	; 0x05
    5344:	fe 81       	ldd	r31, Y+6	; 0x06
    5346:	87 81       	ldd	r24, Z+7	; 0x07
    5348:	90 85       	ldd	r25, Z+8	; 0x08
    534a:	9c 83       	std	Y+4, r25	; 0x04
    534c:	8b 83       	std	Y+3, r24	; 0x03
    534e:	18 c0       	rjmp	.+48     	; 0x5380 <vListInsert+0x72>
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips.
		**********************************************************************/
		
		for( pxIterator = ( xListItem * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext )
    5350:	8d 81       	ldd	r24, Y+5	; 0x05
    5352:	9e 81       	ldd	r25, Y+6	; 0x06
    5354:	03 96       	adiw	r24, 0x03	; 3
    5356:	9c 83       	std	Y+4, r25	; 0x04
    5358:	8b 83       	std	Y+3, r24	; 0x03
    535a:	06 c0       	rjmp	.+12     	; 0x5368 <vListInsert+0x5a>
    535c:	eb 81       	ldd	r30, Y+3	; 0x03
    535e:	fc 81       	ldd	r31, Y+4	; 0x04
    5360:	82 81       	ldd	r24, Z+2	; 0x02
    5362:	93 81       	ldd	r25, Z+3	; 0x03
    5364:	9c 83       	std	Y+4, r25	; 0x04
    5366:	8b 83       	std	Y+3, r24	; 0x03
    5368:	eb 81       	ldd	r30, Y+3	; 0x03
    536a:	fc 81       	ldd	r31, Y+4	; 0x04
    536c:	02 80       	ldd	r0, Z+2	; 0x02
    536e:	f3 81       	ldd	r31, Z+3	; 0x03
    5370:	e0 2d       	mov	r30, r0
    5372:	20 81       	ld	r18, Z
    5374:	31 81       	ldd	r19, Z+1	; 0x01
    5376:	89 81       	ldd	r24, Y+1	; 0x01
    5378:	9a 81       	ldd	r25, Y+2	; 0x02
    537a:	82 17       	cp	r24, r18
    537c:	93 07       	cpc	r25, r19
    537e:	70 f7       	brcc	.-36     	; 0x535c <vListInsert+0x4e>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
    5380:	eb 81       	ldd	r30, Y+3	; 0x03
    5382:	fc 81       	ldd	r31, Y+4	; 0x04
    5384:	82 81       	ldd	r24, Z+2	; 0x02
    5386:	93 81       	ldd	r25, Z+3	; 0x03
    5388:	ef 81       	ldd	r30, Y+7	; 0x07
    538a:	f8 85       	ldd	r31, Y+8	; 0x08
    538c:	93 83       	std	Z+3, r25	; 0x03
    538e:	82 83       	std	Z+2, r24	; 0x02
	pxNewListItem->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
    5390:	ef 81       	ldd	r30, Y+7	; 0x07
    5392:	f8 85       	ldd	r31, Y+8	; 0x08
    5394:	02 80       	ldd	r0, Z+2	; 0x02
    5396:	f3 81       	ldd	r31, Z+3	; 0x03
    5398:	e0 2d       	mov	r30, r0
    539a:	8f 81       	ldd	r24, Y+7	; 0x07
    539c:	98 85       	ldd	r25, Y+8	; 0x08
    539e:	95 83       	std	Z+5, r25	; 0x05
    53a0:	84 83       	std	Z+4, r24	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
    53a2:	ef 81       	ldd	r30, Y+7	; 0x07
    53a4:	f8 85       	ldd	r31, Y+8	; 0x08
    53a6:	8b 81       	ldd	r24, Y+3	; 0x03
    53a8:	9c 81       	ldd	r25, Y+4	; 0x04
    53aa:	95 83       	std	Z+5, r25	; 0x05
    53ac:	84 83       	std	Z+4, r24	; 0x04
	pxIterator->pxNext = ( volatile xListItem * ) pxNewListItem;
    53ae:	8f 81       	ldd	r24, Y+7	; 0x07
    53b0:	98 85       	ldd	r25, Y+8	; 0x08
    53b2:	eb 81       	ldd	r30, Y+3	; 0x03
    53b4:	fc 81       	ldd	r31, Y+4	; 0x04
    53b6:	93 83       	std	Z+3, r25	; 0x03
    53b8:	82 83       	std	Z+2, r24	; 0x02

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    53ba:	ef 81       	ldd	r30, Y+7	; 0x07
    53bc:	f8 85       	ldd	r31, Y+8	; 0x08
    53be:	8d 81       	ldd	r24, Y+5	; 0x05
    53c0:	9e 81       	ldd	r25, Y+6	; 0x06
    53c2:	91 87       	std	Z+9, r25	; 0x09
    53c4:	80 87       	std	Z+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
    53c6:	ed 81       	ldd	r30, Y+5	; 0x05
    53c8:	fe 81       	ldd	r31, Y+6	; 0x06
    53ca:	80 81       	ld	r24, Z
    53cc:	8f 5f       	subi	r24, 0xFF	; 255
    53ce:	ed 81       	ldd	r30, Y+5	; 0x05
    53d0:	fe 81       	ldd	r31, Y+6	; 0x06
    53d2:	80 83       	st	Z, r24
}
    53d4:	28 96       	adiw	r28, 0x08	; 8
    53d6:	0f b6       	in	r0, 0x3f	; 63
    53d8:	f8 94       	cli
    53da:	de bf       	out	0x3e, r29	; 62
    53dc:	0f be       	out	0x3f, r0	; 63
    53de:	cd bf       	out	0x3d, r28	; 61
    53e0:	cf 91       	pop	r28
    53e2:	df 91       	pop	r29
    53e4:	08 95       	ret

000053e6 <vListRemove>:
/*-----------------------------------------------------------*/

void vListRemove( xListItem *pxItemToRemove )
{
    53e6:	df 93       	push	r29
    53e8:	cf 93       	push	r28
    53ea:	00 d0       	rcall	.+0      	; 0x53ec <vListRemove+0x6>
    53ec:	00 d0       	rcall	.+0      	; 0x53ee <vListRemove+0x8>
    53ee:	cd b7       	in	r28, 0x3d	; 61
    53f0:	de b7       	in	r29, 0x3e	; 62
    53f2:	9c 83       	std	Y+4, r25	; 0x04
    53f4:	8b 83       	std	Y+3, r24	; 0x03
xList * pxList;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
    53f6:	eb 81       	ldd	r30, Y+3	; 0x03
    53f8:	fc 81       	ldd	r31, Y+4	; 0x04
    53fa:	a2 81       	ldd	r26, Z+2	; 0x02
    53fc:	b3 81       	ldd	r27, Z+3	; 0x03
    53fe:	eb 81       	ldd	r30, Y+3	; 0x03
    5400:	fc 81       	ldd	r31, Y+4	; 0x04
    5402:	84 81       	ldd	r24, Z+4	; 0x04
    5404:	95 81       	ldd	r25, Z+5	; 0x05
    5406:	15 96       	adiw	r26, 0x05	; 5
    5408:	9c 93       	st	X, r25
    540a:	8e 93       	st	-X, r24
    540c:	14 97       	sbiw	r26, 0x04	; 4
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
    540e:	eb 81       	ldd	r30, Y+3	; 0x03
    5410:	fc 81       	ldd	r31, Y+4	; 0x04
    5412:	a4 81       	ldd	r26, Z+4	; 0x04
    5414:	b5 81       	ldd	r27, Z+5	; 0x05
    5416:	eb 81       	ldd	r30, Y+3	; 0x03
    5418:	fc 81       	ldd	r31, Y+4	; 0x04
    541a:	82 81       	ldd	r24, Z+2	; 0x02
    541c:	93 81       	ldd	r25, Z+3	; 0x03
    541e:	13 96       	adiw	r26, 0x03	; 3
    5420:	9c 93       	st	X, r25
    5422:	8e 93       	st	-X, r24
    5424:	12 97       	sbiw	r26, 0x02	; 2
	
	/* The list item knows which list it is in.  Obtain the list from the list
	item. */
	pxList = ( xList * ) pxItemToRemove->pvContainer;
    5426:	eb 81       	ldd	r30, Y+3	; 0x03
    5428:	fc 81       	ldd	r31, Y+4	; 0x04
    542a:	80 85       	ldd	r24, Z+8	; 0x08
    542c:	91 85       	ldd	r25, Z+9	; 0x09
    542e:	9a 83       	std	Y+2, r25	; 0x02
    5430:	89 83       	std	Y+1, r24	; 0x01

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
    5432:	e9 81       	ldd	r30, Y+1	; 0x01
    5434:	fa 81       	ldd	r31, Y+2	; 0x02
    5436:	21 81       	ldd	r18, Z+1	; 0x01
    5438:	32 81       	ldd	r19, Z+2	; 0x02
    543a:	8b 81       	ldd	r24, Y+3	; 0x03
    543c:	9c 81       	ldd	r25, Y+4	; 0x04
    543e:	28 17       	cp	r18, r24
    5440:	39 07       	cpc	r19, r25
    5442:	41 f4       	brne	.+16     	; 0x5454 <vListRemove+0x6e>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
    5444:	eb 81       	ldd	r30, Y+3	; 0x03
    5446:	fc 81       	ldd	r31, Y+4	; 0x04
    5448:	84 81       	ldd	r24, Z+4	; 0x04
    544a:	95 81       	ldd	r25, Z+5	; 0x05
    544c:	e9 81       	ldd	r30, Y+1	; 0x01
    544e:	fa 81       	ldd	r31, Y+2	; 0x02
    5450:	92 83       	std	Z+2, r25	; 0x02
    5452:	81 83       	std	Z+1, r24	; 0x01
	}

	pxItemToRemove->pvContainer = NULL;
    5454:	eb 81       	ldd	r30, Y+3	; 0x03
    5456:	fc 81       	ldd	r31, Y+4	; 0x04
    5458:	11 86       	std	Z+9, r1	; 0x09
    545a:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
    545c:	e9 81       	ldd	r30, Y+1	; 0x01
    545e:	fa 81       	ldd	r31, Y+2	; 0x02
    5460:	80 81       	ld	r24, Z
    5462:	81 50       	subi	r24, 0x01	; 1
    5464:	e9 81       	ldd	r30, Y+1	; 0x01
    5466:	fa 81       	ldd	r31, Y+2	; 0x02
    5468:	80 83       	st	Z, r24
}
    546a:	0f 90       	pop	r0
    546c:	0f 90       	pop	r0
    546e:	0f 90       	pop	r0
    5470:	0f 90       	pop	r0
    5472:	cf 91       	pop	r28
    5474:	df 91       	pop	r29
    5476:	08 95       	ret

00005478 <pxPortInitialiseStack>:

/* 
 * See header file for description. 
 */
portSTACK_TYPE *pxPortInitialiseStack( portSTACK_TYPE *pxTopOfStack, pdTASK_CODE pxCode, void *pvParameters )
{
    5478:	df 93       	push	r29
    547a:	cf 93       	push	r28
    547c:	cd b7       	in	r28, 0x3d	; 61
    547e:	de b7       	in	r29, 0x3e	; 62
    5480:	28 97       	sbiw	r28, 0x08	; 8
    5482:	0f b6       	in	r0, 0x3f	; 63
    5484:	f8 94       	cli
    5486:	de bf       	out	0x3e, r29	; 62
    5488:	0f be       	out	0x3f, r0	; 63
    548a:	cd bf       	out	0x3d, r28	; 61
    548c:	9c 83       	std	Y+4, r25	; 0x04
    548e:	8b 83       	std	Y+3, r24	; 0x03
    5490:	7e 83       	std	Y+6, r23	; 0x06
    5492:	6d 83       	std	Y+5, r22	; 0x05
    5494:	58 87       	std	Y+8, r21	; 0x08
    5496:	4f 83       	std	Y+7, r20	; 0x07
unsigned short usAddress;

	/* Place a few bytes of known values on the bottom of the stack. 
	This is just useful for debugging. */

	*pxTopOfStack = 0x11;
    5498:	eb 81       	ldd	r30, Y+3	; 0x03
    549a:	fc 81       	ldd	r31, Y+4	; 0x04
    549c:	81 e1       	ldi	r24, 0x11	; 17
    549e:	80 83       	st	Z, r24
	pxTopOfStack--;
    54a0:	8b 81       	ldd	r24, Y+3	; 0x03
    54a2:	9c 81       	ldd	r25, Y+4	; 0x04
    54a4:	01 97       	sbiw	r24, 0x01	; 1
    54a6:	9c 83       	std	Y+4, r25	; 0x04
    54a8:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = 0x22;
    54aa:	eb 81       	ldd	r30, Y+3	; 0x03
    54ac:	fc 81       	ldd	r31, Y+4	; 0x04
    54ae:	82 e2       	ldi	r24, 0x22	; 34
    54b0:	80 83       	st	Z, r24
	pxTopOfStack--;
    54b2:	8b 81       	ldd	r24, Y+3	; 0x03
    54b4:	9c 81       	ldd	r25, Y+4	; 0x04
    54b6:	01 97       	sbiw	r24, 0x01	; 1
    54b8:	9c 83       	std	Y+4, r25	; 0x04
    54ba:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = 0x33;
    54bc:	eb 81       	ldd	r30, Y+3	; 0x03
    54be:	fc 81       	ldd	r31, Y+4	; 0x04
    54c0:	83 e3       	ldi	r24, 0x33	; 51
    54c2:	80 83       	st	Z, r24
	pxTopOfStack--;
    54c4:	8b 81       	ldd	r24, Y+3	; 0x03
    54c6:	9c 81       	ldd	r25, Y+4	; 0x04
    54c8:	01 97       	sbiw	r24, 0x01	; 1
    54ca:	9c 83       	std	Y+4, r25	; 0x04
    54cc:	8b 83       	std	Y+3, r24	; 0x03

	/*lint -e950 -e611 -e923 Lint doesn't like this much - but nothing I can do about it. */

	/* The start of the task code will be popped off the stack last, so place
	it on first. */
	usAddress = ( unsigned short ) pxCode;
    54ce:	8d 81       	ldd	r24, Y+5	; 0x05
    54d0:	9e 81       	ldd	r25, Y+6	; 0x06
    54d2:	9a 83       	std	Y+2, r25	; 0x02
    54d4:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
    54d6:	89 81       	ldd	r24, Y+1	; 0x01
    54d8:	eb 81       	ldd	r30, Y+3	; 0x03
    54da:	fc 81       	ldd	r31, Y+4	; 0x04
    54dc:	80 83       	st	Z, r24
	pxTopOfStack--;
    54de:	8b 81       	ldd	r24, Y+3	; 0x03
    54e0:	9c 81       	ldd	r25, Y+4	; 0x04
    54e2:	01 97       	sbiw	r24, 0x01	; 1
    54e4:	9c 83       	std	Y+4, r25	; 0x04
    54e6:	8b 83       	std	Y+3, r24	; 0x03

	usAddress >>= 8;
    54e8:	89 81       	ldd	r24, Y+1	; 0x01
    54ea:	9a 81       	ldd	r25, Y+2	; 0x02
    54ec:	89 2f       	mov	r24, r25
    54ee:	99 27       	eor	r25, r25
    54f0:	9a 83       	std	Y+2, r25	; 0x02
    54f2:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
    54f4:	89 81       	ldd	r24, Y+1	; 0x01
    54f6:	eb 81       	ldd	r30, Y+3	; 0x03
    54f8:	fc 81       	ldd	r31, Y+4	; 0x04
    54fa:	80 83       	st	Z, r24
	pxTopOfStack--;
    54fc:	8b 81       	ldd	r24, Y+3	; 0x03
    54fe:	9c 81       	ldd	r25, Y+4	; 0x04
    5500:	01 97       	sbiw	r24, 0x01	; 1
    5502:	9c 83       	std	Y+4, r25	; 0x04
    5504:	8b 83       	std	Y+3, r24	; 0x03

	/* Next simulate the stack as if after a call to portSAVE_CONTEXT().  
	portSAVE_CONTEXT places the flags on the stack immediately after r0
	to ensure the interrupts get disabled as soon as possible, and so ensuring
	the stack use is minimal should a context switch interrupt occur. */
	*pxTopOfStack = ( portSTACK_TYPE ) 0x00;	/* R0 */
    5506:	eb 81       	ldd	r30, Y+3	; 0x03
    5508:	fc 81       	ldd	r31, Y+4	; 0x04
    550a:	10 82       	st	Z, r1
	pxTopOfStack--;
    550c:	8b 81       	ldd	r24, Y+3	; 0x03
    550e:	9c 81       	ldd	r25, Y+4	; 0x04
    5510:	01 97       	sbiw	r24, 0x01	; 1
    5512:	9c 83       	std	Y+4, r25	; 0x04
    5514:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = portFLAGS_INT_ENABLED;
    5516:	eb 81       	ldd	r30, Y+3	; 0x03
    5518:	fc 81       	ldd	r31, Y+4	; 0x04
    551a:	80 e8       	ldi	r24, 0x80	; 128
    551c:	80 83       	st	Z, r24
	pxTopOfStack--;
    551e:	8b 81       	ldd	r24, Y+3	; 0x03
    5520:	9c 81       	ldd	r25, Y+4	; 0x04
    5522:	01 97       	sbiw	r24, 0x01	; 1
    5524:	9c 83       	std	Y+4, r25	; 0x04
    5526:	8b 83       	std	Y+3, r24	; 0x03


	/* Now the remaining registers.   The compiler expects R1 to be 0. */
	*pxTopOfStack = ( portSTACK_TYPE ) 0x00;	/* R1 */
    5528:	eb 81       	ldd	r30, Y+3	; 0x03
    552a:	fc 81       	ldd	r31, Y+4	; 0x04
    552c:	10 82       	st	Z, r1
	pxTopOfStack--;
    552e:	8b 81       	ldd	r24, Y+3	; 0x03
    5530:	9c 81       	ldd	r25, Y+4	; 0x04
    5532:	01 97       	sbiw	r24, 0x01	; 1
    5534:	9c 83       	std	Y+4, r25	; 0x04
    5536:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x02;	/* R2 */
    5538:	eb 81       	ldd	r30, Y+3	; 0x03
    553a:	fc 81       	ldd	r31, Y+4	; 0x04
    553c:	82 e0       	ldi	r24, 0x02	; 2
    553e:	80 83       	st	Z, r24
	pxTopOfStack--;
    5540:	8b 81       	ldd	r24, Y+3	; 0x03
    5542:	9c 81       	ldd	r25, Y+4	; 0x04
    5544:	01 97       	sbiw	r24, 0x01	; 1
    5546:	9c 83       	std	Y+4, r25	; 0x04
    5548:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x03;	/* R3 */
    554a:	eb 81       	ldd	r30, Y+3	; 0x03
    554c:	fc 81       	ldd	r31, Y+4	; 0x04
    554e:	83 e0       	ldi	r24, 0x03	; 3
    5550:	80 83       	st	Z, r24
	pxTopOfStack--;
    5552:	8b 81       	ldd	r24, Y+3	; 0x03
    5554:	9c 81       	ldd	r25, Y+4	; 0x04
    5556:	01 97       	sbiw	r24, 0x01	; 1
    5558:	9c 83       	std	Y+4, r25	; 0x04
    555a:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x04;	/* R4 */
    555c:	eb 81       	ldd	r30, Y+3	; 0x03
    555e:	fc 81       	ldd	r31, Y+4	; 0x04
    5560:	84 e0       	ldi	r24, 0x04	; 4
    5562:	80 83       	st	Z, r24
	pxTopOfStack--;
    5564:	8b 81       	ldd	r24, Y+3	; 0x03
    5566:	9c 81       	ldd	r25, Y+4	; 0x04
    5568:	01 97       	sbiw	r24, 0x01	; 1
    556a:	9c 83       	std	Y+4, r25	; 0x04
    556c:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x05;	/* R5 */
    556e:	eb 81       	ldd	r30, Y+3	; 0x03
    5570:	fc 81       	ldd	r31, Y+4	; 0x04
    5572:	85 e0       	ldi	r24, 0x05	; 5
    5574:	80 83       	st	Z, r24
	pxTopOfStack--;
    5576:	8b 81       	ldd	r24, Y+3	; 0x03
    5578:	9c 81       	ldd	r25, Y+4	; 0x04
    557a:	01 97       	sbiw	r24, 0x01	; 1
    557c:	9c 83       	std	Y+4, r25	; 0x04
    557e:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x06;	/* R6 */
    5580:	eb 81       	ldd	r30, Y+3	; 0x03
    5582:	fc 81       	ldd	r31, Y+4	; 0x04
    5584:	86 e0       	ldi	r24, 0x06	; 6
    5586:	80 83       	st	Z, r24
	pxTopOfStack--;
    5588:	8b 81       	ldd	r24, Y+3	; 0x03
    558a:	9c 81       	ldd	r25, Y+4	; 0x04
    558c:	01 97       	sbiw	r24, 0x01	; 1
    558e:	9c 83       	std	Y+4, r25	; 0x04
    5590:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x07;	/* R7 */
    5592:	eb 81       	ldd	r30, Y+3	; 0x03
    5594:	fc 81       	ldd	r31, Y+4	; 0x04
    5596:	87 e0       	ldi	r24, 0x07	; 7
    5598:	80 83       	st	Z, r24
	pxTopOfStack--;
    559a:	8b 81       	ldd	r24, Y+3	; 0x03
    559c:	9c 81       	ldd	r25, Y+4	; 0x04
    559e:	01 97       	sbiw	r24, 0x01	; 1
    55a0:	9c 83       	std	Y+4, r25	; 0x04
    55a2:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x08;	/* R8 */
    55a4:	eb 81       	ldd	r30, Y+3	; 0x03
    55a6:	fc 81       	ldd	r31, Y+4	; 0x04
    55a8:	88 e0       	ldi	r24, 0x08	; 8
    55aa:	80 83       	st	Z, r24
	pxTopOfStack--;
    55ac:	8b 81       	ldd	r24, Y+3	; 0x03
    55ae:	9c 81       	ldd	r25, Y+4	; 0x04
    55b0:	01 97       	sbiw	r24, 0x01	; 1
    55b2:	9c 83       	std	Y+4, r25	; 0x04
    55b4:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x09;	/* R9 */
    55b6:	eb 81       	ldd	r30, Y+3	; 0x03
    55b8:	fc 81       	ldd	r31, Y+4	; 0x04
    55ba:	89 e0       	ldi	r24, 0x09	; 9
    55bc:	80 83       	st	Z, r24
	pxTopOfStack--;
    55be:	8b 81       	ldd	r24, Y+3	; 0x03
    55c0:	9c 81       	ldd	r25, Y+4	; 0x04
    55c2:	01 97       	sbiw	r24, 0x01	; 1
    55c4:	9c 83       	std	Y+4, r25	; 0x04
    55c6:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x10;	/* R10 */
    55c8:	eb 81       	ldd	r30, Y+3	; 0x03
    55ca:	fc 81       	ldd	r31, Y+4	; 0x04
    55cc:	80 e1       	ldi	r24, 0x10	; 16
    55ce:	80 83       	st	Z, r24
	pxTopOfStack--;
    55d0:	8b 81       	ldd	r24, Y+3	; 0x03
    55d2:	9c 81       	ldd	r25, Y+4	; 0x04
    55d4:	01 97       	sbiw	r24, 0x01	; 1
    55d6:	9c 83       	std	Y+4, r25	; 0x04
    55d8:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x11;	/* R11 */
    55da:	eb 81       	ldd	r30, Y+3	; 0x03
    55dc:	fc 81       	ldd	r31, Y+4	; 0x04
    55de:	81 e1       	ldi	r24, 0x11	; 17
    55e0:	80 83       	st	Z, r24
	pxTopOfStack--;
    55e2:	8b 81       	ldd	r24, Y+3	; 0x03
    55e4:	9c 81       	ldd	r25, Y+4	; 0x04
    55e6:	01 97       	sbiw	r24, 0x01	; 1
    55e8:	9c 83       	std	Y+4, r25	; 0x04
    55ea:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x12;	/* R12 */
    55ec:	eb 81       	ldd	r30, Y+3	; 0x03
    55ee:	fc 81       	ldd	r31, Y+4	; 0x04
    55f0:	82 e1       	ldi	r24, 0x12	; 18
    55f2:	80 83       	st	Z, r24
	pxTopOfStack--;
    55f4:	8b 81       	ldd	r24, Y+3	; 0x03
    55f6:	9c 81       	ldd	r25, Y+4	; 0x04
    55f8:	01 97       	sbiw	r24, 0x01	; 1
    55fa:	9c 83       	std	Y+4, r25	; 0x04
    55fc:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x13;	/* R13 */
    55fe:	eb 81       	ldd	r30, Y+3	; 0x03
    5600:	fc 81       	ldd	r31, Y+4	; 0x04
    5602:	83 e1       	ldi	r24, 0x13	; 19
    5604:	80 83       	st	Z, r24
	pxTopOfStack--;
    5606:	8b 81       	ldd	r24, Y+3	; 0x03
    5608:	9c 81       	ldd	r25, Y+4	; 0x04
    560a:	01 97       	sbiw	r24, 0x01	; 1
    560c:	9c 83       	std	Y+4, r25	; 0x04
    560e:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x14;	/* R14 */
    5610:	eb 81       	ldd	r30, Y+3	; 0x03
    5612:	fc 81       	ldd	r31, Y+4	; 0x04
    5614:	84 e1       	ldi	r24, 0x14	; 20
    5616:	80 83       	st	Z, r24
	pxTopOfStack--;
    5618:	8b 81       	ldd	r24, Y+3	; 0x03
    561a:	9c 81       	ldd	r25, Y+4	; 0x04
    561c:	01 97       	sbiw	r24, 0x01	; 1
    561e:	9c 83       	std	Y+4, r25	; 0x04
    5620:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x15;	/* R15 */
    5622:	eb 81       	ldd	r30, Y+3	; 0x03
    5624:	fc 81       	ldd	r31, Y+4	; 0x04
    5626:	85 e1       	ldi	r24, 0x15	; 21
    5628:	80 83       	st	Z, r24
	pxTopOfStack--;
    562a:	8b 81       	ldd	r24, Y+3	; 0x03
    562c:	9c 81       	ldd	r25, Y+4	; 0x04
    562e:	01 97       	sbiw	r24, 0x01	; 1
    5630:	9c 83       	std	Y+4, r25	; 0x04
    5632:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x16;	/* R16 */
    5634:	eb 81       	ldd	r30, Y+3	; 0x03
    5636:	fc 81       	ldd	r31, Y+4	; 0x04
    5638:	86 e1       	ldi	r24, 0x16	; 22
    563a:	80 83       	st	Z, r24
	pxTopOfStack--;
    563c:	8b 81       	ldd	r24, Y+3	; 0x03
    563e:	9c 81       	ldd	r25, Y+4	; 0x04
    5640:	01 97       	sbiw	r24, 0x01	; 1
    5642:	9c 83       	std	Y+4, r25	; 0x04
    5644:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x17;	/* R17 */
    5646:	eb 81       	ldd	r30, Y+3	; 0x03
    5648:	fc 81       	ldd	r31, Y+4	; 0x04
    564a:	87 e1       	ldi	r24, 0x17	; 23
    564c:	80 83       	st	Z, r24
	pxTopOfStack--;
    564e:	8b 81       	ldd	r24, Y+3	; 0x03
    5650:	9c 81       	ldd	r25, Y+4	; 0x04
    5652:	01 97       	sbiw	r24, 0x01	; 1
    5654:	9c 83       	std	Y+4, r25	; 0x04
    5656:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x18;	/* R18 */
    5658:	eb 81       	ldd	r30, Y+3	; 0x03
    565a:	fc 81       	ldd	r31, Y+4	; 0x04
    565c:	88 e1       	ldi	r24, 0x18	; 24
    565e:	80 83       	st	Z, r24
	pxTopOfStack--;
    5660:	8b 81       	ldd	r24, Y+3	; 0x03
    5662:	9c 81       	ldd	r25, Y+4	; 0x04
    5664:	01 97       	sbiw	r24, 0x01	; 1
    5666:	9c 83       	std	Y+4, r25	; 0x04
    5668:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x19;	/* R19 */
    566a:	eb 81       	ldd	r30, Y+3	; 0x03
    566c:	fc 81       	ldd	r31, Y+4	; 0x04
    566e:	89 e1       	ldi	r24, 0x19	; 25
    5670:	80 83       	st	Z, r24
	pxTopOfStack--;
    5672:	8b 81       	ldd	r24, Y+3	; 0x03
    5674:	9c 81       	ldd	r25, Y+4	; 0x04
    5676:	01 97       	sbiw	r24, 0x01	; 1
    5678:	9c 83       	std	Y+4, r25	; 0x04
    567a:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x20;	/* R20 */
    567c:	eb 81       	ldd	r30, Y+3	; 0x03
    567e:	fc 81       	ldd	r31, Y+4	; 0x04
    5680:	80 e2       	ldi	r24, 0x20	; 32
    5682:	80 83       	st	Z, r24
	pxTopOfStack--;
    5684:	8b 81       	ldd	r24, Y+3	; 0x03
    5686:	9c 81       	ldd	r25, Y+4	; 0x04
    5688:	01 97       	sbiw	r24, 0x01	; 1
    568a:	9c 83       	std	Y+4, r25	; 0x04
    568c:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x21;	/* R21 */
    568e:	eb 81       	ldd	r30, Y+3	; 0x03
    5690:	fc 81       	ldd	r31, Y+4	; 0x04
    5692:	81 e2       	ldi	r24, 0x21	; 33
    5694:	80 83       	st	Z, r24
	pxTopOfStack--;
    5696:	8b 81       	ldd	r24, Y+3	; 0x03
    5698:	9c 81       	ldd	r25, Y+4	; 0x04
    569a:	01 97       	sbiw	r24, 0x01	; 1
    569c:	9c 83       	std	Y+4, r25	; 0x04
    569e:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x22;	/* R22 */
    56a0:	eb 81       	ldd	r30, Y+3	; 0x03
    56a2:	fc 81       	ldd	r31, Y+4	; 0x04
    56a4:	82 e2       	ldi	r24, 0x22	; 34
    56a6:	80 83       	st	Z, r24
	pxTopOfStack--;
    56a8:	8b 81       	ldd	r24, Y+3	; 0x03
    56aa:	9c 81       	ldd	r25, Y+4	; 0x04
    56ac:	01 97       	sbiw	r24, 0x01	; 1
    56ae:	9c 83       	std	Y+4, r25	; 0x04
    56b0:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x23;	/* R23 */
    56b2:	eb 81       	ldd	r30, Y+3	; 0x03
    56b4:	fc 81       	ldd	r31, Y+4	; 0x04
    56b6:	83 e2       	ldi	r24, 0x23	; 35
    56b8:	80 83       	st	Z, r24
	pxTopOfStack--;
    56ba:	8b 81       	ldd	r24, Y+3	; 0x03
    56bc:	9c 81       	ldd	r25, Y+4	; 0x04
    56be:	01 97       	sbiw	r24, 0x01	; 1
    56c0:	9c 83       	std	Y+4, r25	; 0x04
    56c2:	8b 83       	std	Y+3, r24	; 0x03

	/* Place the parameter on the stack in the expected location. */
	usAddress = ( unsigned short ) pvParameters;
    56c4:	8f 81       	ldd	r24, Y+7	; 0x07
    56c6:	98 85       	ldd	r25, Y+8	; 0x08
    56c8:	9a 83       	std	Y+2, r25	; 0x02
    56ca:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
    56cc:	89 81       	ldd	r24, Y+1	; 0x01
    56ce:	eb 81       	ldd	r30, Y+3	; 0x03
    56d0:	fc 81       	ldd	r31, Y+4	; 0x04
    56d2:	80 83       	st	Z, r24
	pxTopOfStack--;
    56d4:	8b 81       	ldd	r24, Y+3	; 0x03
    56d6:	9c 81       	ldd	r25, Y+4	; 0x04
    56d8:	01 97       	sbiw	r24, 0x01	; 1
    56da:	9c 83       	std	Y+4, r25	; 0x04
    56dc:	8b 83       	std	Y+3, r24	; 0x03

	usAddress >>= 8;
    56de:	89 81       	ldd	r24, Y+1	; 0x01
    56e0:	9a 81       	ldd	r25, Y+2	; 0x02
    56e2:	89 2f       	mov	r24, r25
    56e4:	99 27       	eor	r25, r25
    56e6:	9a 83       	std	Y+2, r25	; 0x02
    56e8:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
    56ea:	89 81       	ldd	r24, Y+1	; 0x01
    56ec:	eb 81       	ldd	r30, Y+3	; 0x03
    56ee:	fc 81       	ldd	r31, Y+4	; 0x04
    56f0:	80 83       	st	Z, r24
	pxTopOfStack--;
    56f2:	8b 81       	ldd	r24, Y+3	; 0x03
    56f4:	9c 81       	ldd	r25, Y+4	; 0x04
    56f6:	01 97       	sbiw	r24, 0x01	; 1
    56f8:	9c 83       	std	Y+4, r25	; 0x04
    56fa:	8b 83       	std	Y+3, r24	; 0x03

	*pxTopOfStack = ( portSTACK_TYPE ) 0x26;	/* R26 X */
    56fc:	eb 81       	ldd	r30, Y+3	; 0x03
    56fe:	fc 81       	ldd	r31, Y+4	; 0x04
    5700:	86 e2       	ldi	r24, 0x26	; 38
    5702:	80 83       	st	Z, r24
	pxTopOfStack--;
    5704:	8b 81       	ldd	r24, Y+3	; 0x03
    5706:	9c 81       	ldd	r25, Y+4	; 0x04
    5708:	01 97       	sbiw	r24, 0x01	; 1
    570a:	9c 83       	std	Y+4, r25	; 0x04
    570c:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x27;	/* R27 */
    570e:	eb 81       	ldd	r30, Y+3	; 0x03
    5710:	fc 81       	ldd	r31, Y+4	; 0x04
    5712:	87 e2       	ldi	r24, 0x27	; 39
    5714:	80 83       	st	Z, r24
	pxTopOfStack--;
    5716:	8b 81       	ldd	r24, Y+3	; 0x03
    5718:	9c 81       	ldd	r25, Y+4	; 0x04
    571a:	01 97       	sbiw	r24, 0x01	; 1
    571c:	9c 83       	std	Y+4, r25	; 0x04
    571e:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x28;	/* R28 Y */
    5720:	eb 81       	ldd	r30, Y+3	; 0x03
    5722:	fc 81       	ldd	r31, Y+4	; 0x04
    5724:	88 e2       	ldi	r24, 0x28	; 40
    5726:	80 83       	st	Z, r24
	pxTopOfStack--;
    5728:	8b 81       	ldd	r24, Y+3	; 0x03
    572a:	9c 81       	ldd	r25, Y+4	; 0x04
    572c:	01 97       	sbiw	r24, 0x01	; 1
    572e:	9c 83       	std	Y+4, r25	; 0x04
    5730:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x29;	/* R29 */
    5732:	eb 81       	ldd	r30, Y+3	; 0x03
    5734:	fc 81       	ldd	r31, Y+4	; 0x04
    5736:	89 e2       	ldi	r24, 0x29	; 41
    5738:	80 83       	st	Z, r24
	pxTopOfStack--;
    573a:	8b 81       	ldd	r24, Y+3	; 0x03
    573c:	9c 81       	ldd	r25, Y+4	; 0x04
    573e:	01 97       	sbiw	r24, 0x01	; 1
    5740:	9c 83       	std	Y+4, r25	; 0x04
    5742:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x30;	/* R30 Z */
    5744:	eb 81       	ldd	r30, Y+3	; 0x03
    5746:	fc 81       	ldd	r31, Y+4	; 0x04
    5748:	80 e3       	ldi	r24, 0x30	; 48
    574a:	80 83       	st	Z, r24
	pxTopOfStack--;
    574c:	8b 81       	ldd	r24, Y+3	; 0x03
    574e:	9c 81       	ldd	r25, Y+4	; 0x04
    5750:	01 97       	sbiw	r24, 0x01	; 1
    5752:	9c 83       	std	Y+4, r25	; 0x04
    5754:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x031;	/* R31 */
    5756:	eb 81       	ldd	r30, Y+3	; 0x03
    5758:	fc 81       	ldd	r31, Y+4	; 0x04
    575a:	81 e3       	ldi	r24, 0x31	; 49
    575c:	80 83       	st	Z, r24
	pxTopOfStack--;
    575e:	8b 81       	ldd	r24, Y+3	; 0x03
    5760:	9c 81       	ldd	r25, Y+4	; 0x04
    5762:	01 97       	sbiw	r24, 0x01	; 1
    5764:	9c 83       	std	Y+4, r25	; 0x04
    5766:	8b 83       	std	Y+3, r24	; 0x03

	/*lint +e950 +e611 +e923 */

	return pxTopOfStack;
    5768:	8b 81       	ldd	r24, Y+3	; 0x03
    576a:	9c 81       	ldd	r25, Y+4	; 0x04
}
    576c:	28 96       	adiw	r28, 0x08	; 8
    576e:	0f b6       	in	r0, 0x3f	; 63
    5770:	f8 94       	cli
    5772:	de bf       	out	0x3e, r29	; 62
    5774:	0f be       	out	0x3f, r0	; 63
    5776:	cd bf       	out	0x3d, r28	; 61
    5778:	cf 91       	pop	r28
    577a:	df 91       	pop	r29
    577c:	08 95       	ret

0000577e <xPortStartScheduler>:
/*-----------------------------------------------------------*/

portBASE_TYPE xPortStartScheduler( void )
{
    577e:	df 93       	push	r29
    5780:	cf 93       	push	r28
    5782:	cd b7       	in	r28, 0x3d	; 61
    5784:	de b7       	in	r29, 0x3e	; 62
	/* Setup the hardware to generate the tick. */
	prvSetupTimerInterrupt();
    5786:	0e 94 af 2c 	call	0x595e	; 0x595e <prvSetupTimerInterrupt>

	/* Restore the context of the first task that is going to run. */
	portRESTORE_CONTEXT();
    578a:	a0 91 5b 05 	lds	r26, 0x055B
    578e:	b0 91 5c 05 	lds	r27, 0x055C
    5792:	cd 91       	ld	r28, X+
    5794:	cd bf       	out	0x3d, r28	; 61
    5796:	dd 91       	ld	r29, X+
    5798:	de bf       	out	0x3e, r29	; 62
    579a:	ff 91       	pop	r31
    579c:	ef 91       	pop	r30
    579e:	df 91       	pop	r29
    57a0:	cf 91       	pop	r28
    57a2:	bf 91       	pop	r27
    57a4:	af 91       	pop	r26
    57a6:	9f 91       	pop	r25
    57a8:	8f 91       	pop	r24
    57aa:	7f 91       	pop	r23
    57ac:	6f 91       	pop	r22
    57ae:	5f 91       	pop	r21
    57b0:	4f 91       	pop	r20
    57b2:	3f 91       	pop	r19
    57b4:	2f 91       	pop	r18
    57b6:	1f 91       	pop	r17
    57b8:	0f 91       	pop	r16
    57ba:	ff 90       	pop	r15
    57bc:	ef 90       	pop	r14
    57be:	df 90       	pop	r13
    57c0:	cf 90       	pop	r12
    57c2:	bf 90       	pop	r11
    57c4:	af 90       	pop	r10
    57c6:	9f 90       	pop	r9
    57c8:	8f 90       	pop	r8
    57ca:	7f 90       	pop	r7
    57cc:	6f 90       	pop	r6
    57ce:	5f 90       	pop	r5
    57d0:	4f 90       	pop	r4
    57d2:	3f 90       	pop	r3
    57d4:	2f 90       	pop	r2
    57d6:	1f 90       	pop	r1
    57d8:	0f 90       	pop	r0
    57da:	0f be       	out	0x3f, r0	; 63
    57dc:	0f 90       	pop	r0

	/* Simulate a function call end as generated by the compiler.  We will now
	jump to the start of the task the context of which we have just restored. */
	asm volatile ( "ret" );
    57de:	08 95       	ret

	/* Should not get here. */
	return pdTRUE;
    57e0:	81 e0       	ldi	r24, 0x01	; 1
}
    57e2:	cf 91       	pop	r28
    57e4:	df 91       	pop	r29
    57e6:	08 95       	ret

000057e8 <vPortEndScheduler>:
/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
    57e8:	df 93       	push	r29
    57ea:	cf 93       	push	r28
    57ec:	cd b7       	in	r28, 0x3d	; 61
    57ee:	de b7       	in	r29, 0x3e	; 62
	/* It is unlikely that the AVR port will get stopped.  If required simply
	disable the tick interrupt here. */
}
    57f0:	cf 91       	pop	r28
    57f2:	df 91       	pop	r29
    57f4:	08 95       	ret

000057f6 <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
    57f6:	0f 92       	push	r0
    57f8:	0f b6       	in	r0, 0x3f	; 63
    57fa:	f8 94       	cli
    57fc:	0f 92       	push	r0
    57fe:	1f 92       	push	r1
    5800:	11 24       	eor	r1, r1
    5802:	2f 92       	push	r2
    5804:	3f 92       	push	r3
    5806:	4f 92       	push	r4
    5808:	5f 92       	push	r5
    580a:	6f 92       	push	r6
    580c:	7f 92       	push	r7
    580e:	8f 92       	push	r8
    5810:	9f 92       	push	r9
    5812:	af 92       	push	r10
    5814:	bf 92       	push	r11
    5816:	cf 92       	push	r12
    5818:	df 92       	push	r13
    581a:	ef 92       	push	r14
    581c:	ff 92       	push	r15
    581e:	0f 93       	push	r16
    5820:	1f 93       	push	r17
    5822:	2f 93       	push	r18
    5824:	3f 93       	push	r19
    5826:	4f 93       	push	r20
    5828:	5f 93       	push	r21
    582a:	6f 93       	push	r22
    582c:	7f 93       	push	r23
    582e:	8f 93       	push	r24
    5830:	9f 93       	push	r25
    5832:	af 93       	push	r26
    5834:	bf 93       	push	r27
    5836:	cf 93       	push	r28
    5838:	df 93       	push	r29
    583a:	ef 93       	push	r30
    583c:	ff 93       	push	r31
    583e:	a0 91 5b 05 	lds	r26, 0x055B
    5842:	b0 91 5c 05 	lds	r27, 0x055C
    5846:	0d b6       	in	r0, 0x3d	; 61
    5848:	0d 92       	st	X+, r0
    584a:	0e b6       	in	r0, 0x3e	; 62
    584c:	0d 92       	st	X+, r0
	vTaskSwitchContext();
    584e:	0e 94 8a 35 	call	0x6b14	; 0x6b14 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    5852:	a0 91 5b 05 	lds	r26, 0x055B
    5856:	b0 91 5c 05 	lds	r27, 0x055C
    585a:	cd 91       	ld	r28, X+
    585c:	cd bf       	out	0x3d, r28	; 61
    585e:	dd 91       	ld	r29, X+
    5860:	de bf       	out	0x3e, r29	; 62
    5862:	ff 91       	pop	r31
    5864:	ef 91       	pop	r30
    5866:	df 91       	pop	r29
    5868:	cf 91       	pop	r28
    586a:	bf 91       	pop	r27
    586c:	af 91       	pop	r26
    586e:	9f 91       	pop	r25
    5870:	8f 91       	pop	r24
    5872:	7f 91       	pop	r23
    5874:	6f 91       	pop	r22
    5876:	5f 91       	pop	r21
    5878:	4f 91       	pop	r20
    587a:	3f 91       	pop	r19
    587c:	2f 91       	pop	r18
    587e:	1f 91       	pop	r17
    5880:	0f 91       	pop	r16
    5882:	ff 90       	pop	r15
    5884:	ef 90       	pop	r14
    5886:	df 90       	pop	r13
    5888:	cf 90       	pop	r12
    588a:	bf 90       	pop	r11
    588c:	af 90       	pop	r10
    588e:	9f 90       	pop	r9
    5890:	8f 90       	pop	r8
    5892:	7f 90       	pop	r7
    5894:	6f 90       	pop	r6
    5896:	5f 90       	pop	r5
    5898:	4f 90       	pop	r4
    589a:	3f 90       	pop	r3
    589c:	2f 90       	pop	r2
    589e:	1f 90       	pop	r1
    58a0:	0f 90       	pop	r0
    58a2:	0f be       	out	0x3f, r0	; 63
    58a4:	0f 90       	pop	r0

	asm volatile ( "ret" );
    58a6:	08 95       	ret

000058a8 <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
    58a8:	0f 92       	push	r0
    58aa:	0f b6       	in	r0, 0x3f	; 63
    58ac:	f8 94       	cli
    58ae:	0f 92       	push	r0
    58b0:	1f 92       	push	r1
    58b2:	11 24       	eor	r1, r1
    58b4:	2f 92       	push	r2
    58b6:	3f 92       	push	r3
    58b8:	4f 92       	push	r4
    58ba:	5f 92       	push	r5
    58bc:	6f 92       	push	r6
    58be:	7f 92       	push	r7
    58c0:	8f 92       	push	r8
    58c2:	9f 92       	push	r9
    58c4:	af 92       	push	r10
    58c6:	bf 92       	push	r11
    58c8:	cf 92       	push	r12
    58ca:	df 92       	push	r13
    58cc:	ef 92       	push	r14
    58ce:	ff 92       	push	r15
    58d0:	0f 93       	push	r16
    58d2:	1f 93       	push	r17
    58d4:	2f 93       	push	r18
    58d6:	3f 93       	push	r19
    58d8:	4f 93       	push	r20
    58da:	5f 93       	push	r21
    58dc:	6f 93       	push	r22
    58de:	7f 93       	push	r23
    58e0:	8f 93       	push	r24
    58e2:	9f 93       	push	r25
    58e4:	af 93       	push	r26
    58e6:	bf 93       	push	r27
    58e8:	cf 93       	push	r28
    58ea:	df 93       	push	r29
    58ec:	ef 93       	push	r30
    58ee:	ff 93       	push	r31
    58f0:	a0 91 5b 05 	lds	r26, 0x055B
    58f4:	b0 91 5c 05 	lds	r27, 0x055C
    58f8:	0d b6       	in	r0, 0x3d	; 61
    58fa:	0d 92       	st	X+, r0
    58fc:	0e b6       	in	r0, 0x3e	; 62
    58fe:	0d 92       	st	X+, r0
	vTaskIncrementTick();
    5900:	0e 94 b5 34 	call	0x696a	; 0x696a <vTaskIncrementTick>
	vTaskSwitchContext();
    5904:	0e 94 8a 35 	call	0x6b14	; 0x6b14 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    5908:	a0 91 5b 05 	lds	r26, 0x055B
    590c:	b0 91 5c 05 	lds	r27, 0x055C
    5910:	cd 91       	ld	r28, X+
    5912:	cd bf       	out	0x3d, r28	; 61
    5914:	dd 91       	ld	r29, X+
    5916:	de bf       	out	0x3e, r29	; 62
    5918:	ff 91       	pop	r31
    591a:	ef 91       	pop	r30
    591c:	df 91       	pop	r29
    591e:	cf 91       	pop	r28
    5920:	bf 91       	pop	r27
    5922:	af 91       	pop	r26
    5924:	9f 91       	pop	r25
    5926:	8f 91       	pop	r24
    5928:	7f 91       	pop	r23
    592a:	6f 91       	pop	r22
    592c:	5f 91       	pop	r21
    592e:	4f 91       	pop	r20
    5930:	3f 91       	pop	r19
    5932:	2f 91       	pop	r18
    5934:	1f 91       	pop	r17
    5936:	0f 91       	pop	r16
    5938:	ff 90       	pop	r15
    593a:	ef 90       	pop	r14
    593c:	df 90       	pop	r13
    593e:	cf 90       	pop	r12
    5940:	bf 90       	pop	r11
    5942:	af 90       	pop	r10
    5944:	9f 90       	pop	r9
    5946:	8f 90       	pop	r8
    5948:	7f 90       	pop	r7
    594a:	6f 90       	pop	r6
    594c:	5f 90       	pop	r5
    594e:	4f 90       	pop	r4
    5950:	3f 90       	pop	r3
    5952:	2f 90       	pop	r2
    5954:	1f 90       	pop	r1
    5956:	0f 90       	pop	r0
    5958:	0f be       	out	0x3f, r0	; 63
    595a:	0f 90       	pop	r0

	asm volatile ( "ret" );
    595c:	08 95       	ret

0000595e <prvSetupTimerInterrupt>:

/*
 * Setup timer 1 compare match A to generate a tick interrupt.
 */
static void prvSetupTimerInterrupt( void )
{
    595e:	df 93       	push	r29
    5960:	cf 93       	push	r28
    5962:	00 d0       	rcall	.+0      	; 0x5964 <prvSetupTimerInterrupt+0x6>
    5964:	00 d0       	rcall	.+0      	; 0x5966 <prvSetupTimerInterrupt+0x8>
    5966:	00 d0       	rcall	.+0      	; 0x5968 <prvSetupTimerInterrupt+0xa>
    5968:	cd b7       	in	r28, 0x3d	; 61
    596a:	de b7       	in	r29, 0x3e	; 62
unsigned char ucHighByte, ucLowByte;

	/* Using 16bit timer 1 to generate the tick.  Correct fuses must be
	selected for the configCPU_CLOCK_HZ clock. */

	ulCompareMatch = configCPU_CLOCK_HZ / configTICK_RATE_HZ;
    596c:	80 e4       	ldi	r24, 0x40	; 64
    596e:	9f e1       	ldi	r25, 0x1F	; 31
    5970:	a0 e0       	ldi	r26, 0x00	; 0
    5972:	b0 e0       	ldi	r27, 0x00	; 0
    5974:	8b 83       	std	Y+3, r24	; 0x03
    5976:	9c 83       	std	Y+4, r25	; 0x04
    5978:	ad 83       	std	Y+5, r26	; 0x05
    597a:	be 83       	std	Y+6, r27	; 0x06

	/* We only have 16 bits so have to scale to get our required tick rate. */
	ulCompareMatch /= portCLOCK_PRESCALER;
    597c:	8b 81       	ldd	r24, Y+3	; 0x03
    597e:	9c 81       	ldd	r25, Y+4	; 0x04
    5980:	ad 81       	ldd	r26, Y+5	; 0x05
    5982:	be 81       	ldd	r27, Y+6	; 0x06
    5984:	68 94       	set
    5986:	15 f8       	bld	r1, 5
    5988:	b6 95       	lsr	r27
    598a:	a7 95       	ror	r26
    598c:	97 95       	ror	r25
    598e:	87 95       	ror	r24
    5990:	16 94       	lsr	r1
    5992:	d1 f7       	brne	.-12     	; 0x5988 <prvSetupTimerInterrupt+0x2a>
    5994:	8b 83       	std	Y+3, r24	; 0x03
    5996:	9c 83       	std	Y+4, r25	; 0x04
    5998:	ad 83       	std	Y+5, r26	; 0x05
    599a:	be 83       	std	Y+6, r27	; 0x06

	/* Adjust for correct value. */
	ulCompareMatch -= ( unsigned long ) 1;
    599c:	8b 81       	ldd	r24, Y+3	; 0x03
    599e:	9c 81       	ldd	r25, Y+4	; 0x04
    59a0:	ad 81       	ldd	r26, Y+5	; 0x05
    59a2:	be 81       	ldd	r27, Y+6	; 0x06
    59a4:	01 97       	sbiw	r24, 0x01	; 1
    59a6:	a1 09       	sbc	r26, r1
    59a8:	b1 09       	sbc	r27, r1
    59aa:	8b 83       	std	Y+3, r24	; 0x03
    59ac:	9c 83       	std	Y+4, r25	; 0x04
    59ae:	ad 83       	std	Y+5, r26	; 0x05
    59b0:	be 83       	std	Y+6, r27	; 0x06

	/* Setup compare match value for compare match A.  Interrupts are disabled 
	before this is called so we need not worry here. */
	ucLowByte = ( unsigned char ) ( ulCompareMatch & ( unsigned long ) 0xff );
    59b2:	8b 81       	ldd	r24, Y+3	; 0x03
    59b4:	89 83       	std	Y+1, r24	; 0x01
	ulCompareMatch >>= 8;
    59b6:	8b 81       	ldd	r24, Y+3	; 0x03
    59b8:	9c 81       	ldd	r25, Y+4	; 0x04
    59ba:	ad 81       	ldd	r26, Y+5	; 0x05
    59bc:	be 81       	ldd	r27, Y+6	; 0x06
    59be:	89 2f       	mov	r24, r25
    59c0:	9a 2f       	mov	r25, r26
    59c2:	ab 2f       	mov	r26, r27
    59c4:	bb 27       	eor	r27, r27
    59c6:	8b 83       	std	Y+3, r24	; 0x03
    59c8:	9c 83       	std	Y+4, r25	; 0x04
    59ca:	ad 83       	std	Y+5, r26	; 0x05
    59cc:	be 83       	std	Y+6, r27	; 0x06
	ucHighByte = ( unsigned char ) ( ulCompareMatch & ( unsigned long ) 0xff );
    59ce:	8b 81       	ldd	r24, Y+3	; 0x03
    59d0:	8a 83       	std	Y+2, r24	; 0x02
	OCR1AH = ucHighByte;
    59d2:	eb e4       	ldi	r30, 0x4B	; 75
    59d4:	f0 e0       	ldi	r31, 0x00	; 0
    59d6:	8a 81       	ldd	r24, Y+2	; 0x02
    59d8:	80 83       	st	Z, r24
	OCR1AL = ucLowByte;
    59da:	ea e4       	ldi	r30, 0x4A	; 74
    59dc:	f0 e0       	ldi	r31, 0x00	; 0
    59de:	89 81       	ldd	r24, Y+1	; 0x01
    59e0:	80 83       	st	Z, r24

	/* Setup clock source and compare match behaviour. */
	ucLowByte = portCLEAR_COUNTER_ON_MATCH | portPRESCALE_64;
    59e2:	8b e0       	ldi	r24, 0x0B	; 11
    59e4:	89 83       	std	Y+1, r24	; 0x01
	TCCR1B = ucLowByte;
    59e6:	ee e4       	ldi	r30, 0x4E	; 78
    59e8:	f0 e0       	ldi	r31, 0x00	; 0
    59ea:	89 81       	ldd	r24, Y+1	; 0x01
    59ec:	80 83       	st	Z, r24

	/* Enable the interrupt - this is okay as interrupt are currently globally
	disabled. */
	ucLowByte = TIMSK;
    59ee:	e9 e5       	ldi	r30, 0x59	; 89
    59f0:	f0 e0       	ldi	r31, 0x00	; 0
    59f2:	80 81       	ld	r24, Z
    59f4:	89 83       	std	Y+1, r24	; 0x01
	ucLowByte |= portCOMPARE_MATCH_A_INTERRUPT_ENABLE;
    59f6:	89 81       	ldd	r24, Y+1	; 0x01
    59f8:	80 61       	ori	r24, 0x10	; 16
    59fa:	89 83       	std	Y+1, r24	; 0x01
	TIMSK = ucLowByte;
    59fc:	e9 e5       	ldi	r30, 0x59	; 89
    59fe:	f0 e0       	ldi	r31, 0x00	; 0
    5a00:	89 81       	ldd	r24, Y+1	; 0x01
    5a02:	80 83       	st	Z, r24
}
    5a04:	26 96       	adiw	r28, 0x06	; 6
    5a06:	0f b6       	in	r0, 0x3f	; 63
    5a08:	f8 94       	cli
    5a0a:	de bf       	out	0x3e, r29	; 62
    5a0c:	0f be       	out	0x3f, r0	; 63
    5a0e:	cd bf       	out	0x3d, r28	; 61
    5a10:	cf 91       	pop	r28
    5a12:	df 91       	pop	r29
    5a14:	08 95       	ret

00005a16 <__vector_7>:
	 * count is incremented after the context is saved.
	 */
	void SIG_OUTPUT_COMPARE1A( void ) __attribute__ ( ( signal, naked ) );
	void SIG_OUTPUT_COMPARE1A( void )
	{
		vPortYieldFromTick();
    5a16:	0e 94 54 2c 	call	0x58a8	; 0x58a8 <vPortYieldFromTick>
		asm volatile ( "reti" );
    5a1a:	18 95       	reti

00005a1c <xQueueCreate>:
/*-----------------------------------------------------------
 * PUBLIC QUEUE MANAGEMENT API documented in queue.h
 *----------------------------------------------------------*/

xQueueHandle xQueueCreate( unsigned portBASE_TYPE uxQueueLength, unsigned portBASE_TYPE uxItemSize )
{
    5a1c:	df 93       	push	r29
    5a1e:	cf 93       	push	r28
    5a20:	cd b7       	in	r28, 0x3d	; 61
    5a22:	de b7       	in	r29, 0x3e	; 62
    5a24:	28 97       	sbiw	r28, 0x08	; 8
    5a26:	0f b6       	in	r0, 0x3f	; 63
    5a28:	f8 94       	cli
    5a2a:	de bf       	out	0x3e, r29	; 62
    5a2c:	0f be       	out	0x3f, r0	; 63
    5a2e:	cd bf       	out	0x3d, r28	; 61
    5a30:	8f 83       	std	Y+7, r24	; 0x07
    5a32:	68 87       	std	Y+8, r22	; 0x08
	xQUEUE *pxNewQueue;
	size_t xQueueSizeInBytes;
	xQueueHandle xReturn = NULL;
    5a34:	1a 82       	std	Y+2, r1	; 0x02
    5a36:	19 82       	std	Y+1, r1	; 0x01

	/* Allocate the new queue structure. */
	if( uxQueueLength > ( unsigned portBASE_TYPE ) 0 )
    5a38:	8f 81       	ldd	r24, Y+7	; 0x07
    5a3a:	88 23       	and	r24, r24
    5a3c:	09 f4       	brne	.+2      	; 0x5a40 <xQueueCreate+0x24>
    5a3e:	8c c0       	rjmp	.+280    	; 0x5b58 <xQueueCreate+0x13c>
	{
		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
    5a40:	8f e1       	ldi	r24, 0x1F	; 31
    5a42:	90 e0       	ldi	r25, 0x00	; 0
    5a44:	0e 94 95 28 	call	0x512a	; 0x512a <pvPortMalloc>
    5a48:	9e 83       	std	Y+6, r25	; 0x06
    5a4a:	8d 83       	std	Y+5, r24	; 0x05
		if( pxNewQueue != NULL )
    5a4c:	8d 81       	ldd	r24, Y+5	; 0x05
    5a4e:	9e 81       	ldd	r25, Y+6	; 0x06
    5a50:	00 97       	sbiw	r24, 0x00	; 0
    5a52:	09 f4       	brne	.+2      	; 0x5a56 <xQueueCreate+0x3a>
    5a54:	81 c0       	rjmp	.+258    	; 0x5b58 <xQueueCreate+0x13c>
		{
			/* Create the list of pointers to queue items.  The queue is one byte
			longer than asked for to make wrap checking easier/faster. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ) + ( size_t ) 1;
    5a56:	8f 81       	ldd	r24, Y+7	; 0x07
    5a58:	28 2f       	mov	r18, r24
    5a5a:	30 e0       	ldi	r19, 0x00	; 0
    5a5c:	88 85       	ldd	r24, Y+8	; 0x08
    5a5e:	88 2f       	mov	r24, r24
    5a60:	90 e0       	ldi	r25, 0x00	; 0
    5a62:	ac 01       	movw	r20, r24
    5a64:	24 9f       	mul	r18, r20
    5a66:	c0 01       	movw	r24, r0
    5a68:	25 9f       	mul	r18, r21
    5a6a:	90 0d       	add	r25, r0
    5a6c:	34 9f       	mul	r19, r20
    5a6e:	90 0d       	add	r25, r0
    5a70:	11 24       	eor	r1, r1
    5a72:	01 96       	adiw	r24, 0x01	; 1
    5a74:	9c 83       	std	Y+4, r25	; 0x04
    5a76:	8b 83       	std	Y+3, r24	; 0x03

			pxNewQueue->pcHead = ( signed char * ) pvPortMalloc( xQueueSizeInBytes );
    5a78:	8b 81       	ldd	r24, Y+3	; 0x03
    5a7a:	9c 81       	ldd	r25, Y+4	; 0x04
    5a7c:	0e 94 95 28 	call	0x512a	; 0x512a <pvPortMalloc>
    5a80:	ed 81       	ldd	r30, Y+5	; 0x05
    5a82:	fe 81       	ldd	r31, Y+6	; 0x06
    5a84:	91 83       	std	Z+1, r25	; 0x01
    5a86:	80 83       	st	Z, r24
			if( pxNewQueue->pcHead != NULL )
    5a88:	ed 81       	ldd	r30, Y+5	; 0x05
    5a8a:	fe 81       	ldd	r31, Y+6	; 0x06
    5a8c:	80 81       	ld	r24, Z
    5a8e:	91 81       	ldd	r25, Z+1	; 0x01
    5a90:	00 97       	sbiw	r24, 0x00	; 0
    5a92:	09 f4       	brne	.+2      	; 0x5a96 <xQueueCreate+0x7a>
    5a94:	5d c0       	rjmp	.+186    	; 0x5b50 <xQueueCreate+0x134>
			{
				/* Initialise the queue members as described above where the
				queue type is defined. */
				pxNewQueue->pcTail = pxNewQueue->pcHead + ( uxQueueLength * uxItemSize );
    5a96:	ed 81       	ldd	r30, Y+5	; 0x05
    5a98:	fe 81       	ldd	r31, Y+6	; 0x06
    5a9a:	40 81       	ld	r20, Z
    5a9c:	51 81       	ldd	r21, Z+1	; 0x01
    5a9e:	8f 81       	ldd	r24, Y+7	; 0x07
    5aa0:	28 2f       	mov	r18, r24
    5aa2:	30 e0       	ldi	r19, 0x00	; 0
    5aa4:	88 85       	ldd	r24, Y+8	; 0x08
    5aa6:	88 2f       	mov	r24, r24
    5aa8:	90 e0       	ldi	r25, 0x00	; 0
    5aaa:	bc 01       	movw	r22, r24
    5aac:	26 9f       	mul	r18, r22
    5aae:	c0 01       	movw	r24, r0
    5ab0:	27 9f       	mul	r18, r23
    5ab2:	90 0d       	add	r25, r0
    5ab4:	36 9f       	mul	r19, r22
    5ab6:	90 0d       	add	r25, r0
    5ab8:	11 24       	eor	r1, r1
    5aba:	84 0f       	add	r24, r20
    5abc:	95 1f       	adc	r25, r21
    5abe:	ed 81       	ldd	r30, Y+5	; 0x05
    5ac0:	fe 81       	ldd	r31, Y+6	; 0x06
    5ac2:	93 83       	std	Z+3, r25	; 0x03
    5ac4:	82 83       	std	Z+2, r24	; 0x02
				pxNewQueue->uxMessagesWaiting = ( unsigned portBASE_TYPE ) 0U;
    5ac6:	ed 81       	ldd	r30, Y+5	; 0x05
    5ac8:	fe 81       	ldd	r31, Y+6	; 0x06
    5aca:	12 8e       	std	Z+26, r1	; 0x1a
				pxNewQueue->pcWriteTo = pxNewQueue->pcHead;
    5acc:	ed 81       	ldd	r30, Y+5	; 0x05
    5ace:	fe 81       	ldd	r31, Y+6	; 0x06
    5ad0:	80 81       	ld	r24, Z
    5ad2:	91 81       	ldd	r25, Z+1	; 0x01
    5ad4:	ed 81       	ldd	r30, Y+5	; 0x05
    5ad6:	fe 81       	ldd	r31, Y+6	; 0x06
    5ad8:	95 83       	std	Z+5, r25	; 0x05
    5ada:	84 83       	std	Z+4, r24	; 0x04
				pxNewQueue->pcReadFrom = pxNewQueue->pcHead + ( ( uxQueueLength - ( unsigned portBASE_TYPE ) 1U ) * uxItemSize );
    5adc:	ed 81       	ldd	r30, Y+5	; 0x05
    5ade:	fe 81       	ldd	r31, Y+6	; 0x06
    5ae0:	40 81       	ld	r20, Z
    5ae2:	51 81       	ldd	r21, Z+1	; 0x01
    5ae4:	8f 81       	ldd	r24, Y+7	; 0x07
    5ae6:	88 2f       	mov	r24, r24
    5ae8:	90 e0       	ldi	r25, 0x00	; 0
    5aea:	9c 01       	movw	r18, r24
    5aec:	21 50       	subi	r18, 0x01	; 1
    5aee:	30 40       	sbci	r19, 0x00	; 0
    5af0:	88 85       	ldd	r24, Y+8	; 0x08
    5af2:	88 2f       	mov	r24, r24
    5af4:	90 e0       	ldi	r25, 0x00	; 0
    5af6:	bc 01       	movw	r22, r24
    5af8:	26 9f       	mul	r18, r22
    5afa:	c0 01       	movw	r24, r0
    5afc:	27 9f       	mul	r18, r23
    5afe:	90 0d       	add	r25, r0
    5b00:	36 9f       	mul	r19, r22
    5b02:	90 0d       	add	r25, r0
    5b04:	11 24       	eor	r1, r1
    5b06:	84 0f       	add	r24, r20
    5b08:	95 1f       	adc	r25, r21
    5b0a:	ed 81       	ldd	r30, Y+5	; 0x05
    5b0c:	fe 81       	ldd	r31, Y+6	; 0x06
    5b0e:	97 83       	std	Z+7, r25	; 0x07
    5b10:	86 83       	std	Z+6, r24	; 0x06
				pxNewQueue->uxLength = uxQueueLength;
    5b12:	ed 81       	ldd	r30, Y+5	; 0x05
    5b14:	fe 81       	ldd	r31, Y+6	; 0x06
    5b16:	8f 81       	ldd	r24, Y+7	; 0x07
    5b18:	83 8f       	std	Z+27, r24	; 0x1b
				pxNewQueue->uxItemSize = uxItemSize;
    5b1a:	ed 81       	ldd	r30, Y+5	; 0x05
    5b1c:	fe 81       	ldd	r31, Y+6	; 0x06
    5b1e:	88 85       	ldd	r24, Y+8	; 0x08
    5b20:	84 8f       	std	Z+28, r24	; 0x1c
				pxNewQueue->xRxLock = queueUNLOCKED;
    5b22:	ed 81       	ldd	r30, Y+5	; 0x05
    5b24:	fe 81       	ldd	r31, Y+6	; 0x06
    5b26:	8f ef       	ldi	r24, 0xFF	; 255
    5b28:	85 8f       	std	Z+29, r24	; 0x1d
				pxNewQueue->xTxLock = queueUNLOCKED;
    5b2a:	ed 81       	ldd	r30, Y+5	; 0x05
    5b2c:	fe 81       	ldd	r31, Y+6	; 0x06
    5b2e:	8f ef       	ldi	r24, 0xFF	; 255
    5b30:	86 8f       	std	Z+30, r24	; 0x1e

				/* Likewise ensure the event queues start with the correct state. */
				vListInitialise( &( pxNewQueue->xTasksWaitingToSend ) );
    5b32:	8d 81       	ldd	r24, Y+5	; 0x05
    5b34:	9e 81       	ldd	r25, Y+6	; 0x06
    5b36:	08 96       	adiw	r24, 0x08	; 8
    5b38:	0e 94 01 29 	call	0x5202	; 0x5202 <vListInitialise>
				vListInitialise( &( pxNewQueue->xTasksWaitingToReceive ) );
    5b3c:	8d 81       	ldd	r24, Y+5	; 0x05
    5b3e:	9e 81       	ldd	r25, Y+6	; 0x06
    5b40:	41 96       	adiw	r24, 0x11	; 17
    5b42:	0e 94 01 29 	call	0x5202	; 0x5202 <vListInitialise>

				traceQUEUE_CREATE( pxNewQueue );
				xReturn = pxNewQueue;
    5b46:	8d 81       	ldd	r24, Y+5	; 0x05
    5b48:	9e 81       	ldd	r25, Y+6	; 0x06
    5b4a:	9a 83       	std	Y+2, r25	; 0x02
    5b4c:	89 83       	std	Y+1, r24	; 0x01
    5b4e:	04 c0       	rjmp	.+8      	; 0x5b58 <xQueueCreate+0x13c>
			}
			else
			{
				traceQUEUE_CREATE_FAILED();
				vPortFree( pxNewQueue );
    5b50:	8d 81       	ldd	r24, Y+5	; 0x05
    5b52:	9e 81       	ldd	r25, Y+6	; 0x06
    5b54:	0e 94 db 28 	call	0x51b6	; 0x51b6 <vPortFree>
		}
	}

	configASSERT( xReturn );

	return xReturn;
    5b58:	89 81       	ldd	r24, Y+1	; 0x01
    5b5a:	9a 81       	ldd	r25, Y+2	; 0x02
}
    5b5c:	28 96       	adiw	r28, 0x08	; 8
    5b5e:	0f b6       	in	r0, 0x3f	; 63
    5b60:	f8 94       	cli
    5b62:	de bf       	out	0x3e, r29	; 62
    5b64:	0f be       	out	0x3f, r0	; 63
    5b66:	cd bf       	out	0x3d, r28	; 61
    5b68:	cf 91       	pop	r28
    5b6a:	df 91       	pop	r29
    5b6c:	08 95       	ret

00005b6e <xQueueCreateCountingSemaphore>:
/*-----------------------------------------------------------*/

#if configUSE_COUNTING_SEMAPHORES == 1

xQueueHandle xQueueCreateCountingSemaphore( unsigned portBASE_TYPE uxCountValue, unsigned portBASE_TYPE uxInitialCount )
{
    5b6e:	df 93       	push	r29
    5b70:	cf 93       	push	r28
    5b72:	00 d0       	rcall	.+0      	; 0x5b74 <xQueueCreateCountingSemaphore+0x6>
    5b74:	00 d0       	rcall	.+0      	; 0x5b76 <xQueueCreateCountingSemaphore+0x8>
    5b76:	cd b7       	in	r28, 0x3d	; 61
    5b78:	de b7       	in	r29, 0x3e	; 62
    5b7a:	8b 83       	std	Y+3, r24	; 0x03
    5b7c:	6c 83       	std	Y+4, r22	; 0x04
	xQueueHandle pxHandle;

	pxHandle = xQueueCreate( ( unsigned portBASE_TYPE ) uxCountValue, queueSEMAPHORE_QUEUE_ITEM_LENGTH );
    5b7e:	8b 81       	ldd	r24, Y+3	; 0x03
    5b80:	60 e0       	ldi	r22, 0x00	; 0
    5b82:	0e 94 0e 2d 	call	0x5a1c	; 0x5a1c <xQueueCreate>
    5b86:	9a 83       	std	Y+2, r25	; 0x02
    5b88:	89 83       	std	Y+1, r24	; 0x01

	if( pxHandle != NULL )
    5b8a:	89 81       	ldd	r24, Y+1	; 0x01
    5b8c:	9a 81       	ldd	r25, Y+2	; 0x02
    5b8e:	00 97       	sbiw	r24, 0x00	; 0
    5b90:	21 f0       	breq	.+8      	; 0x5b9a <xQueueCreateCountingSemaphore+0x2c>
	{
		pxHandle->uxMessagesWaiting = uxInitialCount;
    5b92:	e9 81       	ldd	r30, Y+1	; 0x01
    5b94:	fa 81       	ldd	r31, Y+2	; 0x02
    5b96:	8c 81       	ldd	r24, Y+4	; 0x04
    5b98:	82 8f       	std	Z+26, r24	; 0x1a
	{
		traceCREATE_COUNTING_SEMAPHORE_FAILED();
	}

	configASSERT( pxHandle );
	return pxHandle;
    5b9a:	89 81       	ldd	r24, Y+1	; 0x01
    5b9c:	9a 81       	ldd	r25, Y+2	; 0x02
}
    5b9e:	0f 90       	pop	r0
    5ba0:	0f 90       	pop	r0
    5ba2:	0f 90       	pop	r0
    5ba4:	0f 90       	pop	r0
    5ba6:	cf 91       	pop	r28
    5ba8:	df 91       	pop	r29
    5baa:	08 95       	ret

00005bac <xQueueGenericSend>:

#endif /* configUSE_COUNTING_SEMAPHORES */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSend( xQueueHandle pxQueue, const void * const pvItemToQueue, portTickType xTicksToWait, portBASE_TYPE xCopyPosition )
{
    5bac:	df 93       	push	r29
    5bae:	cf 93       	push	r28
    5bb0:	cd b7       	in	r28, 0x3d	; 61
    5bb2:	de b7       	in	r29, 0x3e	; 62
    5bb4:	2c 97       	sbiw	r28, 0x0c	; 12
    5bb6:	0f b6       	in	r0, 0x3f	; 63
    5bb8:	f8 94       	cli
    5bba:	de bf       	out	0x3e, r29	; 62
    5bbc:	0f be       	out	0x3f, r0	; 63
    5bbe:	cd bf       	out	0x3d, r28	; 61
    5bc0:	9e 83       	std	Y+6, r25	; 0x06
    5bc2:	8d 83       	std	Y+5, r24	; 0x05
    5bc4:	78 87       	std	Y+8, r23	; 0x08
    5bc6:	6f 83       	std	Y+7, r22	; 0x07
    5bc8:	5a 87       	std	Y+10, r21	; 0x0a
    5bca:	49 87       	std	Y+9, r20	; 0x09
    5bcc:	2b 87       	std	Y+11, r18	; 0x0b
	signed portBASE_TYPE xEntryTimeSet = pdFALSE;
    5bce:	19 82       	std	Y+1, r1	; 0x01
	/* This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    5bd0:	0f b6       	in	r0, 0x3f	; 63
    5bd2:	f8 94       	cli
    5bd4:	0f 92       	push	r0
		{
			/* Is there room on the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
    5bd6:	ed 81       	ldd	r30, Y+5	; 0x05
    5bd8:	fe 81       	ldd	r31, Y+6	; 0x06
    5bda:	92 8d       	ldd	r25, Z+26	; 0x1a
    5bdc:	ed 81       	ldd	r30, Y+5	; 0x05
    5bde:	fe 81       	ldd	r31, Y+6	; 0x06
    5be0:	83 8d       	ldd	r24, Z+27	; 0x1b
    5be2:	98 17       	cp	r25, r24
    5be4:	d8 f4       	brcc	.+54     	; 0x5c1c <xQueueGenericSend+0x70>
			{
				traceQUEUE_SEND( pxQueue );
				prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    5be6:	8d 81       	ldd	r24, Y+5	; 0x05
    5be8:	9e 81       	ldd	r25, Y+6	; 0x06
    5bea:	2f 81       	ldd	r18, Y+7	; 0x07
    5bec:	38 85       	ldd	r19, Y+8	; 0x08
    5bee:	b9 01       	movw	r22, r18
    5bf0:	4b 85       	ldd	r20, Y+11	; 0x0b
    5bf2:	0e 94 11 30 	call	0x6022	; 0x6022 <prvCopyDataToQueue>

				/* If there was a task waiting for data to arrive on the
				queue then unblock it now. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    5bf6:	ed 81       	ldd	r30, Y+5	; 0x05
    5bf8:	fe 81       	ldd	r31, Y+6	; 0x06
    5bfa:	81 89       	ldd	r24, Z+17	; 0x11
    5bfc:	88 23       	and	r24, r24
    5bfe:	49 f0       	breq	.+18     	; 0x5c12 <xQueueGenericSend+0x66>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
    5c00:	8d 81       	ldd	r24, Y+5	; 0x05
    5c02:	9e 81       	ldd	r25, Y+6	; 0x06
    5c04:	41 96       	adiw	r24, 0x11	; 17
    5c06:	0e 94 26 36 	call	0x6c4c	; 0x6c4c <xTaskRemoveFromEventList>
    5c0a:	81 30       	cpi	r24, 0x01	; 1
    5c0c:	11 f4       	brne	.+4      	; 0x5c12 <xQueueGenericSend+0x66>
					{
						/* The unblocked task has a priority higher than
						our own so yield immediately.  Yes it is ok to do
						this from within the critical section - the kernel
						takes care of that. */
						portYIELD_WITHIN_API();
    5c0e:	0e 94 fb 2b 	call	0x57f6	; 0x57f6 <vPortYield>
					}
				}

				taskEXIT_CRITICAL();
    5c12:	0f 90       	pop	r0
    5c14:	0f be       	out	0x3f, r0	; 63

				/* Return to the original privilege level before exiting the
				function. */
				return pdPASS;
    5c16:	81 e0       	ldi	r24, 0x01	; 1
    5c18:	8c 87       	std	Y+12, r24	; 0x0c
    5c1a:	5c c0       	rjmp	.+184    	; 0x5cd4 <xQueueGenericSend+0x128>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
    5c1c:	89 85       	ldd	r24, Y+9	; 0x09
    5c1e:	9a 85       	ldd	r25, Y+10	; 0x0a
    5c20:	00 97       	sbiw	r24, 0x00	; 0
    5c22:	21 f4       	brne	.+8      	; 0x5c2c <xQueueGenericSend+0x80>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    5c24:	0f 90       	pop	r0
    5c26:	0f be       	out	0x3f, r0	; 63

					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
    5c28:	1c 86       	std	Y+12, r1	; 0x0c
    5c2a:	54 c0       	rjmp	.+168    	; 0x5cd4 <xQueueGenericSend+0x128>
				}
				else if( xEntryTimeSet == pdFALSE )
    5c2c:	89 81       	ldd	r24, Y+1	; 0x01
    5c2e:	88 23       	and	r24, r24
    5c30:	31 f4       	brne	.+12     	; 0x5c3e <xQueueGenericSend+0x92>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    5c32:	ce 01       	movw	r24, r28
    5c34:	02 96       	adiw	r24, 0x02	; 2
    5c36:	0e 94 8e 36 	call	0x6d1c	; 0x6d1c <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    5c3a:	81 e0       	ldi	r24, 0x01	; 1
    5c3c:	89 83       	std	Y+1, r24	; 0x01
				}
			}
		}
		taskEXIT_CRITICAL();
    5c3e:	0f 90       	pop	r0
    5c40:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    5c42:	0e 94 ea 33 	call	0x67d4	; 0x67d4 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    5c46:	0f b6       	in	r0, 0x3f	; 63
    5c48:	f8 94       	cli
    5c4a:	0f 92       	push	r0
    5c4c:	ed 81       	ldd	r30, Y+5	; 0x05
    5c4e:	fe 81       	ldd	r31, Y+6	; 0x06
    5c50:	85 8d       	ldd	r24, Z+29	; 0x1d
    5c52:	8f 3f       	cpi	r24, 0xFF	; 255
    5c54:	19 f4       	brne	.+6      	; 0x5c5c <xQueueGenericSend+0xb0>
    5c56:	ed 81       	ldd	r30, Y+5	; 0x05
    5c58:	fe 81       	ldd	r31, Y+6	; 0x06
    5c5a:	15 8e       	std	Z+29, r1	; 0x1d
    5c5c:	ed 81       	ldd	r30, Y+5	; 0x05
    5c5e:	fe 81       	ldd	r31, Y+6	; 0x06
    5c60:	86 8d       	ldd	r24, Z+30	; 0x1e
    5c62:	8f 3f       	cpi	r24, 0xFF	; 255
    5c64:	19 f4       	brne	.+6      	; 0x5c6c <xQueueGenericSend+0xc0>
    5c66:	ed 81       	ldd	r30, Y+5	; 0x05
    5c68:	fe 81       	ldd	r31, Y+6	; 0x06
    5c6a:	16 8e       	std	Z+30, r1	; 0x1e
    5c6c:	0f 90       	pop	r0
    5c6e:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    5c70:	ce 01       	movw	r24, r28
    5c72:	02 96       	adiw	r24, 0x02	; 2
    5c74:	9e 01       	movw	r18, r28
    5c76:	27 5f       	subi	r18, 0xF7	; 247
    5c78:	3f 4f       	sbci	r19, 0xFF	; 255
    5c7a:	b9 01       	movw	r22, r18
    5c7c:	0e 94 a7 36 	call	0x6d4e	; 0x6d4e <xTaskCheckForTimeOut>
    5c80:	88 23       	and	r24, r24
    5c82:	09 f5       	brne	.+66     	; 0x5cc6 <xQueueGenericSend+0x11a>
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
    5c84:	8d 81       	ldd	r24, Y+5	; 0x05
    5c86:	9e 81       	ldd	r25, Y+6	; 0x06
    5c88:	0e 94 75 31 	call	0x62ea	; 0x62ea <prvIsQueueFull>
    5c8c:	88 23       	and	r24, r24
    5c8e:	a1 f0       	breq	.+40     	; 0x5cb8 <xQueueGenericSend+0x10c>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    5c90:	8d 81       	ldd	r24, Y+5	; 0x05
    5c92:	9e 81       	ldd	r25, Y+6	; 0x06
    5c94:	08 96       	adiw	r24, 0x08	; 8
    5c96:	29 85       	ldd	r18, Y+9	; 0x09
    5c98:	3a 85       	ldd	r19, Y+10	; 0x0a
    5c9a:	b9 01       	movw	r22, r18
    5c9c:	0e 94 f0 35 	call	0x6be0	; 0x6be0 <vTaskPlaceOnEventList>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible	that interrupts occurring now
				remove this task from the event	list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
    5ca0:	8d 81       	ldd	r24, Y+5	; 0x05
    5ca2:	9e 81       	ldd	r25, Y+6	; 0x06
    5ca4:	0e 94 ee 30 	call	0x61dc	; 0x61dc <prvUnlockQueue>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( xTaskResumeAll() == pdFALSE )
    5ca8:	0e 94 f6 33 	call	0x67ec	; 0x67ec <xTaskResumeAll>
    5cac:	88 23       	and	r24, r24
    5cae:	09 f0       	breq	.+2      	; 0x5cb2 <xQueueGenericSend+0x106>
    5cb0:	8f cf       	rjmp	.-226    	; 0x5bd0 <xQueueGenericSend+0x24>
				{
					portYIELD_WITHIN_API();
    5cb2:	0e 94 fb 2b 	call	0x57f6	; 0x57f6 <vPortYield>
    5cb6:	8c cf       	rjmp	.-232    	; 0x5bd0 <xQueueGenericSend+0x24>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    5cb8:	8d 81       	ldd	r24, Y+5	; 0x05
    5cba:	9e 81       	ldd	r25, Y+6	; 0x06
    5cbc:	0e 94 ee 30 	call	0x61dc	; 0x61dc <prvUnlockQueue>
				( void ) xTaskResumeAll();
    5cc0:	0e 94 f6 33 	call	0x67ec	; 0x67ec <xTaskResumeAll>
    5cc4:	85 cf       	rjmp	.-246    	; 0x5bd0 <xQueueGenericSend+0x24>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
    5cc6:	8d 81       	ldd	r24, Y+5	; 0x05
    5cc8:	9e 81       	ldd	r25, Y+6	; 0x06
    5cca:	0e 94 ee 30 	call	0x61dc	; 0x61dc <prvUnlockQueue>
			( void ) xTaskResumeAll();
    5cce:	0e 94 f6 33 	call	0x67ec	; 0x67ec <xTaskResumeAll>

			/* Return to the original privilege level before exiting the
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
    5cd2:	1c 86       	std	Y+12, r1	; 0x0c
    5cd4:	8c 85       	ldd	r24, Y+12	; 0x0c
		}
	}
}
    5cd6:	2c 96       	adiw	r28, 0x0c	; 12
    5cd8:	0f b6       	in	r0, 0x3f	; 63
    5cda:	f8 94       	cli
    5cdc:	de bf       	out	0x3e, r29	; 62
    5cde:	0f be       	out	0x3f, r0	; 63
    5ce0:	cd bf       	out	0x3d, r28	; 61
    5ce2:	cf 91       	pop	r28
    5ce4:	df 91       	pop	r29
    5ce6:	08 95       	ret

00005ce8 <xQueueGenericSendFromISR>:

#endif /* configUSE_ALTERNATIVE_API */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSendFromISR( xQueueHandle pxQueue, const void * const pvItemToQueue, signed portBASE_TYPE *pxHigherPriorityTaskWoken, portBASE_TYPE xCopyPosition )
{
    5ce8:	df 93       	push	r29
    5cea:	cf 93       	push	r28
    5cec:	cd b7       	in	r28, 0x3d	; 61
    5cee:	de b7       	in	r29, 0x3e	; 62
    5cf0:	29 97       	sbiw	r28, 0x09	; 9
    5cf2:	0f b6       	in	r0, 0x3f	; 63
    5cf4:	f8 94       	cli
    5cf6:	de bf       	out	0x3e, r29	; 62
    5cf8:	0f be       	out	0x3f, r0	; 63
    5cfa:	cd bf       	out	0x3d, r28	; 61
    5cfc:	9c 83       	std	Y+4, r25	; 0x04
    5cfe:	8b 83       	std	Y+3, r24	; 0x03
    5d00:	7e 83       	std	Y+6, r23	; 0x06
    5d02:	6d 83       	std	Y+5, r22	; 0x05
    5d04:	58 87       	std	Y+8, r21	; 0x08
    5d06:	4f 83       	std	Y+7, r20	; 0x07
    5d08:	29 87       	std	Y+9, r18	; 0x09
	/* Similar to xQueueGenericSend, except we don't block if there is no room
	in the queue.  Also we don't directly wake a task that was blocked on a
	queue read, instead we return a flag to say whether a context switch is
	required or not (i.e. has a task with a higher priority than us been woken
	by this	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    5d0a:	19 82       	std	Y+1, r1	; 0x01
	{
		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
    5d0c:	eb 81       	ldd	r30, Y+3	; 0x03
    5d0e:	fc 81       	ldd	r31, Y+4	; 0x04
    5d10:	92 8d       	ldd	r25, Z+26	; 0x1a
    5d12:	eb 81       	ldd	r30, Y+3	; 0x03
    5d14:	fc 81       	ldd	r31, Y+4	; 0x04
    5d16:	83 8d       	ldd	r24, Z+27	; 0x1b
    5d18:	98 17       	cp	r25, r24
    5d1a:	40 f5       	brcc	.+80     	; 0x5d6c <xQueueGenericSendFromISR+0x84>
		{
			traceQUEUE_SEND_FROM_ISR( pxQueue );

			prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    5d1c:	8b 81       	ldd	r24, Y+3	; 0x03
    5d1e:	9c 81       	ldd	r25, Y+4	; 0x04
    5d20:	2d 81       	ldd	r18, Y+5	; 0x05
    5d22:	3e 81       	ldd	r19, Y+6	; 0x06
    5d24:	b9 01       	movw	r22, r18
    5d26:	49 85       	ldd	r20, Y+9	; 0x09
    5d28:	0e 94 11 30 	call	0x6022	; 0x6022 <prvCopyDataToQueue>

			/* If the queue is locked we do not alter the event list.  This will
			be done when the queue is unlocked later. */
			if( pxQueue->xTxLock == queueUNLOCKED )
    5d2c:	eb 81       	ldd	r30, Y+3	; 0x03
    5d2e:	fc 81       	ldd	r31, Y+4	; 0x04
    5d30:	86 8d       	ldd	r24, Z+30	; 0x1e
    5d32:	8f 3f       	cpi	r24, 0xFF	; 255
    5d34:	89 f4       	brne	.+34     	; 0x5d58 <xQueueGenericSendFromISR+0x70>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    5d36:	eb 81       	ldd	r30, Y+3	; 0x03
    5d38:	fc 81       	ldd	r31, Y+4	; 0x04
    5d3a:	81 89       	ldd	r24, Z+17	; 0x11
    5d3c:	88 23       	and	r24, r24
    5d3e:	99 f0       	breq	.+38     	; 0x5d66 <xQueueGenericSendFromISR+0x7e>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    5d40:	8b 81       	ldd	r24, Y+3	; 0x03
    5d42:	9c 81       	ldd	r25, Y+4	; 0x04
    5d44:	41 96       	adiw	r24, 0x11	; 17
    5d46:	0e 94 26 36 	call	0x6c4c	; 0x6c4c <xTaskRemoveFromEventList>
    5d4a:	88 23       	and	r24, r24
    5d4c:	61 f0       	breq	.+24     	; 0x5d66 <xQueueGenericSendFromISR+0x7e>
					{
						/* The task waiting has a higher priority so record that a
						context	switch is required. */
						*pxHigherPriorityTaskWoken = pdTRUE;
    5d4e:	ef 81       	ldd	r30, Y+7	; 0x07
    5d50:	f8 85       	ldd	r31, Y+8	; 0x08
    5d52:	81 e0       	ldi	r24, 0x01	; 1
    5d54:	80 83       	st	Z, r24
    5d56:	07 c0       	rjmp	.+14     	; 0x5d66 <xQueueGenericSendFromISR+0x7e>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
    5d58:	eb 81       	ldd	r30, Y+3	; 0x03
    5d5a:	fc 81       	ldd	r31, Y+4	; 0x04
    5d5c:	86 8d       	ldd	r24, Z+30	; 0x1e
    5d5e:	8f 5f       	subi	r24, 0xFF	; 255
    5d60:	eb 81       	ldd	r30, Y+3	; 0x03
    5d62:	fc 81       	ldd	r31, Y+4	; 0x04
    5d64:	86 8f       	std	Z+30, r24	; 0x1e
			}

			xReturn = pdPASS;
    5d66:	81 e0       	ldi	r24, 0x01	; 1
    5d68:	8a 83       	std	Y+2, r24	; 0x02
    5d6a:	01 c0       	rjmp	.+2      	; 0x5d6e <xQueueGenericSendFromISR+0x86>
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
    5d6c:	1a 82       	std	Y+2, r1	; 0x02
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    5d6e:	8a 81       	ldd	r24, Y+2	; 0x02
}
    5d70:	29 96       	adiw	r28, 0x09	; 9
    5d72:	0f b6       	in	r0, 0x3f	; 63
    5d74:	f8 94       	cli
    5d76:	de bf       	out	0x3e, r29	; 62
    5d78:	0f be       	out	0x3f, r0	; 63
    5d7a:	cd bf       	out	0x3d, r28	; 61
    5d7c:	cf 91       	pop	r28
    5d7e:	df 91       	pop	r29
    5d80:	08 95       	ret

00005d82 <xQueueGenericReceive>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericReceive( xQueueHandle pxQueue, void * const pvBuffer, portTickType xTicksToWait, portBASE_TYPE xJustPeeking )
{
    5d82:	df 93       	push	r29
    5d84:	cf 93       	push	r28
    5d86:	cd b7       	in	r28, 0x3d	; 61
    5d88:	de b7       	in	r29, 0x3e	; 62
    5d8a:	2e 97       	sbiw	r28, 0x0e	; 14
    5d8c:	0f b6       	in	r0, 0x3f	; 63
    5d8e:	f8 94       	cli
    5d90:	de bf       	out	0x3e, r29	; 62
    5d92:	0f be       	out	0x3f, r0	; 63
    5d94:	cd bf       	out	0x3d, r28	; 61
    5d96:	98 87       	std	Y+8, r25	; 0x08
    5d98:	8f 83       	std	Y+7, r24	; 0x07
    5d9a:	7a 87       	std	Y+10, r23	; 0x0a
    5d9c:	69 87       	std	Y+9, r22	; 0x09
    5d9e:	5c 87       	std	Y+12, r21	; 0x0c
    5da0:	4b 87       	std	Y+11, r20	; 0x0b
    5da2:	2d 87       	std	Y+13, r18	; 0x0d
	signed portBASE_TYPE xEntryTimeSet = pdFALSE;
    5da4:	1b 82       	std	Y+3, r1	; 0x03
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
    5da6:	0f b6       	in	r0, 0x3f	; 63
    5da8:	f8 94       	cli
    5daa:	0f 92       	push	r0
		{
			/* Is there data in the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
    5dac:	ef 81       	ldd	r30, Y+7	; 0x07
    5dae:	f8 85       	ldd	r31, Y+8	; 0x08
    5db0:	82 8d       	ldd	r24, Z+26	; 0x1a
    5db2:	88 23       	and	r24, r24
    5db4:	09 f4       	brne	.+2      	; 0x5db8 <xQueueGenericReceive+0x36>
    5db6:	3f c0       	rjmp	.+126    	; 0x5e36 <xQueueGenericReceive+0xb4>
			{
				/* Remember our read position in case we are just peeking. */
				pcOriginalReadPosition = pxQueue->pcReadFrom;
    5db8:	ef 81       	ldd	r30, Y+7	; 0x07
    5dba:	f8 85       	ldd	r31, Y+8	; 0x08
    5dbc:	86 81       	ldd	r24, Z+6	; 0x06
    5dbe:	97 81       	ldd	r25, Z+7	; 0x07
    5dc0:	9a 83       	std	Y+2, r25	; 0x02
    5dc2:	89 83       	std	Y+1, r24	; 0x01

				prvCopyDataFromQueue( pxQueue, pvBuffer );
    5dc4:	8f 81       	ldd	r24, Y+7	; 0x07
    5dc6:	98 85       	ldd	r25, Y+8	; 0x08
    5dc8:	29 85       	ldd	r18, Y+9	; 0x09
    5dca:	3a 85       	ldd	r19, Y+10	; 0x0a
    5dcc:	b9 01       	movw	r22, r18
    5dce:	0e 94 a6 30 	call	0x614c	; 0x614c <prvCopyDataFromQueue>

				if( xJustPeeking == pdFALSE )
    5dd2:	8d 85       	ldd	r24, Y+13	; 0x0d
    5dd4:	88 23       	and	r24, r24
    5dd6:	b1 f4       	brne	.+44     	; 0x5e04 <xQueueGenericReceive+0x82>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* We are actually removing data. */
					--( pxQueue->uxMessagesWaiting );
    5dd8:	ef 81       	ldd	r30, Y+7	; 0x07
    5dda:	f8 85       	ldd	r31, Y+8	; 0x08
    5ddc:	82 8d       	ldd	r24, Z+26	; 0x1a
    5dde:	81 50       	subi	r24, 0x01	; 1
    5de0:	ef 81       	ldd	r30, Y+7	; 0x07
    5de2:	f8 85       	ldd	r31, Y+8	; 0x08
    5de4:	82 8f       	std	Z+26, r24	; 0x1a
							pxQueue->pxMutexHolder = xTaskGetCurrentTaskHandle();
						}
					}
#endif

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    5de6:	ef 81       	ldd	r30, Y+7	; 0x07
    5de8:	f8 85       	ldd	r31, Y+8	; 0x08
    5dea:	80 85       	ldd	r24, Z+8	; 0x08
    5dec:	88 23       	and	r24, r24
    5dee:	f1 f0       	breq	.+60     	; 0x5e2c <xQueueGenericReceive+0xaa>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
    5df0:	8f 81       	ldd	r24, Y+7	; 0x07
    5df2:	98 85       	ldd	r25, Y+8	; 0x08
    5df4:	08 96       	adiw	r24, 0x08	; 8
    5df6:	0e 94 26 36 	call	0x6c4c	; 0x6c4c <xTaskRemoveFromEventList>
    5dfa:	81 30       	cpi	r24, 0x01	; 1
    5dfc:	b9 f4       	brne	.+46     	; 0x5e2c <xQueueGenericReceive+0xaa>
						{
							portYIELD_WITHIN_API();
    5dfe:	0e 94 fb 2b 	call	0x57f6	; 0x57f6 <vPortYield>
    5e02:	14 c0       	rjmp	.+40     	; 0x5e2c <xQueueGenericReceive+0xaa>
				{
					traceQUEUE_PEEK( pxQueue );

					/* We are not removing the data, so reset our read
					pointer. */
					pxQueue->pcReadFrom = pcOriginalReadPosition;
    5e04:	ef 81       	ldd	r30, Y+7	; 0x07
    5e06:	f8 85       	ldd	r31, Y+8	; 0x08
    5e08:	89 81       	ldd	r24, Y+1	; 0x01
    5e0a:	9a 81       	ldd	r25, Y+2	; 0x02
    5e0c:	97 83       	std	Z+7, r25	; 0x07
    5e0e:	86 83       	std	Z+6, r24	; 0x06

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    5e10:	ef 81       	ldd	r30, Y+7	; 0x07
    5e12:	f8 85       	ldd	r31, Y+8	; 0x08
    5e14:	81 89       	ldd	r24, Z+17	; 0x11
    5e16:	88 23       	and	r24, r24
    5e18:	49 f0       	breq	.+18     	; 0x5e2c <xQueueGenericReceive+0xaa>
					{
						/* Tasks that are removed from the event list will get added to
						the pending ready list as the scheduler is still suspended. */
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    5e1a:	8f 81       	ldd	r24, Y+7	; 0x07
    5e1c:	98 85       	ldd	r25, Y+8	; 0x08
    5e1e:	41 96       	adiw	r24, 0x11	; 17
    5e20:	0e 94 26 36 	call	0x6c4c	; 0x6c4c <xTaskRemoveFromEventList>
    5e24:	88 23       	and	r24, r24
    5e26:	11 f0       	breq	.+4      	; 0x5e2c <xQueueGenericReceive+0xaa>
						{
							/* The task waiting has a higher priority than this task. */
							portYIELD_WITHIN_API();
    5e28:	0e 94 fb 2b 	call	0x57f6	; 0x57f6 <vPortYield>
						}
					}

				}

				taskEXIT_CRITICAL();
    5e2c:	0f 90       	pop	r0
    5e2e:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    5e30:	81 e0       	ldi	r24, 0x01	; 1
    5e32:	8e 87       	std	Y+14, r24	; 0x0e
    5e34:	5c c0       	rjmp	.+184    	; 0x5eee <xQueueGenericReceive+0x16c>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
    5e36:	8b 85       	ldd	r24, Y+11	; 0x0b
    5e38:	9c 85       	ldd	r25, Y+12	; 0x0c
    5e3a:	00 97       	sbiw	r24, 0x00	; 0
    5e3c:	21 f4       	brne	.+8      	; 0x5e46 <xQueueGenericReceive+0xc4>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    5e3e:	0f 90       	pop	r0
    5e40:	0f be       	out	0x3f, r0	; 63
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
    5e42:	1e 86       	std	Y+14, r1	; 0x0e
    5e44:	54 c0       	rjmp	.+168    	; 0x5eee <xQueueGenericReceive+0x16c>
				}
				else if( xEntryTimeSet == pdFALSE )
    5e46:	8b 81       	ldd	r24, Y+3	; 0x03
    5e48:	88 23       	and	r24, r24
    5e4a:	31 f4       	brne	.+12     	; 0x5e58 <xQueueGenericReceive+0xd6>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    5e4c:	ce 01       	movw	r24, r28
    5e4e:	04 96       	adiw	r24, 0x04	; 4
    5e50:	0e 94 8e 36 	call	0x6d1c	; 0x6d1c <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    5e54:	81 e0       	ldi	r24, 0x01	; 1
    5e56:	8b 83       	std	Y+3, r24	; 0x03
				}
			}
		}
		taskEXIT_CRITICAL();
    5e58:	0f 90       	pop	r0
    5e5a:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    5e5c:	0e 94 ea 33 	call	0x67d4	; 0x67d4 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    5e60:	0f b6       	in	r0, 0x3f	; 63
    5e62:	f8 94       	cli
    5e64:	0f 92       	push	r0
    5e66:	ef 81       	ldd	r30, Y+7	; 0x07
    5e68:	f8 85       	ldd	r31, Y+8	; 0x08
    5e6a:	85 8d       	ldd	r24, Z+29	; 0x1d
    5e6c:	8f 3f       	cpi	r24, 0xFF	; 255
    5e6e:	19 f4       	brne	.+6      	; 0x5e76 <xQueueGenericReceive+0xf4>
    5e70:	ef 81       	ldd	r30, Y+7	; 0x07
    5e72:	f8 85       	ldd	r31, Y+8	; 0x08
    5e74:	15 8e       	std	Z+29, r1	; 0x1d
    5e76:	ef 81       	ldd	r30, Y+7	; 0x07
    5e78:	f8 85       	ldd	r31, Y+8	; 0x08
    5e7a:	86 8d       	ldd	r24, Z+30	; 0x1e
    5e7c:	8f 3f       	cpi	r24, 0xFF	; 255
    5e7e:	19 f4       	brne	.+6      	; 0x5e86 <xQueueGenericReceive+0x104>
    5e80:	ef 81       	ldd	r30, Y+7	; 0x07
    5e82:	f8 85       	ldd	r31, Y+8	; 0x08
    5e84:	16 8e       	std	Z+30, r1	; 0x1e
    5e86:	0f 90       	pop	r0
    5e88:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    5e8a:	ce 01       	movw	r24, r28
    5e8c:	04 96       	adiw	r24, 0x04	; 4
    5e8e:	9e 01       	movw	r18, r28
    5e90:	25 5f       	subi	r18, 0xF5	; 245
    5e92:	3f 4f       	sbci	r19, 0xFF	; 255
    5e94:	b9 01       	movw	r22, r18
    5e96:	0e 94 a7 36 	call	0x6d4e	; 0x6d4e <xTaskCheckForTimeOut>
    5e9a:	88 23       	and	r24, r24
    5e9c:	09 f5       	brne	.+66     	; 0x5ee0 <xQueueGenericReceive+0x15e>
		{
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    5e9e:	8f 81       	ldd	r24, Y+7	; 0x07
    5ea0:	98 85       	ldd	r25, Y+8	; 0x08
    5ea2:	0e 94 42 31 	call	0x6284	; 0x6284 <prvIsQueueEmpty>
    5ea6:	88 23       	and	r24, r24
    5ea8:	a1 f0       	breq	.+40     	; 0x5ed2 <xQueueGenericReceive+0x150>
						portEXIT_CRITICAL();
					}
				}
#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    5eaa:	8f 81       	ldd	r24, Y+7	; 0x07
    5eac:	98 85       	ldd	r25, Y+8	; 0x08
    5eae:	41 96       	adiw	r24, 0x11	; 17
    5eb0:	2b 85       	ldd	r18, Y+11	; 0x0b
    5eb2:	3c 85       	ldd	r19, Y+12	; 0x0c
    5eb4:	b9 01       	movw	r22, r18
    5eb6:	0e 94 f0 35 	call	0x6be0	; 0x6be0 <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    5eba:	8f 81       	ldd	r24, Y+7	; 0x07
    5ebc:	98 85       	ldd	r25, Y+8	; 0x08
    5ebe:	0e 94 ee 30 	call	0x61dc	; 0x61dc <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
    5ec2:	0e 94 f6 33 	call	0x67ec	; 0x67ec <xTaskResumeAll>
    5ec6:	88 23       	and	r24, r24
    5ec8:	09 f0       	breq	.+2      	; 0x5ecc <xQueueGenericReceive+0x14a>
    5eca:	6d cf       	rjmp	.-294    	; 0x5da6 <xQueueGenericReceive+0x24>
				{
					portYIELD_WITHIN_API();
    5ecc:	0e 94 fb 2b 	call	0x57f6	; 0x57f6 <vPortYield>
    5ed0:	6a cf       	rjmp	.-300    	; 0x5da6 <xQueueGenericReceive+0x24>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    5ed2:	8f 81       	ldd	r24, Y+7	; 0x07
    5ed4:	98 85       	ldd	r25, Y+8	; 0x08
    5ed6:	0e 94 ee 30 	call	0x61dc	; 0x61dc <prvUnlockQueue>
				( void ) xTaskResumeAll();
    5eda:	0e 94 f6 33 	call	0x67ec	; 0x67ec <xTaskResumeAll>
    5ede:	63 cf       	rjmp	.-314    	; 0x5da6 <xQueueGenericReceive+0x24>
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
    5ee0:	8f 81       	ldd	r24, Y+7	; 0x07
    5ee2:	98 85       	ldd	r25, Y+8	; 0x08
    5ee4:	0e 94 ee 30 	call	0x61dc	; 0x61dc <prvUnlockQueue>
			( void ) xTaskResumeAll();
    5ee8:	0e 94 f6 33 	call	0x67ec	; 0x67ec <xTaskResumeAll>
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
    5eec:	1e 86       	std	Y+14, r1	; 0x0e
    5eee:	8e 85       	ldd	r24, Y+14	; 0x0e
		}
	}
}
    5ef0:	2e 96       	adiw	r28, 0x0e	; 14
    5ef2:	0f b6       	in	r0, 0x3f	; 63
    5ef4:	f8 94       	cli
    5ef6:	de bf       	out	0x3e, r29	; 62
    5ef8:	0f be       	out	0x3f, r0	; 63
    5efa:	cd bf       	out	0x3d, r28	; 61
    5efc:	cf 91       	pop	r28
    5efe:	df 91       	pop	r29
    5f00:	08 95       	ret

00005f02 <xQueueReceiveFromISR>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueReceiveFromISR( xQueueHandle pxQueue, void * const pvBuffer, signed portBASE_TYPE *pxTaskWoken )
{
    5f02:	df 93       	push	r29
    5f04:	cf 93       	push	r28
    5f06:	cd b7       	in	r28, 0x3d	; 61
    5f08:	de b7       	in	r29, 0x3e	; 62
    5f0a:	28 97       	sbiw	r28, 0x08	; 8
    5f0c:	0f b6       	in	r0, 0x3f	; 63
    5f0e:	f8 94       	cli
    5f10:	de bf       	out	0x3e, r29	; 62
    5f12:	0f be       	out	0x3f, r0	; 63
    5f14:	cd bf       	out	0x3d, r28	; 61
    5f16:	9c 83       	std	Y+4, r25	; 0x04
    5f18:	8b 83       	std	Y+3, r24	; 0x03
    5f1a:	7e 83       	std	Y+6, r23	; 0x06
    5f1c:	6d 83       	std	Y+5, r22	; 0x05
    5f1e:	58 87       	std	Y+8, r21	; 0x08
    5f20:	4f 83       	std	Y+7, r20	; 0x07

	configASSERT( pxQueue );
	configASSERT( pxTaskWoken );
	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( unsigned portBASE_TYPE ) 0U ) ) );

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    5f22:	19 82       	std	Y+1, r1	; 0x01
	{
		/* We cannot block from an ISR, so check there is data available. */
		if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
    5f24:	eb 81       	ldd	r30, Y+3	; 0x03
    5f26:	fc 81       	ldd	r31, Y+4	; 0x04
    5f28:	82 8d       	ldd	r24, Z+26	; 0x1a
    5f2a:	88 23       	and	r24, r24
    5f2c:	71 f1       	breq	.+92     	; 0x5f8a <xQueueReceiveFromISR+0x88>
		{
			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );

			prvCopyDataFromQueue( pxQueue, pvBuffer );
    5f2e:	8b 81       	ldd	r24, Y+3	; 0x03
    5f30:	9c 81       	ldd	r25, Y+4	; 0x04
    5f32:	2d 81       	ldd	r18, Y+5	; 0x05
    5f34:	3e 81       	ldd	r19, Y+6	; 0x06
    5f36:	b9 01       	movw	r22, r18
    5f38:	0e 94 a6 30 	call	0x614c	; 0x614c <prvCopyDataFromQueue>
			--( pxQueue->uxMessagesWaiting );
    5f3c:	eb 81       	ldd	r30, Y+3	; 0x03
    5f3e:	fc 81       	ldd	r31, Y+4	; 0x04
    5f40:	82 8d       	ldd	r24, Z+26	; 0x1a
    5f42:	81 50       	subi	r24, 0x01	; 1
    5f44:	eb 81       	ldd	r30, Y+3	; 0x03
    5f46:	fc 81       	ldd	r31, Y+4	; 0x04
    5f48:	82 8f       	std	Z+26, r24	; 0x1a

			/* If the queue is locked we will not modify the event list.  Instead
			we update the lock count so the task that unlocks the queue will know
			that an ISR has removed data while the queue was locked. */
			if( pxQueue->xRxLock == queueUNLOCKED )
    5f4a:	eb 81       	ldd	r30, Y+3	; 0x03
    5f4c:	fc 81       	ldd	r31, Y+4	; 0x04
    5f4e:	85 8d       	ldd	r24, Z+29	; 0x1d
    5f50:	8f 3f       	cpi	r24, 0xFF	; 255
    5f52:	89 f4       	brne	.+34     	; 0x5f76 <xQueueReceiveFromISR+0x74>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    5f54:	eb 81       	ldd	r30, Y+3	; 0x03
    5f56:	fc 81       	ldd	r31, Y+4	; 0x04
    5f58:	80 85       	ldd	r24, Z+8	; 0x08
    5f5a:	88 23       	and	r24, r24
    5f5c:	99 f0       	breq	.+38     	; 0x5f84 <xQueueReceiveFromISR+0x82>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    5f5e:	8b 81       	ldd	r24, Y+3	; 0x03
    5f60:	9c 81       	ldd	r25, Y+4	; 0x04
    5f62:	08 96       	adiw	r24, 0x08	; 8
    5f64:	0e 94 26 36 	call	0x6c4c	; 0x6c4c <xTaskRemoveFromEventList>
    5f68:	88 23       	and	r24, r24
    5f6a:	61 f0       	breq	.+24     	; 0x5f84 <xQueueReceiveFromISR+0x82>
					{
						/* The task waiting has a higher priority than us so
						force a context switch. */
						*pxTaskWoken = pdTRUE;
    5f6c:	ef 81       	ldd	r30, Y+7	; 0x07
    5f6e:	f8 85       	ldd	r31, Y+8	; 0x08
    5f70:	81 e0       	ldi	r24, 0x01	; 1
    5f72:	80 83       	st	Z, r24
    5f74:	07 c0       	rjmp	.+14     	; 0x5f84 <xQueueReceiveFromISR+0x82>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				++( pxQueue->xRxLock );
    5f76:	eb 81       	ldd	r30, Y+3	; 0x03
    5f78:	fc 81       	ldd	r31, Y+4	; 0x04
    5f7a:	85 8d       	ldd	r24, Z+29	; 0x1d
    5f7c:	8f 5f       	subi	r24, 0xFF	; 255
    5f7e:	eb 81       	ldd	r30, Y+3	; 0x03
    5f80:	fc 81       	ldd	r31, Y+4	; 0x04
    5f82:	85 8f       	std	Z+29, r24	; 0x1d
			}

			xReturn = pdPASS;
    5f84:	81 e0       	ldi	r24, 0x01	; 1
    5f86:	8a 83       	std	Y+2, r24	; 0x02
    5f88:	01 c0       	rjmp	.+2      	; 0x5f8c <xQueueReceiveFromISR+0x8a>
		}
		else
		{
			xReturn = pdFAIL;
    5f8a:	1a 82       	std	Y+2, r1	; 0x02
			traceQUEUE_RECEIVE_FROM_ISR_FAILED( pxQueue );
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    5f8c:	8a 81       	ldd	r24, Y+2	; 0x02
}
    5f8e:	28 96       	adiw	r28, 0x08	; 8
    5f90:	0f b6       	in	r0, 0x3f	; 63
    5f92:	f8 94       	cli
    5f94:	de bf       	out	0x3e, r29	; 62
    5f96:	0f be       	out	0x3f, r0	; 63
    5f98:	cd bf       	out	0x3d, r28	; 61
    5f9a:	cf 91       	pop	r28
    5f9c:	df 91       	pop	r29
    5f9e:	08 95       	ret

00005fa0 <uxQueueMessagesWaiting>:
/*-----------------------------------------------------------*/

unsigned portBASE_TYPE uxQueueMessagesWaiting( const xQueueHandle pxQueue )
{
    5fa0:	df 93       	push	r29
    5fa2:	cf 93       	push	r28
    5fa4:	00 d0       	rcall	.+0      	; 0x5fa6 <uxQueueMessagesWaiting+0x6>
    5fa6:	0f 92       	push	r0
    5fa8:	cd b7       	in	r28, 0x3d	; 61
    5faa:	de b7       	in	r29, 0x3e	; 62
    5fac:	9b 83       	std	Y+3, r25	; 0x03
    5fae:	8a 83       	std	Y+2, r24	; 0x02
	unsigned portBASE_TYPE uxReturn;

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
    5fb0:	0f b6       	in	r0, 0x3f	; 63
    5fb2:	f8 94       	cli
    5fb4:	0f 92       	push	r0
	uxReturn = pxQueue->uxMessagesWaiting;
    5fb6:	ea 81       	ldd	r30, Y+2	; 0x02
    5fb8:	fb 81       	ldd	r31, Y+3	; 0x03
    5fba:	82 8d       	ldd	r24, Z+26	; 0x1a
    5fbc:	89 83       	std	Y+1, r24	; 0x01
	taskEXIT_CRITICAL();
    5fbe:	0f 90       	pop	r0
    5fc0:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
    5fc2:	89 81       	ldd	r24, Y+1	; 0x01
}
    5fc4:	0f 90       	pop	r0
    5fc6:	0f 90       	pop	r0
    5fc8:	0f 90       	pop	r0
    5fca:	cf 91       	pop	r28
    5fcc:	df 91       	pop	r29
    5fce:	08 95       	ret

00005fd0 <uxQueueMessagesWaitingFromISR>:
/*-----------------------------------------------------------*/

unsigned portBASE_TYPE uxQueueMessagesWaitingFromISR( const xQueueHandle pxQueue )
{
    5fd0:	df 93       	push	r29
    5fd2:	cf 93       	push	r28
    5fd4:	00 d0       	rcall	.+0      	; 0x5fd6 <uxQueueMessagesWaitingFromISR+0x6>
    5fd6:	0f 92       	push	r0
    5fd8:	cd b7       	in	r28, 0x3d	; 61
    5fda:	de b7       	in	r29, 0x3e	; 62
    5fdc:	9b 83       	std	Y+3, r25	; 0x03
    5fde:	8a 83       	std	Y+2, r24	; 0x02
	unsigned portBASE_TYPE uxReturn;

	configASSERT( pxQueue );

	uxReturn = pxQueue->uxMessagesWaiting;
    5fe0:	ea 81       	ldd	r30, Y+2	; 0x02
    5fe2:	fb 81       	ldd	r31, Y+3	; 0x03
    5fe4:	82 8d       	ldd	r24, Z+26	; 0x1a
    5fe6:	89 83       	std	Y+1, r24	; 0x01

	return uxReturn;
    5fe8:	89 81       	ldd	r24, Y+1	; 0x01
}
    5fea:	0f 90       	pop	r0
    5fec:	0f 90       	pop	r0
    5fee:	0f 90       	pop	r0
    5ff0:	cf 91       	pop	r28
    5ff2:	df 91       	pop	r29
    5ff4:	08 95       	ret

00005ff6 <vQueueDelete>:
/*-----------------------------------------------------------*/

void vQueueDelete( xQueueHandle pxQueue )
{
    5ff6:	df 93       	push	r29
    5ff8:	cf 93       	push	r28
    5ffa:	00 d0       	rcall	.+0      	; 0x5ffc <vQueueDelete+0x6>
    5ffc:	cd b7       	in	r28, 0x3d	; 61
    5ffe:	de b7       	in	r29, 0x3e	; 62
    6000:	9a 83       	std	Y+2, r25	; 0x02
    6002:	89 83       	std	Y+1, r24	; 0x01
	configASSERT( pxQueue );

	traceQUEUE_DELETE( pxQueue );
	vQueueUnregisterQueue( pxQueue );
	vPortFree( pxQueue->pcHead );
    6004:	e9 81       	ldd	r30, Y+1	; 0x01
    6006:	fa 81       	ldd	r31, Y+2	; 0x02
    6008:	80 81       	ld	r24, Z
    600a:	91 81       	ldd	r25, Z+1	; 0x01
    600c:	0e 94 db 28 	call	0x51b6	; 0x51b6 <vPortFree>
	vPortFree( pxQueue );
    6010:	89 81       	ldd	r24, Y+1	; 0x01
    6012:	9a 81       	ldd	r25, Y+2	; 0x02
    6014:	0e 94 db 28 	call	0x51b6	; 0x51b6 <vPortFree>
}
    6018:	0f 90       	pop	r0
    601a:	0f 90       	pop	r0
    601c:	cf 91       	pop	r28
    601e:	df 91       	pop	r29
    6020:	08 95       	ret

00006022 <prvCopyDataToQueue>:
/*-----------------------------------------------------------*/

static void prvCopyDataToQueue( xQUEUE *pxQueue, const void *pvItemToQueue, portBASE_TYPE xPosition )
{
    6022:	df 93       	push	r29
    6024:	cf 93       	push	r28
    6026:	00 d0       	rcall	.+0      	; 0x6028 <prvCopyDataToQueue+0x6>
    6028:	00 d0       	rcall	.+0      	; 0x602a <prvCopyDataToQueue+0x8>
    602a:	0f 92       	push	r0
    602c:	cd b7       	in	r28, 0x3d	; 61
    602e:	de b7       	in	r29, 0x3e	; 62
    6030:	9a 83       	std	Y+2, r25	; 0x02
    6032:	89 83       	std	Y+1, r24	; 0x01
    6034:	7c 83       	std	Y+4, r23	; 0x04
    6036:	6b 83       	std	Y+3, r22	; 0x03
    6038:	4d 83       	std	Y+5, r20	; 0x05
	if( pxQueue->uxItemSize == ( unsigned portBASE_TYPE ) 0 )
    603a:	e9 81       	ldd	r30, Y+1	; 0x01
    603c:	fa 81       	ldd	r31, Y+2	; 0x02
    603e:	84 8d       	ldd	r24, Z+28	; 0x1c
    6040:	88 23       	and	r24, r24
    6042:	09 f4       	brne	.+2      	; 0x6046 <prvCopyDataToQueue+0x24>
    6044:	74 c0       	rjmp	.+232    	; 0x612e <prvCopyDataToQueue+0x10c>
				pxQueue->pxMutexHolder = NULL;
			}
		}
#endif
	}
	else if( xPosition == queueSEND_TO_BACK )
    6046:	8d 81       	ldd	r24, Y+5	; 0x05
    6048:	88 23       	and	r24, r24
    604a:	99 f5       	brne	.+102    	; 0x60b2 <prvCopyDataToQueue+0x90>
	{
		memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
    604c:	e9 81       	ldd	r30, Y+1	; 0x01
    604e:	fa 81       	ldd	r31, Y+2	; 0x02
    6050:	64 81       	ldd	r22, Z+4	; 0x04
    6052:	75 81       	ldd	r23, Z+5	; 0x05
    6054:	e9 81       	ldd	r30, Y+1	; 0x01
    6056:	fa 81       	ldd	r31, Y+2	; 0x02
    6058:	84 8d       	ldd	r24, Z+28	; 0x1c
    605a:	48 2f       	mov	r20, r24
    605c:	50 e0       	ldi	r21, 0x00	; 0
    605e:	2b 81       	ldd	r18, Y+3	; 0x03
    6060:	3c 81       	ldd	r19, Y+4	; 0x04
    6062:	cb 01       	movw	r24, r22
    6064:	b9 01       	movw	r22, r18
    6066:	0e 94 ec 3c 	call	0x79d8	; 0x79d8 <memcpy>
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
    606a:	e9 81       	ldd	r30, Y+1	; 0x01
    606c:	fa 81       	ldd	r31, Y+2	; 0x02
    606e:	24 81       	ldd	r18, Z+4	; 0x04
    6070:	35 81       	ldd	r19, Z+5	; 0x05
    6072:	e9 81       	ldd	r30, Y+1	; 0x01
    6074:	fa 81       	ldd	r31, Y+2	; 0x02
    6076:	84 8d       	ldd	r24, Z+28	; 0x1c
    6078:	88 2f       	mov	r24, r24
    607a:	90 e0       	ldi	r25, 0x00	; 0
    607c:	82 0f       	add	r24, r18
    607e:	93 1f       	adc	r25, r19
    6080:	e9 81       	ldd	r30, Y+1	; 0x01
    6082:	fa 81       	ldd	r31, Y+2	; 0x02
    6084:	95 83       	std	Z+5, r25	; 0x05
    6086:	84 83       	std	Z+4, r24	; 0x04
		if( pxQueue->pcWriteTo >= pxQueue->pcTail )
    6088:	e9 81       	ldd	r30, Y+1	; 0x01
    608a:	fa 81       	ldd	r31, Y+2	; 0x02
    608c:	24 81       	ldd	r18, Z+4	; 0x04
    608e:	35 81       	ldd	r19, Z+5	; 0x05
    6090:	e9 81       	ldd	r30, Y+1	; 0x01
    6092:	fa 81       	ldd	r31, Y+2	; 0x02
    6094:	82 81       	ldd	r24, Z+2	; 0x02
    6096:	93 81       	ldd	r25, Z+3	; 0x03
    6098:	28 17       	cp	r18, r24
    609a:	39 07       	cpc	r19, r25
    609c:	08 f4       	brcc	.+2      	; 0x60a0 <prvCopyDataToQueue+0x7e>
    609e:	47 c0       	rjmp	.+142    	; 0x612e <prvCopyDataToQueue+0x10c>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
    60a0:	e9 81       	ldd	r30, Y+1	; 0x01
    60a2:	fa 81       	ldd	r31, Y+2	; 0x02
    60a4:	80 81       	ld	r24, Z
    60a6:	91 81       	ldd	r25, Z+1	; 0x01
    60a8:	e9 81       	ldd	r30, Y+1	; 0x01
    60aa:	fa 81       	ldd	r31, Y+2	; 0x02
    60ac:	95 83       	std	Z+5, r25	; 0x05
    60ae:	84 83       	std	Z+4, r24	; 0x04
    60b0:	3e c0       	rjmp	.+124    	; 0x612e <prvCopyDataToQueue+0x10c>
		}
	}
	else
	{
		memcpy( ( void * ) pxQueue->pcReadFrom, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
    60b2:	e9 81       	ldd	r30, Y+1	; 0x01
    60b4:	fa 81       	ldd	r31, Y+2	; 0x02
    60b6:	66 81       	ldd	r22, Z+6	; 0x06
    60b8:	77 81       	ldd	r23, Z+7	; 0x07
    60ba:	e9 81       	ldd	r30, Y+1	; 0x01
    60bc:	fa 81       	ldd	r31, Y+2	; 0x02
    60be:	84 8d       	ldd	r24, Z+28	; 0x1c
    60c0:	48 2f       	mov	r20, r24
    60c2:	50 e0       	ldi	r21, 0x00	; 0
    60c4:	2b 81       	ldd	r18, Y+3	; 0x03
    60c6:	3c 81       	ldd	r19, Y+4	; 0x04
    60c8:	cb 01       	movw	r24, r22
    60ca:	b9 01       	movw	r22, r18
    60cc:	0e 94 ec 3c 	call	0x79d8	; 0x79d8 <memcpy>
		pxQueue->pcReadFrom -= pxQueue->uxItemSize;
    60d0:	e9 81       	ldd	r30, Y+1	; 0x01
    60d2:	fa 81       	ldd	r31, Y+2	; 0x02
    60d4:	26 81       	ldd	r18, Z+6	; 0x06
    60d6:	37 81       	ldd	r19, Z+7	; 0x07
    60d8:	e9 81       	ldd	r30, Y+1	; 0x01
    60da:	fa 81       	ldd	r31, Y+2	; 0x02
    60dc:	84 8d       	ldd	r24, Z+28	; 0x1c
    60de:	88 2f       	mov	r24, r24
    60e0:	90 e0       	ldi	r25, 0x00	; 0
    60e2:	90 95       	com	r25
    60e4:	81 95       	neg	r24
    60e6:	9f 4f       	sbci	r25, 0xFF	; 255
    60e8:	82 0f       	add	r24, r18
    60ea:	93 1f       	adc	r25, r19
    60ec:	e9 81       	ldd	r30, Y+1	; 0x01
    60ee:	fa 81       	ldd	r31, Y+2	; 0x02
    60f0:	97 83       	std	Z+7, r25	; 0x07
    60f2:	86 83       	std	Z+6, r24	; 0x06
		if( pxQueue->pcReadFrom < pxQueue->pcHead )
    60f4:	e9 81       	ldd	r30, Y+1	; 0x01
    60f6:	fa 81       	ldd	r31, Y+2	; 0x02
    60f8:	26 81       	ldd	r18, Z+6	; 0x06
    60fa:	37 81       	ldd	r19, Z+7	; 0x07
    60fc:	e9 81       	ldd	r30, Y+1	; 0x01
    60fe:	fa 81       	ldd	r31, Y+2	; 0x02
    6100:	80 81       	ld	r24, Z
    6102:	91 81       	ldd	r25, Z+1	; 0x01
    6104:	28 17       	cp	r18, r24
    6106:	39 07       	cpc	r19, r25
    6108:	90 f4       	brcc	.+36     	; 0x612e <prvCopyDataToQueue+0x10c>
		{
			pxQueue->pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
    610a:	e9 81       	ldd	r30, Y+1	; 0x01
    610c:	fa 81       	ldd	r31, Y+2	; 0x02
    610e:	22 81       	ldd	r18, Z+2	; 0x02
    6110:	33 81       	ldd	r19, Z+3	; 0x03
    6112:	e9 81       	ldd	r30, Y+1	; 0x01
    6114:	fa 81       	ldd	r31, Y+2	; 0x02
    6116:	84 8d       	ldd	r24, Z+28	; 0x1c
    6118:	88 2f       	mov	r24, r24
    611a:	90 e0       	ldi	r25, 0x00	; 0
    611c:	90 95       	com	r25
    611e:	81 95       	neg	r24
    6120:	9f 4f       	sbci	r25, 0xFF	; 255
    6122:	82 0f       	add	r24, r18
    6124:	93 1f       	adc	r25, r19
    6126:	e9 81       	ldd	r30, Y+1	; 0x01
    6128:	fa 81       	ldd	r31, Y+2	; 0x02
    612a:	97 83       	std	Z+7, r25	; 0x07
    612c:	86 83       	std	Z+6, r24	; 0x06
		}
	}

	++( pxQueue->uxMessagesWaiting );
    612e:	e9 81       	ldd	r30, Y+1	; 0x01
    6130:	fa 81       	ldd	r31, Y+2	; 0x02
    6132:	82 8d       	ldd	r24, Z+26	; 0x1a
    6134:	8f 5f       	subi	r24, 0xFF	; 255
    6136:	e9 81       	ldd	r30, Y+1	; 0x01
    6138:	fa 81       	ldd	r31, Y+2	; 0x02
    613a:	82 8f       	std	Z+26, r24	; 0x1a
}
    613c:	0f 90       	pop	r0
    613e:	0f 90       	pop	r0
    6140:	0f 90       	pop	r0
    6142:	0f 90       	pop	r0
    6144:	0f 90       	pop	r0
    6146:	cf 91       	pop	r28
    6148:	df 91       	pop	r29
    614a:	08 95       	ret

0000614c <prvCopyDataFromQueue>:
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( xQUEUE * const pxQueue, const void *pvBuffer )
{
    614c:	df 93       	push	r29
    614e:	cf 93       	push	r28
    6150:	00 d0       	rcall	.+0      	; 0x6152 <prvCopyDataFromQueue+0x6>
    6152:	00 d0       	rcall	.+0      	; 0x6154 <prvCopyDataFromQueue+0x8>
    6154:	cd b7       	in	r28, 0x3d	; 61
    6156:	de b7       	in	r29, 0x3e	; 62
    6158:	9a 83       	std	Y+2, r25	; 0x02
    615a:	89 83       	std	Y+1, r24	; 0x01
    615c:	7c 83       	std	Y+4, r23	; 0x04
    615e:	6b 83       	std	Y+3, r22	; 0x03
	if( pxQueue->uxQueueType != queueQUEUE_IS_MUTEX )
    6160:	e9 81       	ldd	r30, Y+1	; 0x01
    6162:	fa 81       	ldd	r31, Y+2	; 0x02
    6164:	80 81       	ld	r24, Z
    6166:	91 81       	ldd	r25, Z+1	; 0x01
    6168:	00 97       	sbiw	r24, 0x00	; 0
    616a:	89 f1       	breq	.+98     	; 0x61ce <prvCopyDataFromQueue+0x82>
	{
		pxQueue->pcReadFrom += pxQueue->uxItemSize;
    616c:	e9 81       	ldd	r30, Y+1	; 0x01
    616e:	fa 81       	ldd	r31, Y+2	; 0x02
    6170:	26 81       	ldd	r18, Z+6	; 0x06
    6172:	37 81       	ldd	r19, Z+7	; 0x07
    6174:	e9 81       	ldd	r30, Y+1	; 0x01
    6176:	fa 81       	ldd	r31, Y+2	; 0x02
    6178:	84 8d       	ldd	r24, Z+28	; 0x1c
    617a:	88 2f       	mov	r24, r24
    617c:	90 e0       	ldi	r25, 0x00	; 0
    617e:	82 0f       	add	r24, r18
    6180:	93 1f       	adc	r25, r19
    6182:	e9 81       	ldd	r30, Y+1	; 0x01
    6184:	fa 81       	ldd	r31, Y+2	; 0x02
    6186:	97 83       	std	Z+7, r25	; 0x07
    6188:	86 83       	std	Z+6, r24	; 0x06
		if( pxQueue->pcReadFrom >= pxQueue->pcTail )
    618a:	e9 81       	ldd	r30, Y+1	; 0x01
    618c:	fa 81       	ldd	r31, Y+2	; 0x02
    618e:	26 81       	ldd	r18, Z+6	; 0x06
    6190:	37 81       	ldd	r19, Z+7	; 0x07
    6192:	e9 81       	ldd	r30, Y+1	; 0x01
    6194:	fa 81       	ldd	r31, Y+2	; 0x02
    6196:	82 81       	ldd	r24, Z+2	; 0x02
    6198:	93 81       	ldd	r25, Z+3	; 0x03
    619a:	28 17       	cp	r18, r24
    619c:	39 07       	cpc	r19, r25
    619e:	40 f0       	brcs	.+16     	; 0x61b0 <prvCopyDataFromQueue+0x64>
		{
			pxQueue->pcReadFrom = pxQueue->pcHead;
    61a0:	e9 81       	ldd	r30, Y+1	; 0x01
    61a2:	fa 81       	ldd	r31, Y+2	; 0x02
    61a4:	80 81       	ld	r24, Z
    61a6:	91 81       	ldd	r25, Z+1	; 0x01
    61a8:	e9 81       	ldd	r30, Y+1	; 0x01
    61aa:	fa 81       	ldd	r31, Y+2	; 0x02
    61ac:	97 83       	std	Z+7, r25	; 0x07
    61ae:	86 83       	std	Z+6, r24	; 0x06
		}
		memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
    61b0:	e9 81       	ldd	r30, Y+1	; 0x01
    61b2:	fa 81       	ldd	r31, Y+2	; 0x02
    61b4:	46 81       	ldd	r20, Z+6	; 0x06
    61b6:	57 81       	ldd	r21, Z+7	; 0x07
    61b8:	e9 81       	ldd	r30, Y+1	; 0x01
    61ba:	fa 81       	ldd	r31, Y+2	; 0x02
    61bc:	84 8d       	ldd	r24, Z+28	; 0x1c
    61be:	28 2f       	mov	r18, r24
    61c0:	30 e0       	ldi	r19, 0x00	; 0
    61c2:	8b 81       	ldd	r24, Y+3	; 0x03
    61c4:	9c 81       	ldd	r25, Y+4	; 0x04
    61c6:	ba 01       	movw	r22, r20
    61c8:	a9 01       	movw	r20, r18
    61ca:	0e 94 ec 3c 	call	0x79d8	; 0x79d8 <memcpy>
	}
}
    61ce:	0f 90       	pop	r0
    61d0:	0f 90       	pop	r0
    61d2:	0f 90       	pop	r0
    61d4:	0f 90       	pop	r0
    61d6:	cf 91       	pop	r28
    61d8:	df 91       	pop	r29
    61da:	08 95       	ret

000061dc <prvUnlockQueue>:
/*-----------------------------------------------------------*/

static void prvUnlockQueue( xQueueHandle pxQueue )
{
    61dc:	df 93       	push	r29
    61de:	cf 93       	push	r28
    61e0:	00 d0       	rcall	.+0      	; 0x61e2 <prvUnlockQueue+0x6>
    61e2:	cd b7       	in	r28, 0x3d	; 61
    61e4:	de b7       	in	r29, 0x3e	; 62
    61e6:	9a 83       	std	Y+2, r25	; 0x02
    61e8:	89 83       	std	Y+1, r24	; 0x01

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
    61ea:	0f b6       	in	r0, 0x3f	; 63
    61ec:	f8 94       	cli
    61ee:	0f 92       	push	r0
    61f0:	15 c0       	rjmp	.+42     	; 0x621c <prvUnlockQueue+0x40>
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
		{
			/* Data was posted while the queue was locked.  Are any tasks
			blocked waiting for data to become available? */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    61f2:	e9 81       	ldd	r30, Y+1	; 0x01
    61f4:	fa 81       	ldd	r31, Y+2	; 0x02
    61f6:	81 89       	ldd	r24, Z+17	; 0x11
    61f8:	88 23       	and	r24, r24
    61fa:	a9 f0       	breq	.+42     	; 0x6226 <prvUnlockQueue+0x4a>
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    61fc:	89 81       	ldd	r24, Y+1	; 0x01
    61fe:	9a 81       	ldd	r25, Y+2	; 0x02
    6200:	41 96       	adiw	r24, 0x11	; 17
    6202:	0e 94 26 36 	call	0x6c4c	; 0x6c4c <xTaskRemoveFromEventList>
    6206:	88 23       	and	r24, r24
    6208:	11 f0       	breq	.+4      	; 0x620e <prvUnlockQueue+0x32>
				{
					/* The task waiting has a higher priority so record that a
					context	switch is required. */
					vTaskMissedYield();
    620a:	0e 94 04 37 	call	0x6e08	; 0x6e08 <vTaskMissedYield>
				}

				--( pxQueue->xTxLock );
    620e:	e9 81       	ldd	r30, Y+1	; 0x01
    6210:	fa 81       	ldd	r31, Y+2	; 0x02
    6212:	86 8d       	ldd	r24, Z+30	; 0x1e
    6214:	81 50       	subi	r24, 0x01	; 1
    6216:	e9 81       	ldd	r30, Y+1	; 0x01
    6218:	fa 81       	ldd	r31, Y+2	; 0x02
    621a:	86 8f       	std	Z+30, r24	; 0x1e
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
    621c:	e9 81       	ldd	r30, Y+1	; 0x01
    621e:	fa 81       	ldd	r31, Y+2	; 0x02
    6220:	86 8d       	ldd	r24, Z+30	; 0x1e
    6222:	18 16       	cp	r1, r24
    6224:	34 f3       	brlt	.-52     	; 0x61f2 <prvUnlockQueue+0x16>
			{
				break;
			}
		}

		pxQueue->xTxLock = queueUNLOCKED;
    6226:	e9 81       	ldd	r30, Y+1	; 0x01
    6228:	fa 81       	ldd	r31, Y+2	; 0x02
    622a:	8f ef       	ldi	r24, 0xFF	; 255
    622c:	86 8f       	std	Z+30, r24	; 0x1e
	}
	taskEXIT_CRITICAL();
    622e:	0f 90       	pop	r0
    6230:	0f be       	out	0x3f, r0	; 63

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
    6232:	0f b6       	in	r0, 0x3f	; 63
    6234:	f8 94       	cli
    6236:	0f 92       	push	r0
    6238:	15 c0       	rjmp	.+42     	; 0x6264 <prvUnlockQueue+0x88>
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    623a:	e9 81       	ldd	r30, Y+1	; 0x01
    623c:	fa 81       	ldd	r31, Y+2	; 0x02
    623e:	80 85       	ldd	r24, Z+8	; 0x08
    6240:	88 23       	and	r24, r24
    6242:	a9 f0       	breq	.+42     	; 0x626e <prvUnlockQueue+0x92>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    6244:	89 81       	ldd	r24, Y+1	; 0x01
    6246:	9a 81       	ldd	r25, Y+2	; 0x02
    6248:	08 96       	adiw	r24, 0x08	; 8
    624a:	0e 94 26 36 	call	0x6c4c	; 0x6c4c <xTaskRemoveFromEventList>
    624e:	88 23       	and	r24, r24
    6250:	11 f0       	breq	.+4      	; 0x6256 <prvUnlockQueue+0x7a>
				{
					vTaskMissedYield();
    6252:	0e 94 04 37 	call	0x6e08	; 0x6e08 <vTaskMissedYield>
				}

				--( pxQueue->xRxLock );
    6256:	e9 81       	ldd	r30, Y+1	; 0x01
    6258:	fa 81       	ldd	r31, Y+2	; 0x02
    625a:	85 8d       	ldd	r24, Z+29	; 0x1d
    625c:	81 50       	subi	r24, 0x01	; 1
    625e:	e9 81       	ldd	r30, Y+1	; 0x01
    6260:	fa 81       	ldd	r31, Y+2	; 0x02
    6262:	85 8f       	std	Z+29, r24	; 0x1d
	taskEXIT_CRITICAL();

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
    6264:	e9 81       	ldd	r30, Y+1	; 0x01
    6266:	fa 81       	ldd	r31, Y+2	; 0x02
    6268:	85 8d       	ldd	r24, Z+29	; 0x1d
    626a:	18 16       	cp	r1, r24
    626c:	34 f3       	brlt	.-52     	; 0x623a <prvUnlockQueue+0x5e>
			{
				break;
			}
		}

		pxQueue->xRxLock = queueUNLOCKED;
    626e:	e9 81       	ldd	r30, Y+1	; 0x01
    6270:	fa 81       	ldd	r31, Y+2	; 0x02
    6272:	8f ef       	ldi	r24, 0xFF	; 255
    6274:	85 8f       	std	Z+29, r24	; 0x1d
	}
	taskEXIT_CRITICAL();
    6276:	0f 90       	pop	r0
    6278:	0f be       	out	0x3f, r0	; 63
}
    627a:	0f 90       	pop	r0
    627c:	0f 90       	pop	r0
    627e:	cf 91       	pop	r28
    6280:	df 91       	pop	r29
    6282:	08 95       	ret

00006284 <prvIsQueueEmpty>:
/*-----------------------------------------------------------*/

static signed portBASE_TYPE prvIsQueueEmpty( const xQueueHandle pxQueue )
{
    6284:	df 93       	push	r29
    6286:	cf 93       	push	r28
    6288:	00 d0       	rcall	.+0      	; 0x628a <prvIsQueueEmpty+0x6>
    628a:	0f 92       	push	r0
    628c:	cd b7       	in	r28, 0x3d	; 61
    628e:	de b7       	in	r29, 0x3e	; 62
    6290:	9b 83       	std	Y+3, r25	; 0x03
    6292:	8a 83       	std	Y+2, r24	; 0x02
	signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
    6294:	0f b6       	in	r0, 0x3f	; 63
    6296:	f8 94       	cli
    6298:	0f 92       	push	r0
	xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
    629a:	ea 81       	ldd	r30, Y+2	; 0x02
    629c:	fb 81       	ldd	r31, Y+3	; 0x03
    629e:	82 8d       	ldd	r24, Z+26	; 0x1a
    62a0:	19 82       	std	Y+1, r1	; 0x01
    62a2:	88 23       	and	r24, r24
    62a4:	11 f4       	brne	.+4      	; 0x62aa <prvIsQueueEmpty+0x26>
    62a6:	81 e0       	ldi	r24, 0x01	; 1
    62a8:	89 83       	std	Y+1, r24	; 0x01
	taskEXIT_CRITICAL();
    62aa:	0f 90       	pop	r0
    62ac:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    62ae:	89 81       	ldd	r24, Y+1	; 0x01
}
    62b0:	0f 90       	pop	r0
    62b2:	0f 90       	pop	r0
    62b4:	0f 90       	pop	r0
    62b6:	cf 91       	pop	r28
    62b8:	df 91       	pop	r29
    62ba:	08 95       	ret

000062bc <xQueueIsQueueEmptyFromISR>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueIsQueueEmptyFromISR( const xQueueHandle pxQueue )
{
    62bc:	df 93       	push	r29
    62be:	cf 93       	push	r28
    62c0:	00 d0       	rcall	.+0      	; 0x62c2 <xQueueIsQueueEmptyFromISR+0x6>
    62c2:	0f 92       	push	r0
    62c4:	cd b7       	in	r28, 0x3d	; 61
    62c6:	de b7       	in	r29, 0x3e	; 62
    62c8:	9b 83       	std	Y+3, r25	; 0x03
    62ca:	8a 83       	std	Y+2, r24	; 0x02
	signed portBASE_TYPE xReturn;

	configASSERT( pxQueue );
	xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
    62cc:	ea 81       	ldd	r30, Y+2	; 0x02
    62ce:	fb 81       	ldd	r31, Y+3	; 0x03
    62d0:	82 8d       	ldd	r24, Z+26	; 0x1a
    62d2:	19 82       	std	Y+1, r1	; 0x01
    62d4:	88 23       	and	r24, r24
    62d6:	11 f4       	brne	.+4      	; 0x62dc <xQueueIsQueueEmptyFromISR+0x20>
    62d8:	81 e0       	ldi	r24, 0x01	; 1
    62da:	89 83       	std	Y+1, r24	; 0x01

	return xReturn;
    62dc:	89 81       	ldd	r24, Y+1	; 0x01
}
    62de:	0f 90       	pop	r0
    62e0:	0f 90       	pop	r0
    62e2:	0f 90       	pop	r0
    62e4:	cf 91       	pop	r28
    62e6:	df 91       	pop	r29
    62e8:	08 95       	ret

000062ea <prvIsQueueFull>:
/*-----------------------------------------------------------*/

static signed portBASE_TYPE prvIsQueueFull( const xQueueHandle pxQueue )
{
    62ea:	df 93       	push	r29
    62ec:	cf 93       	push	r28
    62ee:	00 d0       	rcall	.+0      	; 0x62f0 <prvIsQueueFull+0x6>
    62f0:	0f 92       	push	r0
    62f2:	cd b7       	in	r28, 0x3d	; 61
    62f4:	de b7       	in	r29, 0x3e	; 62
    62f6:	9b 83       	std	Y+3, r25	; 0x03
    62f8:	8a 83       	std	Y+2, r24	; 0x02
	signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
    62fa:	0f b6       	in	r0, 0x3f	; 63
    62fc:	f8 94       	cli
    62fe:	0f 92       	push	r0
	xReturn = ( pxQueue->uxMessagesWaiting == pxQueue->uxLength );
    6300:	ea 81       	ldd	r30, Y+2	; 0x02
    6302:	fb 81       	ldd	r31, Y+3	; 0x03
    6304:	92 8d       	ldd	r25, Z+26	; 0x1a
    6306:	ea 81       	ldd	r30, Y+2	; 0x02
    6308:	fb 81       	ldd	r31, Y+3	; 0x03
    630a:	83 8d       	ldd	r24, Z+27	; 0x1b
    630c:	19 82       	std	Y+1, r1	; 0x01
    630e:	98 17       	cp	r25, r24
    6310:	11 f4       	brne	.+4      	; 0x6316 <prvIsQueueFull+0x2c>
    6312:	81 e0       	ldi	r24, 0x01	; 1
    6314:	89 83       	std	Y+1, r24	; 0x01
	taskEXIT_CRITICAL();
    6316:	0f 90       	pop	r0
    6318:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    631a:	89 81       	ldd	r24, Y+1	; 0x01
}
    631c:	0f 90       	pop	r0
    631e:	0f 90       	pop	r0
    6320:	0f 90       	pop	r0
    6322:	cf 91       	pop	r28
    6324:	df 91       	pop	r29
    6326:	08 95       	ret

00006328 <xQueueIsQueueFullFromISR>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueIsQueueFullFromISR( const xQueueHandle pxQueue )
{
    6328:	df 93       	push	r29
    632a:	cf 93       	push	r28
    632c:	00 d0       	rcall	.+0      	; 0x632e <xQueueIsQueueFullFromISR+0x6>
    632e:	0f 92       	push	r0
    6330:	cd b7       	in	r28, 0x3d	; 61
    6332:	de b7       	in	r29, 0x3e	; 62
    6334:	9b 83       	std	Y+3, r25	; 0x03
    6336:	8a 83       	std	Y+2, r24	; 0x02
	signed portBASE_TYPE xReturn;

	configASSERT( pxQueue );
	xReturn = ( pxQueue->uxMessagesWaiting == pxQueue->uxLength );
    6338:	ea 81       	ldd	r30, Y+2	; 0x02
    633a:	fb 81       	ldd	r31, Y+3	; 0x03
    633c:	92 8d       	ldd	r25, Z+26	; 0x1a
    633e:	ea 81       	ldd	r30, Y+2	; 0x02
    6340:	fb 81       	ldd	r31, Y+3	; 0x03
    6342:	83 8d       	ldd	r24, Z+27	; 0x1b
    6344:	19 82       	std	Y+1, r1	; 0x01
    6346:	98 17       	cp	r25, r24
    6348:	11 f4       	brne	.+4      	; 0x634e <xQueueIsQueueFullFromISR+0x26>
    634a:	81 e0       	ldi	r24, 0x01	; 1
    634c:	89 83       	std	Y+1, r24	; 0x01

	return xReturn;
    634e:	89 81       	ldd	r24, Y+1	; 0x01
}
    6350:	0f 90       	pop	r0
    6352:	0f 90       	pop	r0
    6354:	0f 90       	pop	r0
    6356:	cf 91       	pop	r28
    6358:	df 91       	pop	r29
    635a:	08 95       	ret

0000635c <xTaskGenericCreate>:
/*-----------------------------------------------------------
 * TASK CREATION API documented in task.h
 *----------------------------------------------------------*/

signed portBASE_TYPE xTaskGenericCreate( pdTASK_CODE pxTaskCode, const signed char * const pcName, unsigned short usStackDepth, void *pvParameters, unsigned portBASE_TYPE uxPriority, xTaskHandle *pxCreatedTask, portSTACK_TYPE *puxStackBuffer, const xMemoryRegion * const xRegions )
{
    635c:	af 92       	push	r10
    635e:	bf 92       	push	r11
    6360:	cf 92       	push	r12
    6362:	df 92       	push	r13
    6364:	ef 92       	push	r14
    6366:	ff 92       	push	r15
    6368:	0f 93       	push	r16
    636a:	1f 93       	push	r17
    636c:	df 93       	push	r29
    636e:	cf 93       	push	r28
    6370:	cd b7       	in	r28, 0x3d	; 61
    6372:	de b7       	in	r29, 0x3e	; 62
    6374:	64 97       	sbiw	r28, 0x14	; 20
    6376:	0f b6       	in	r0, 0x3f	; 63
    6378:	f8 94       	cli
    637a:	de bf       	out	0x3e, r29	; 62
    637c:	0f be       	out	0x3f, r0	; 63
    637e:	cd bf       	out	0x3d, r28	; 61
    6380:	9f 83       	std	Y+7, r25	; 0x07
    6382:	8e 83       	std	Y+6, r24	; 0x06
    6384:	79 87       	std	Y+9, r23	; 0x09
    6386:	68 87       	std	Y+8, r22	; 0x08
    6388:	5b 87       	std	Y+11, r21	; 0x0b
    638a:	4a 87       	std	Y+10, r20	; 0x0a
    638c:	3d 87       	std	Y+13, r19	; 0x0d
    638e:	2c 87       	std	Y+12, r18	; 0x0c
    6390:	0e 87       	std	Y+14, r16	; 0x0e
    6392:	f8 8a       	std	Y+16, r15	; 0x10
    6394:	ef 86       	std	Y+15, r14	; 0x0f
    6396:	da 8a       	std	Y+18, r13	; 0x12
    6398:	c9 8a       	std	Y+17, r12	; 0x11
    639a:	bc 8a       	std	Y+20, r11	; 0x14
    639c:	ab 8a       	std	Y+19, r10	; 0x13
	configASSERT( pxTaskCode );
	configASSERT( ( uxPriority < configMAX_PRIORITIES ) );

	/* Allocate the memory required by the TCB and stack for the new task,
	checking that the allocation was successful. */
	pxNewTCB = prvAllocateTCBAndStack( usStackDepth, puxStackBuffer );
    639e:	8a 85       	ldd	r24, Y+10	; 0x0a
    63a0:	9b 85       	ldd	r25, Y+11	; 0x0b
    63a2:	29 89       	ldd	r18, Y+17	; 0x11
    63a4:	3a 89       	ldd	r19, Y+18	; 0x12
    63a6:	b9 01       	movw	r22, r18
    63a8:	0e 94 33 38 	call	0x7066	; 0x7066 <prvAllocateTCBAndStack>
    63ac:	9c 83       	std	Y+4, r25	; 0x04
    63ae:	8b 83       	std	Y+3, r24	; 0x03

	if( pxNewTCB != NULL )
    63b0:	8b 81       	ldd	r24, Y+3	; 0x03
    63b2:	9c 81       	ldd	r25, Y+4	; 0x04
    63b4:	00 97       	sbiw	r24, 0x00	; 0
    63b6:	09 f4       	brne	.+2      	; 0x63ba <xTaskGenericCreate+0x5e>
    63b8:	99 c0       	rjmp	.+306    	; 0x64ec <xTaskGenericCreate+0x190>
		stack grows from high memory to low (as per the 80x86) or visa versa.
		portSTACK_GROWTH is used to make the result positive or negative as
		required by the port. */
		#if( portSTACK_GROWTH < 0 )
		{
			pxTopOfStack = pxNewTCB->pxStack + ( usStackDepth - ( unsigned short ) 1 );
    63ba:	eb 81       	ldd	r30, Y+3	; 0x03
    63bc:	fc 81       	ldd	r31, Y+4	; 0x04
    63be:	27 89       	ldd	r18, Z+23	; 0x17
    63c0:	30 8d       	ldd	r19, Z+24	; 0x18
    63c2:	8a 85       	ldd	r24, Y+10	; 0x0a
    63c4:	9b 85       	ldd	r25, Y+11	; 0x0b
    63c6:	01 97       	sbiw	r24, 0x01	; 1
    63c8:	82 0f       	add	r24, r18
    63ca:	93 1f       	adc	r25, r19
    63cc:	9a 83       	std	Y+2, r25	; 0x02
    63ce:	89 83       	std	Y+1, r24	; 0x01
			pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( usStackDepth - 1 );
		}
		#endif

		/* Setup the newly allocated TCB with the initial state of the task. */
		prvInitialiseTCBVariables( pxNewTCB, pcName, uxPriority, xRegions, usStackDepth );
    63d0:	8b 81       	ldd	r24, Y+3	; 0x03
    63d2:	9c 81       	ldd	r25, Y+4	; 0x04
    63d4:	28 85       	ldd	r18, Y+8	; 0x08
    63d6:	39 85       	ldd	r19, Y+9	; 0x09
    63d8:	eb 89       	ldd	r30, Y+19	; 0x13
    63da:	fc 89       	ldd	r31, Y+20	; 0x14
    63dc:	aa 85       	ldd	r26, Y+10	; 0x0a
    63de:	bb 85       	ldd	r27, Y+11	; 0x0b
    63e0:	b9 01       	movw	r22, r18
    63e2:	4e 85       	ldd	r20, Y+14	; 0x0e
    63e4:	9f 01       	movw	r18, r30
    63e6:	8d 01       	movw	r16, r26
    63e8:	0e 94 18 37 	call	0x6e30	; 0x6e30 <prvInitialiseTCBVariables>
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
		}
		#else
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
    63ec:	89 81       	ldd	r24, Y+1	; 0x01
    63ee:	9a 81       	ldd	r25, Y+2	; 0x02
    63f0:	2e 81       	ldd	r18, Y+6	; 0x06
    63f2:	3f 81       	ldd	r19, Y+7	; 0x07
    63f4:	4c 85       	ldd	r20, Y+12	; 0x0c
    63f6:	5d 85       	ldd	r21, Y+13	; 0x0d
    63f8:	b9 01       	movw	r22, r18
    63fa:	0e 94 3c 2a 	call	0x5478	; 0x5478 <pxPortInitialiseStack>
    63fe:	eb 81       	ldd	r30, Y+3	; 0x03
    6400:	fc 81       	ldd	r31, Y+4	; 0x04
    6402:	91 83       	std	Z+1, r25	; 0x01
    6404:	80 83       	st	Z, r24
		#endif

		/* Check the alignment of the initialised stack. */
		configASSERT( ( ( ( unsigned long ) pxNewTCB->pxTopOfStack & ( unsigned long ) portBYTE_ALIGNMENT_MASK ) == 0UL ) );

		if( ( void * ) pxCreatedTask != NULL )
    6406:	8f 85       	ldd	r24, Y+15	; 0x0f
    6408:	98 89       	ldd	r25, Y+16	; 0x10
    640a:	00 97       	sbiw	r24, 0x00	; 0
    640c:	31 f0       	breq	.+12     	; 0x641a <xTaskGenericCreate+0xbe>
		{
			/* Pass the TCB out - in an anonymous way.  The calling function/
			task can use this as a handle to delete the task later if
			required.*/
			*pxCreatedTask = ( xTaskHandle ) pxNewTCB;
    640e:	ef 85       	ldd	r30, Y+15	; 0x0f
    6410:	f8 89       	ldd	r31, Y+16	; 0x10
    6412:	8b 81       	ldd	r24, Y+3	; 0x03
    6414:	9c 81       	ldd	r25, Y+4	; 0x04
    6416:	91 83       	std	Z+1, r25	; 0x01
    6418:	80 83       	st	Z, r24
		}
		
		/* We are going to manipulate the task queues to add this task to a
		ready list, so must make sure no interrupts occur. */
		taskENTER_CRITICAL();
    641a:	0f b6       	in	r0, 0x3f	; 63
    641c:	f8 94       	cli
    641e:	0f 92       	push	r0
		{
			uxCurrentNumberOfTasks++;
    6420:	80 91 5e 05 	lds	r24, 0x055E
    6424:	8f 5f       	subi	r24, 0xFF	; 255
    6426:	80 93 5e 05 	sts	0x055E, r24
			if( pxCurrentTCB == NULL )
    642a:	80 91 5b 05 	lds	r24, 0x055B
    642e:	90 91 5c 05 	lds	r25, 0x055C
    6432:	00 97       	sbiw	r24, 0x00	; 0
    6434:	69 f4       	brne	.+26     	; 0x6450 <xTaskGenericCreate+0xf4>
			{
				/* There are no other tasks, or all the other tasks are in
				the suspended state - make this the current task. */
				pxCurrentTCB =  pxNewTCB;
    6436:	8b 81       	ldd	r24, Y+3	; 0x03
    6438:	9c 81       	ldd	r25, Y+4	; 0x04
    643a:	90 93 5c 05 	sts	0x055C, r25
    643e:	80 93 5b 05 	sts	0x055B, r24

				if( uxCurrentNumberOfTasks == ( unsigned portBASE_TYPE ) 1 )
    6442:	80 91 5e 05 	lds	r24, 0x055E
    6446:	81 30       	cpi	r24, 0x01	; 1
    6448:	a9 f4       	brne	.+42     	; 0x6474 <xTaskGenericCreate+0x118>
				{
					/* This is the first task to be created so do the preliminary
					initialisation required.  We will not recover if this call
					fails, but we will report the failure. */
					prvInitialiseTaskLists();
    644a:	0e 94 6f 37 	call	0x6ede	; 0x6ede <prvInitialiseTaskLists>
    644e:	12 c0       	rjmp	.+36     	; 0x6474 <xTaskGenericCreate+0x118>
			else
			{
				/* If the scheduler is not already running, make this task the
				current task if it is the highest priority task to be created
				so far. */
				if( xSchedulerRunning == pdFALSE )
    6450:	80 91 63 05 	lds	r24, 0x0563
    6454:	88 23       	and	r24, r24
    6456:	71 f4       	brne	.+28     	; 0x6474 <xTaskGenericCreate+0x118>
				{
					if( pxCurrentTCB->uxPriority <= uxPriority )
    6458:	e0 91 5b 05 	lds	r30, 0x055B
    645c:	f0 91 5c 05 	lds	r31, 0x055C
    6460:	96 89       	ldd	r25, Z+22	; 0x16
    6462:	8e 85       	ldd	r24, Y+14	; 0x0e
    6464:	89 17       	cp	r24, r25
    6466:	30 f0       	brcs	.+12     	; 0x6474 <xTaskGenericCreate+0x118>
					{
						pxCurrentTCB = pxNewTCB;
    6468:	8b 81       	ldd	r24, Y+3	; 0x03
    646a:	9c 81       	ldd	r25, Y+4	; 0x04
    646c:	90 93 5c 05 	sts	0x055C, r25
    6470:	80 93 5b 05 	sts	0x055B, r24
				}
			}

			/* Remember the top priority to make context switching faster.  Use
			the priority in pxNewTCB as this has been capped to a valid value. */
			if( pxNewTCB->uxPriority > uxTopUsedPriority )
    6474:	eb 81       	ldd	r30, Y+3	; 0x03
    6476:	fc 81       	ldd	r31, Y+4	; 0x04
    6478:	96 89       	ldd	r25, Z+22	; 0x16
    647a:	80 91 61 05 	lds	r24, 0x0561
    647e:	89 17       	cp	r24, r25
    6480:	28 f4       	brcc	.+10     	; 0x648c <xTaskGenericCreate+0x130>
			{
				uxTopUsedPriority = pxNewTCB->uxPriority;
    6482:	eb 81       	ldd	r30, Y+3	; 0x03
    6484:	fc 81       	ldd	r31, Y+4	; 0x04
    6486:	86 89       	ldd	r24, Z+22	; 0x16
    6488:	80 93 61 05 	sts	0x0561, r24
			{
				/* Add a counter into the TCB for tracing only. */
				pxNewTCB->uxTCBNumber = uxTaskNumber;
			}
			#endif
			uxTaskNumber++;
    648c:	80 91 68 05 	lds	r24, 0x0568
    6490:	8f 5f       	subi	r24, 0xFF	; 255
    6492:	80 93 68 05 	sts	0x0568, r24

			prvAddTaskToReadyQueue( pxNewTCB );
    6496:	eb 81       	ldd	r30, Y+3	; 0x03
    6498:	fc 81       	ldd	r31, Y+4	; 0x04
    649a:	96 89       	ldd	r25, Z+22	; 0x16
    649c:	80 91 62 05 	lds	r24, 0x0562
    64a0:	89 17       	cp	r24, r25
    64a2:	28 f4       	brcc	.+10     	; 0x64ae <xTaskGenericCreate+0x152>
    64a4:	eb 81       	ldd	r30, Y+3	; 0x03
    64a6:	fc 81       	ldd	r31, Y+4	; 0x04
    64a8:	86 89       	ldd	r24, Z+22	; 0x16
    64aa:	80 93 62 05 	sts	0x0562, r24
    64ae:	eb 81       	ldd	r30, Y+3	; 0x03
    64b0:	fc 81       	ldd	r31, Y+4	; 0x04
    64b2:	86 89       	ldd	r24, Z+22	; 0x16
    64b4:	28 2f       	mov	r18, r24
    64b6:	30 e0       	ldi	r19, 0x00	; 0
    64b8:	c9 01       	movw	r24, r18
    64ba:	88 0f       	add	r24, r24
    64bc:	99 1f       	adc	r25, r25
    64be:	88 0f       	add	r24, r24
    64c0:	99 1f       	adc	r25, r25
    64c2:	88 0f       	add	r24, r24
    64c4:	99 1f       	adc	r25, r25
    64c6:	82 0f       	add	r24, r18
    64c8:	93 1f       	adc	r25, r19
    64ca:	ac 01       	movw	r20, r24
    64cc:	47 59       	subi	r20, 0x97	; 151
    64ce:	5a 4f       	sbci	r21, 0xFA	; 250
    64d0:	8b 81       	ldd	r24, Y+3	; 0x03
    64d2:	9c 81       	ldd	r25, Y+4	; 0x04
    64d4:	9c 01       	movw	r18, r24
    64d6:	2e 5f       	subi	r18, 0xFE	; 254
    64d8:	3f 4f       	sbci	r19, 0xFF	; 255
    64da:	ca 01       	movw	r24, r20
    64dc:	b9 01       	movw	r22, r18
    64de:	0e 94 3b 29 	call	0x5276	; 0x5276 <vListInsertEnd>

			xReturn = pdPASS;
    64e2:	81 e0       	ldi	r24, 0x01	; 1
    64e4:	8d 83       	std	Y+5, r24	; 0x05
			traceTASK_CREATE( pxNewTCB );
		}
		taskEXIT_CRITICAL();
    64e6:	0f 90       	pop	r0
    64e8:	0f be       	out	0x3f, r0	; 63
    64ea:	02 c0       	rjmp	.+4      	; 0x64f0 <xTaskGenericCreate+0x194>
	}
	else
	{
		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
    64ec:	8f ef       	ldi	r24, 0xFF	; 255
    64ee:	8d 83       	std	Y+5, r24	; 0x05
		traceTASK_CREATE_FAILED();
	}

	if( xReturn == pdPASS )
    64f0:	8d 81       	ldd	r24, Y+5	; 0x05
    64f2:	81 30       	cpi	r24, 0x01	; 1
    64f4:	71 f4       	brne	.+28     	; 0x6512 <xTaskGenericCreate+0x1b6>
	{
		if( xSchedulerRunning != pdFALSE )
    64f6:	80 91 63 05 	lds	r24, 0x0563
    64fa:	88 23       	and	r24, r24
    64fc:	51 f0       	breq	.+20     	; 0x6512 <xTaskGenericCreate+0x1b6>
		{
			/* If the created task is of a higher priority than the current task
			then it should run now. */
			if( pxCurrentTCB->uxPriority < uxPriority )
    64fe:	e0 91 5b 05 	lds	r30, 0x055B
    6502:	f0 91 5c 05 	lds	r31, 0x055C
    6506:	96 89       	ldd	r25, Z+22	; 0x16
    6508:	8e 85       	ldd	r24, Y+14	; 0x0e
    650a:	98 17       	cp	r25, r24
    650c:	10 f4       	brcc	.+4      	; 0x6512 <xTaskGenericCreate+0x1b6>
			{
				portYIELD_WITHIN_API();
    650e:	0e 94 fb 2b 	call	0x57f6	; 0x57f6 <vPortYield>
			}
		}
	}

	return xReturn;
    6512:	8d 81       	ldd	r24, Y+5	; 0x05
}
    6514:	64 96       	adiw	r28, 0x14	; 20
    6516:	0f b6       	in	r0, 0x3f	; 63
    6518:	f8 94       	cli
    651a:	de bf       	out	0x3e, r29	; 62
    651c:	0f be       	out	0x3f, r0	; 63
    651e:	cd bf       	out	0x3d, r28	; 61
    6520:	cf 91       	pop	r28
    6522:	df 91       	pop	r29
    6524:	1f 91       	pop	r17
    6526:	0f 91       	pop	r16
    6528:	ff 90       	pop	r15
    652a:	ef 90       	pop	r14
    652c:	df 90       	pop	r13
    652e:	cf 90       	pop	r12
    6530:	bf 90       	pop	r11
    6532:	af 90       	pop	r10
    6534:	08 95       	ret

00006536 <vTaskDelete>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

	void vTaskDelete( xTaskHandle pxTaskToDelete )
	{
    6536:	df 93       	push	r29
    6538:	cf 93       	push	r28
    653a:	00 d0       	rcall	.+0      	; 0x653c <vTaskDelete+0x6>
    653c:	00 d0       	rcall	.+0      	; 0x653e <vTaskDelete+0x8>
    653e:	00 d0       	rcall	.+0      	; 0x6540 <vTaskDelete+0xa>
    6540:	cd b7       	in	r28, 0x3d	; 61
    6542:	de b7       	in	r29, 0x3e	; 62
    6544:	9c 83       	std	Y+4, r25	; 0x04
    6546:	8b 83       	std	Y+3, r24	; 0x03
	tskTCB *pxTCB;

		taskENTER_CRITICAL();
    6548:	0f b6       	in	r0, 0x3f	; 63
    654a:	f8 94       	cli
    654c:	0f 92       	push	r0
		{
			/* Ensure a yield is performed if the current task is being
			deleted. */
			if( pxTaskToDelete == pxCurrentTCB )
    654e:	20 91 5b 05 	lds	r18, 0x055B
    6552:	30 91 5c 05 	lds	r19, 0x055C
    6556:	8b 81       	ldd	r24, Y+3	; 0x03
    6558:	9c 81       	ldd	r25, Y+4	; 0x04
    655a:	82 17       	cp	r24, r18
    655c:	93 07       	cpc	r25, r19
    655e:	11 f4       	brne	.+4      	; 0x6564 <vTaskDelete+0x2e>
			{
				pxTaskToDelete = NULL;
    6560:	1c 82       	std	Y+4, r1	; 0x04
    6562:	1b 82       	std	Y+3, r1	; 0x03
			}

			/* If null is passed in here then we are deleting ourselves. */
			pxTCB = prvGetTCBFromHandle( pxTaskToDelete );
    6564:	8b 81       	ldd	r24, Y+3	; 0x03
    6566:	9c 81       	ldd	r25, Y+4	; 0x04
    6568:	00 97       	sbiw	r24, 0x00	; 0
    656a:	39 f4       	brne	.+14     	; 0x657a <vTaskDelete+0x44>
    656c:	80 91 5b 05 	lds	r24, 0x055B
    6570:	90 91 5c 05 	lds	r25, 0x055C
    6574:	9e 83       	std	Y+6, r25	; 0x06
    6576:	8d 83       	std	Y+5, r24	; 0x05
    6578:	04 c0       	rjmp	.+8      	; 0x6582 <vTaskDelete+0x4c>
    657a:	8b 81       	ldd	r24, Y+3	; 0x03
    657c:	9c 81       	ldd	r25, Y+4	; 0x04
    657e:	9e 83       	std	Y+6, r25	; 0x06
    6580:	8d 83       	std	Y+5, r24	; 0x05
    6582:	8d 81       	ldd	r24, Y+5	; 0x05
    6584:	9e 81       	ldd	r25, Y+6	; 0x06
    6586:	9a 83       	std	Y+2, r25	; 0x02
    6588:	89 83       	std	Y+1, r24	; 0x01

			/* Remove task from the ready list and place in the	termination list.
			This will stop the task from be scheduled.  The idle task will check
			the termination list and free up any memory allocated by the
			scheduler for the TCB and stack. */
			vListRemove( &( pxTCB->xGenericListItem ) );
    658a:	89 81       	ldd	r24, Y+1	; 0x01
    658c:	9a 81       	ldd	r25, Y+2	; 0x02
    658e:	02 96       	adiw	r24, 0x02	; 2
    6590:	0e 94 f3 29 	call	0x53e6	; 0x53e6 <vListRemove>

			/* Is the task waiting on an event also? */
			if( pxTCB->xEventListItem.pvContainer != NULL )
    6594:	e9 81       	ldd	r30, Y+1	; 0x01
    6596:	fa 81       	ldd	r31, Y+2	; 0x02
    6598:	84 89       	ldd	r24, Z+20	; 0x14
    659a:	95 89       	ldd	r25, Z+21	; 0x15
    659c:	00 97       	sbiw	r24, 0x00	; 0
    659e:	29 f0       	breq	.+10     	; 0x65aa <vTaskDelete+0x74>
			{
				vListRemove( &( pxTCB->xEventListItem ) );
    65a0:	89 81       	ldd	r24, Y+1	; 0x01
    65a2:	9a 81       	ldd	r25, Y+2	; 0x02
    65a4:	0c 96       	adiw	r24, 0x0c	; 12
    65a6:	0e 94 f3 29 	call	0x53e6	; 0x53e6 <vListRemove>
			}

			vListInsertEnd( ( xList * ) &xTasksWaitingTermination, &( pxTCB->xGenericListItem ) );
    65aa:	89 81       	ldd	r24, Y+1	; 0x01
    65ac:	9a 81       	ldd	r25, Y+2	; 0x02
    65ae:	9c 01       	movw	r18, r24
    65b0:	2e 5f       	subi	r18, 0xFE	; 254
    65b2:	3f 4f       	sbci	r19, 0xFF	; 255
    65b4:	83 ea       	ldi	r24, 0xA3	; 163
    65b6:	95 e0       	ldi	r25, 0x05	; 5
    65b8:	b9 01       	movw	r22, r18
    65ba:	0e 94 3b 29 	call	0x5276	; 0x5276 <vListInsertEnd>

			/* Increment the ucTasksDeleted variable so the idle task knows
			there is a task that has been deleted and that it should therefore
			check the xTasksWaitingTermination list. */
			++uxTasksDeleted;
    65be:	80 91 5d 05 	lds	r24, 0x055D
    65c2:	8f 5f       	subi	r24, 0xFF	; 255
    65c4:	80 93 5d 05 	sts	0x055D, r24

			/* Increment the uxTaskNumberVariable also so kernel aware debuggers
			can detect that the task lists need re-generating. */
			uxTaskNumber++;
    65c8:	80 91 68 05 	lds	r24, 0x0568
    65cc:	8f 5f       	subi	r24, 0xFF	; 255
    65ce:	80 93 68 05 	sts	0x0568, r24

			traceTASK_DELETE( pxTCB );
		}
		taskEXIT_CRITICAL();
    65d2:	0f 90       	pop	r0
    65d4:	0f be       	out	0x3f, r0	; 63

		/* Force a reschedule if we have just deleted the current task. */
		if( xSchedulerRunning != pdFALSE )
    65d6:	80 91 63 05 	lds	r24, 0x0563
    65da:	88 23       	and	r24, r24
    65dc:	31 f0       	breq	.+12     	; 0x65ea <vTaskDelete+0xb4>
		{
			if( ( void * ) pxTaskToDelete == NULL )
    65de:	8b 81       	ldd	r24, Y+3	; 0x03
    65e0:	9c 81       	ldd	r25, Y+4	; 0x04
    65e2:	00 97       	sbiw	r24, 0x00	; 0
    65e4:	11 f4       	brne	.+4      	; 0x65ea <vTaskDelete+0xb4>
			{
				portYIELD_WITHIN_API();
    65e6:	0e 94 fb 2b 	call	0x57f6	; 0x57f6 <vPortYield>
			}
		}
	}
    65ea:	26 96       	adiw	r28, 0x06	; 6
    65ec:	0f b6       	in	r0, 0x3f	; 63
    65ee:	f8 94       	cli
    65f0:	de bf       	out	0x3e, r29	; 62
    65f2:	0f be       	out	0x3f, r0	; 63
    65f4:	cd bf       	out	0x3d, r28	; 61
    65f6:	cf 91       	pop	r28
    65f8:	df 91       	pop	r29
    65fa:	08 95       	ret

000065fc <vTaskDelayUntil>:
 *----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( portTickType * const pxPreviousWakeTime, portTickType xTimeIncrement )
	{
    65fc:	df 93       	push	r29
    65fe:	cf 93       	push	r28
    6600:	cd b7       	in	r28, 0x3d	; 61
    6602:	de b7       	in	r29, 0x3e	; 62
    6604:	28 97       	sbiw	r28, 0x08	; 8
    6606:	0f b6       	in	r0, 0x3f	; 63
    6608:	f8 94       	cli
    660a:	de bf       	out	0x3e, r29	; 62
    660c:	0f be       	out	0x3f, r0	; 63
    660e:	cd bf       	out	0x3d, r28	; 61
    6610:	9e 83       	std	Y+6, r25	; 0x06
    6612:	8d 83       	std	Y+5, r24	; 0x05
    6614:	78 87       	std	Y+8, r23	; 0x08
    6616:	6f 83       	std	Y+7, r22	; 0x07
	portTickType xTimeToWake;
	portBASE_TYPE xAlreadyYielded, xShouldDelay = pdFALSE;
    6618:	19 82       	std	Y+1, r1	; 0x01

		configASSERT( pxPreviousWakeTime );
		configASSERT( ( xTimeIncrement > 0U ) );

		vTaskSuspendAll();
    661a:	0e 94 ea 33 	call	0x67d4	; 0x67d4 <vTaskSuspendAll>
		{
			/* Generate the tick time at which the task wants to wake. */
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
    661e:	ed 81       	ldd	r30, Y+5	; 0x05
    6620:	fe 81       	ldd	r31, Y+6	; 0x06
    6622:	20 81       	ld	r18, Z
    6624:	31 81       	ldd	r19, Z+1	; 0x01
    6626:	8f 81       	ldd	r24, Y+7	; 0x07
    6628:	98 85       	ldd	r25, Y+8	; 0x08
    662a:	82 0f       	add	r24, r18
    662c:	93 1f       	adc	r25, r19
    662e:	9c 83       	std	Y+4, r25	; 0x04
    6630:	8b 83       	std	Y+3, r24	; 0x03

			if( xTickCount < *pxPreviousWakeTime )
    6632:	ed 81       	ldd	r30, Y+5	; 0x05
    6634:	fe 81       	ldd	r31, Y+6	; 0x06
    6636:	20 81       	ld	r18, Z
    6638:	31 81       	ldd	r19, Z+1	; 0x01
    663a:	80 91 5f 05 	lds	r24, 0x055F
    663e:	90 91 60 05 	lds	r25, 0x0560
    6642:	82 17       	cp	r24, r18
    6644:	93 07       	cpc	r25, r19
    6646:	a8 f4       	brcc	.+42     	; 0x6672 <vTaskDelayUntil+0x76>
				/* The tick count has overflowed since this function was
				lasted called.  In this case the only time we should ever
				actually delay is if the wake time has also	overflowed,
				and the wake time is greater than the tick time.  When this
				is the case it is as if neither time had overflowed. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xTickCount ) )
    6648:	ed 81       	ldd	r30, Y+5	; 0x05
    664a:	fe 81       	ldd	r31, Y+6	; 0x06
    664c:	20 81       	ld	r18, Z
    664e:	31 81       	ldd	r19, Z+1	; 0x01
    6650:	8b 81       	ldd	r24, Y+3	; 0x03
    6652:	9c 81       	ldd	r25, Y+4	; 0x04
    6654:	82 17       	cp	r24, r18
    6656:	93 07       	cpc	r25, r19
    6658:	00 f5       	brcc	.+64     	; 0x669a <vTaskDelayUntil+0x9e>
    665a:	20 91 5f 05 	lds	r18, 0x055F
    665e:	30 91 60 05 	lds	r19, 0x0560
    6662:	8b 81       	ldd	r24, Y+3	; 0x03
    6664:	9c 81       	ldd	r25, Y+4	; 0x04
    6666:	28 17       	cp	r18, r24
    6668:	39 07       	cpc	r19, r25
    666a:	b8 f4       	brcc	.+46     	; 0x669a <vTaskDelayUntil+0x9e>
				{
					xShouldDelay = pdTRUE;
    666c:	81 e0       	ldi	r24, 0x01	; 1
    666e:	89 83       	std	Y+1, r24	; 0x01
    6670:	14 c0       	rjmp	.+40     	; 0x669a <vTaskDelayUntil+0x9e>
			else
			{
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xTickCount ) )
    6672:	ed 81       	ldd	r30, Y+5	; 0x05
    6674:	fe 81       	ldd	r31, Y+6	; 0x06
    6676:	20 81       	ld	r18, Z
    6678:	31 81       	ldd	r19, Z+1	; 0x01
    667a:	8b 81       	ldd	r24, Y+3	; 0x03
    667c:	9c 81       	ldd	r25, Y+4	; 0x04
    667e:	82 17       	cp	r24, r18
    6680:	93 07       	cpc	r25, r19
    6682:	48 f0       	brcs	.+18     	; 0x6696 <vTaskDelayUntil+0x9a>
    6684:	20 91 5f 05 	lds	r18, 0x055F
    6688:	30 91 60 05 	lds	r19, 0x0560
    668c:	8b 81       	ldd	r24, Y+3	; 0x03
    668e:	9c 81       	ldd	r25, Y+4	; 0x04
    6690:	28 17       	cp	r18, r24
    6692:	39 07       	cpc	r19, r25
    6694:	10 f4       	brcc	.+4      	; 0x669a <vTaskDelayUntil+0x9e>
				{
					xShouldDelay = pdTRUE;
    6696:	81 e0       	ldi	r24, 0x01	; 1
    6698:	89 83       	std	Y+1, r24	; 0x01
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
    669a:	ed 81       	ldd	r30, Y+5	; 0x05
    669c:	fe 81       	ldd	r31, Y+6	; 0x06
    669e:	8b 81       	ldd	r24, Y+3	; 0x03
    66a0:	9c 81       	ldd	r25, Y+4	; 0x04
    66a2:	91 83       	std	Z+1, r25	; 0x01
    66a4:	80 83       	st	Z, r24

			if( xShouldDelay != pdFALSE )
    66a6:	89 81       	ldd	r24, Y+1	; 0x01
    66a8:	88 23       	and	r24, r24
    66aa:	59 f0       	breq	.+22     	; 0x66c2 <vTaskDelayUntil+0xc6>
				traceTASK_DELAY_UNTIL();

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    66ac:	80 91 5b 05 	lds	r24, 0x055B
    66b0:	90 91 5c 05 	lds	r25, 0x055C
    66b4:	02 96       	adiw	r24, 0x02	; 2
    66b6:	0e 94 f3 29 	call	0x53e6	; 0x53e6 <vListRemove>
				prvAddCurrentTaskToDelayedList( xTimeToWake );
    66ba:	8b 81       	ldd	r24, Y+3	; 0x03
    66bc:	9c 81       	ldd	r25, Y+4	; 0x04
    66be:	0e 94 ea 37 	call	0x6fd4	; 0x6fd4 <prvAddCurrentTaskToDelayedList>
			}
		}
		xAlreadyYielded = xTaskResumeAll();
    66c2:	0e 94 f6 33 	call	0x67ec	; 0x67ec <xTaskResumeAll>
    66c6:	8a 83       	std	Y+2, r24	; 0x02

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    66c8:	8a 81       	ldd	r24, Y+2	; 0x02
    66ca:	88 23       	and	r24, r24
    66cc:	11 f4       	brne	.+4      	; 0x66d2 <vTaskDelayUntil+0xd6>
		{
			portYIELD_WITHIN_API();
    66ce:	0e 94 fb 2b 	call	0x57f6	; 0x57f6 <vPortYield>
		}
	}
    66d2:	28 96       	adiw	r28, 0x08	; 8
    66d4:	0f b6       	in	r0, 0x3f	; 63
    66d6:	f8 94       	cli
    66d8:	de bf       	out	0x3e, r29	; 62
    66da:	0f be       	out	0x3f, r0	; 63
    66dc:	cd bf       	out	0x3d, r28	; 61
    66de:	cf 91       	pop	r28
    66e0:	df 91       	pop	r29
    66e2:	08 95       	ret

000066e4 <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( portTickType xTicksToDelay )
	{
    66e4:	df 93       	push	r29
    66e6:	cf 93       	push	r28
    66e8:	00 d0       	rcall	.+0      	; 0x66ea <vTaskDelay+0x6>
    66ea:	00 d0       	rcall	.+0      	; 0x66ec <vTaskDelay+0x8>
    66ec:	0f 92       	push	r0
    66ee:	cd b7       	in	r28, 0x3d	; 61
    66f0:	de b7       	in	r29, 0x3e	; 62
    66f2:	9d 83       	std	Y+5, r25	; 0x05
    66f4:	8c 83       	std	Y+4, r24	; 0x04
	portTickType xTimeToWake;
	signed portBASE_TYPE xAlreadyYielded = pdFALSE;
    66f6:	19 82       	std	Y+1, r1	; 0x01

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( portTickType ) 0U )
    66f8:	8c 81       	ldd	r24, Y+4	; 0x04
    66fa:	9d 81       	ldd	r25, Y+5	; 0x05
    66fc:	00 97       	sbiw	r24, 0x00	; 0
    66fe:	d1 f0       	breq	.+52     	; 0x6734 <vTaskDelay+0x50>
		{
			vTaskSuspendAll();
    6700:	0e 94 ea 33 	call	0x67d4	; 0x67d4 <vTaskSuspendAll>
				This task cannot be in an event list as it is the currently
				executing task. */

				/* Calculate the time to wake - this may overflow but this is
				not a problem. */
				xTimeToWake = xTickCount + xTicksToDelay;
    6704:	20 91 5f 05 	lds	r18, 0x055F
    6708:	30 91 60 05 	lds	r19, 0x0560
    670c:	8c 81       	ldd	r24, Y+4	; 0x04
    670e:	9d 81       	ldd	r25, Y+5	; 0x05
    6710:	82 0f       	add	r24, r18
    6712:	93 1f       	adc	r25, r19
    6714:	9b 83       	std	Y+3, r25	; 0x03
    6716:	8a 83       	std	Y+2, r24	; 0x02

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    6718:	80 91 5b 05 	lds	r24, 0x055B
    671c:	90 91 5c 05 	lds	r25, 0x055C
    6720:	02 96       	adiw	r24, 0x02	; 2
    6722:	0e 94 f3 29 	call	0x53e6	; 0x53e6 <vListRemove>
				prvAddCurrentTaskToDelayedList( xTimeToWake );
    6726:	8a 81       	ldd	r24, Y+2	; 0x02
    6728:	9b 81       	ldd	r25, Y+3	; 0x03
    672a:	0e 94 ea 37 	call	0x6fd4	; 0x6fd4 <prvAddCurrentTaskToDelayedList>
			}
			xAlreadyYielded = xTaskResumeAll();
    672e:	0e 94 f6 33 	call	0x67ec	; 0x67ec <xTaskResumeAll>
    6732:	89 83       	std	Y+1, r24	; 0x01
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    6734:	89 81       	ldd	r24, Y+1	; 0x01
    6736:	88 23       	and	r24, r24
    6738:	11 f4       	brne	.+4      	; 0x673e <vTaskDelay+0x5a>
		{
			portYIELD_WITHIN_API();
    673a:	0e 94 fb 2b 	call	0x57f6	; 0x57f6 <vPortYield>
		}
	}
    673e:	0f 90       	pop	r0
    6740:	0f 90       	pop	r0
    6742:	0f 90       	pop	r0
    6744:	0f 90       	pop	r0
    6746:	0f 90       	pop	r0
    6748:	cf 91       	pop	r28
    674a:	df 91       	pop	r29
    674c:	08 95       	ret

0000674e <vTaskStartScheduler>:
 * PUBLIC SCHEDULER CONTROL documented in task.h
 *----------------------------------------------------------*/


void vTaskStartScheduler( void )
{
    674e:	af 92       	push	r10
    6750:	bf 92       	push	r11
    6752:	cf 92       	push	r12
    6754:	df 92       	push	r13
    6756:	ef 92       	push	r14
    6758:	ff 92       	push	r15
    675a:	0f 93       	push	r16
    675c:	df 93       	push	r29
    675e:	cf 93       	push	r28
    6760:	0f 92       	push	r0
    6762:	cd b7       	in	r28, 0x3d	; 61
    6764:	de b7       	in	r29, 0x3e	; 62
		xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), &xIdleTaskHandle );
	}
	#else
	{
		/* Create the idle task without storing its handle. */
		xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), NULL );
    6766:	21 e7       	ldi	r18, 0x71	; 113
    6768:	30 e0       	ldi	r19, 0x00	; 0
    676a:	8e e0       	ldi	r24, 0x0E	; 14
    676c:	97 e3       	ldi	r25, 0x37	; 55
    676e:	b9 01       	movw	r22, r18
    6770:	4a ef       	ldi	r20, 0xFA	; 250
    6772:	50 e0       	ldi	r21, 0x00	; 0
    6774:	20 e0       	ldi	r18, 0x00	; 0
    6776:	30 e0       	ldi	r19, 0x00	; 0
    6778:	00 e0       	ldi	r16, 0x00	; 0
    677a:	ee 24       	eor	r14, r14
    677c:	ff 24       	eor	r15, r15
    677e:	cc 24       	eor	r12, r12
    6780:	dd 24       	eor	r13, r13
    6782:	aa 24       	eor	r10, r10
    6784:	bb 24       	eor	r11, r11
    6786:	0e 94 ae 31 	call	0x635c	; 0x635c <xTaskGenericCreate>
    678a:	89 83       	std	Y+1, r24	; 0x01
			xReturn = xTimerCreateTimerTask();
		}
	}
	#endif

	if( xReturn == pdPASS )
    678c:	89 81       	ldd	r24, Y+1	; 0x01
    678e:	81 30       	cpi	r24, 0x01	; 1
    6790:	51 f4       	brne	.+20     	; 0x67a6 <vTaskStartScheduler+0x58>
		so interrupts will automatically get re-enabled when the first task
		starts to run.

		STEPPING THROUGH HERE USING A DEBUGGER CAN CAUSE BIG PROBLEMS IF THE
		DEBUGGER ALLOWS INTERRUPTS TO BE PROCESSED. */
		portDISABLE_INTERRUPTS();
    6792:	f8 94       	cli

		xSchedulerRunning = pdTRUE;
    6794:	81 e0       	ldi	r24, 0x01	; 1
    6796:	80 93 63 05 	sts	0x0563, r24
		xTickCount = ( portTickType ) 0U;
    679a:	10 92 60 05 	sts	0x0560, r1
    679e:	10 92 5f 05 	sts	0x055F, r1
		the run time counter time base. */
		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();
		
		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() != pdFALSE )
    67a2:	0e 94 bf 2b 	call	0x577e	; 0x577e <xPortStartScheduler>
		}
	}

	/* This line will only be reached if the kernel could not be started. */
	configASSERT( xReturn );
}
    67a6:	0f 90       	pop	r0
    67a8:	cf 91       	pop	r28
    67aa:	df 91       	pop	r29
    67ac:	0f 91       	pop	r16
    67ae:	ff 90       	pop	r15
    67b0:	ef 90       	pop	r14
    67b2:	df 90       	pop	r13
    67b4:	cf 90       	pop	r12
    67b6:	bf 90       	pop	r11
    67b8:	af 90       	pop	r10
    67ba:	08 95       	ret

000067bc <vTaskEndScheduler>:
/*-----------------------------------------------------------*/

void vTaskEndScheduler( void )
{
    67bc:	df 93       	push	r29
    67be:	cf 93       	push	r28
    67c0:	cd b7       	in	r28, 0x3d	; 61
    67c2:	de b7       	in	r29, 0x3e	; 62
	/* Stop the scheduler interrupts and call the portable scheduler end
	routine so the original ISRs can be restored if necessary.  The port
	layer must ensure interrupts enable	bit is left in the correct state. */
	portDISABLE_INTERRUPTS();
    67c4:	f8 94       	cli
	xSchedulerRunning = pdFALSE;
    67c6:	10 92 63 05 	sts	0x0563, r1
	vPortEndScheduler();
    67ca:	0e 94 f4 2b 	call	0x57e8	; 0x57e8 <vPortEndScheduler>
}
    67ce:	cf 91       	pop	r28
    67d0:	df 91       	pop	r29
    67d2:	08 95       	ret

000067d4 <vTaskSuspendAll>:
/*----------------------------------------------------------*/

void vTaskSuspendAll( void )
{
    67d4:	df 93       	push	r29
    67d6:	cf 93       	push	r28
    67d8:	cd b7       	in	r28, 0x3d	; 61
    67da:	de b7       	in	r29, 0x3e	; 62
	/* A critical section is not required as the variable is of type
	portBASE_TYPE. */
	++uxSchedulerSuspended;
    67dc:	80 91 64 05 	lds	r24, 0x0564
    67e0:	8f 5f       	subi	r24, 0xFF	; 255
    67e2:	80 93 64 05 	sts	0x0564, r24
}
    67e6:	cf 91       	pop	r28
    67e8:	df 91       	pop	r29
    67ea:	08 95       	ret

000067ec <xTaskResumeAll>:
/*----------------------------------------------------------*/

signed portBASE_TYPE xTaskResumeAll( void )
{
    67ec:	df 93       	push	r29
    67ee:	cf 93       	push	r28
    67f0:	00 d0       	rcall	.+0      	; 0x67f2 <xTaskResumeAll+0x6>
    67f2:	00 d0       	rcall	.+0      	; 0x67f4 <xTaskResumeAll+0x8>
    67f4:	cd b7       	in	r28, 0x3d	; 61
    67f6:	de b7       	in	r29, 0x3e	; 62
register tskTCB *pxTCB;
signed portBASE_TYPE xAlreadyYielded = pdFALSE;
    67f8:	1a 82       	std	Y+2, r1	; 0x02
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
    67fa:	0f b6       	in	r0, 0x3f	; 63
    67fc:	f8 94       	cli
    67fe:	0f 92       	push	r0
	{
		--uxSchedulerSuspended;
    6800:	80 91 64 05 	lds	r24, 0x0564
    6804:	81 50       	subi	r24, 0x01	; 1
    6806:	80 93 64 05 	sts	0x0564, r24

		if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    680a:	80 91 64 05 	lds	r24, 0x0564
    680e:	88 23       	and	r24, r24
    6810:	09 f0       	breq	.+2      	; 0x6814 <xTaskResumeAll+0x28>
    6812:	6c c0       	rjmp	.+216    	; 0x68ec <xTaskResumeAll+0x100>
		{
			if( uxCurrentNumberOfTasks > ( unsigned portBASE_TYPE ) 0U )
    6814:	80 91 5e 05 	lds	r24, 0x055E
    6818:	88 23       	and	r24, r24
    681a:	09 f4       	brne	.+2      	; 0x681e <xTaskResumeAll+0x32>
    681c:	67 c0       	rjmp	.+206    	; 0x68ec <xTaskResumeAll+0x100>
			{
				portBASE_TYPE xYieldRequired = pdFALSE;
    681e:	19 82       	std	Y+1, r1	; 0x01
    6820:	41 c0       	rjmp	.+130    	; 0x68a4 <xTaskResumeAll+0xb8>

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
    6822:	e0 91 9f 05 	lds	r30, 0x059F
    6826:	f0 91 a0 05 	lds	r31, 0x05A0
    682a:	86 81       	ldd	r24, Z+6	; 0x06
    682c:	97 81       	ldd	r25, Z+7	; 0x07
    682e:	9c 83       	std	Y+4, r25	; 0x04
    6830:	8b 83       	std	Y+3, r24	; 0x03
					vListRemove( &( pxTCB->xEventListItem ) );
    6832:	8b 81       	ldd	r24, Y+3	; 0x03
    6834:	9c 81       	ldd	r25, Y+4	; 0x04
    6836:	0c 96       	adiw	r24, 0x0c	; 12
    6838:	0e 94 f3 29 	call	0x53e6	; 0x53e6 <vListRemove>
					vListRemove( &( pxTCB->xGenericListItem ) );
    683c:	8b 81       	ldd	r24, Y+3	; 0x03
    683e:	9c 81       	ldd	r25, Y+4	; 0x04
    6840:	02 96       	adiw	r24, 0x02	; 2
    6842:	0e 94 f3 29 	call	0x53e6	; 0x53e6 <vListRemove>
					prvAddTaskToReadyQueue( pxTCB );
    6846:	eb 81       	ldd	r30, Y+3	; 0x03
    6848:	fc 81       	ldd	r31, Y+4	; 0x04
    684a:	96 89       	ldd	r25, Z+22	; 0x16
    684c:	80 91 62 05 	lds	r24, 0x0562
    6850:	89 17       	cp	r24, r25
    6852:	28 f4       	brcc	.+10     	; 0x685e <xTaskResumeAll+0x72>
    6854:	eb 81       	ldd	r30, Y+3	; 0x03
    6856:	fc 81       	ldd	r31, Y+4	; 0x04
    6858:	86 89       	ldd	r24, Z+22	; 0x16
    685a:	80 93 62 05 	sts	0x0562, r24
    685e:	eb 81       	ldd	r30, Y+3	; 0x03
    6860:	fc 81       	ldd	r31, Y+4	; 0x04
    6862:	86 89       	ldd	r24, Z+22	; 0x16
    6864:	28 2f       	mov	r18, r24
    6866:	30 e0       	ldi	r19, 0x00	; 0
    6868:	c9 01       	movw	r24, r18
    686a:	88 0f       	add	r24, r24
    686c:	99 1f       	adc	r25, r25
    686e:	88 0f       	add	r24, r24
    6870:	99 1f       	adc	r25, r25
    6872:	88 0f       	add	r24, r24
    6874:	99 1f       	adc	r25, r25
    6876:	82 0f       	add	r24, r18
    6878:	93 1f       	adc	r25, r19
    687a:	87 59       	subi	r24, 0x97	; 151
    687c:	9a 4f       	sbci	r25, 0xFA	; 250
    687e:	2b 81       	ldd	r18, Y+3	; 0x03
    6880:	3c 81       	ldd	r19, Y+4	; 0x04
    6882:	2e 5f       	subi	r18, 0xFE	; 254
    6884:	3f 4f       	sbci	r19, 0xFF	; 255
    6886:	b9 01       	movw	r22, r18
    6888:	0e 94 3b 29 	call	0x5276	; 0x5276 <vListInsertEnd>

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    688c:	eb 81       	ldd	r30, Y+3	; 0x03
    688e:	fc 81       	ldd	r31, Y+4	; 0x04
    6890:	96 89       	ldd	r25, Z+22	; 0x16
    6892:	e0 91 5b 05 	lds	r30, 0x055B
    6896:	f0 91 5c 05 	lds	r31, 0x055C
    689a:	86 89       	ldd	r24, Z+22	; 0x16
    689c:	98 17       	cp	r25, r24
    689e:	10 f0       	brcs	.+4      	; 0x68a4 <xTaskResumeAll+0xb8>
					{
						xYieldRequired = pdTRUE;
    68a0:	81 e0       	ldi	r24, 0x01	; 1
    68a2:	89 83       	std	Y+1, r24	; 0x01
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
    68a4:	80 91 9a 05 	lds	r24, 0x059A
    68a8:	88 23       	and	r24, r24
    68aa:	09 f0       	breq	.+2      	; 0x68ae <xTaskResumeAll+0xc2>
    68ac:	ba cf       	rjmp	.-140    	; 0x6822 <xTaskResumeAll+0x36>
				}

				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
    68ae:	80 91 65 05 	lds	r24, 0x0565
    68b2:	88 23       	and	r24, r24
    68b4:	71 f0       	breq	.+28     	; 0x68d2 <xTaskResumeAll+0xe6>
    68b6:	07 c0       	rjmp	.+14     	; 0x68c6 <xTaskResumeAll+0xda>
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
					{
						vTaskIncrementTick();
    68b8:	0e 94 b5 34 	call	0x696a	; 0x696a <vTaskIncrementTick>
						--uxMissedTicks;
    68bc:	80 91 65 05 	lds	r24, 0x0565
    68c0:	81 50       	subi	r24, 0x01	; 1
    68c2:	80 93 65 05 	sts	0x0565, r24
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
    68c6:	80 91 65 05 	lds	r24, 0x0565
    68ca:	88 23       	and	r24, r24
    68cc:	a9 f7       	brne	.-22     	; 0x68b8 <xTaskResumeAll+0xcc>
					/* As we have processed some ticks it is appropriate to yield
					to ensure the highest priority task that is ready to run is
					the task actually running. */
					#if configUSE_PREEMPTION == 1
					{
						xYieldRequired = pdTRUE;
    68ce:	81 e0       	ldi	r24, 0x01	; 1
    68d0:	89 83       	std	Y+1, r24	; 0x01
					}
					#endif
				}

				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
    68d2:	89 81       	ldd	r24, Y+1	; 0x01
    68d4:	81 30       	cpi	r24, 0x01	; 1
    68d6:	21 f0       	breq	.+8      	; 0x68e0 <xTaskResumeAll+0xf4>
    68d8:	80 91 66 05 	lds	r24, 0x0566
    68dc:	81 30       	cpi	r24, 0x01	; 1
    68de:	31 f4       	brne	.+12     	; 0x68ec <xTaskResumeAll+0x100>
				{
					xAlreadyYielded = pdTRUE;
    68e0:	81 e0       	ldi	r24, 0x01	; 1
    68e2:	8a 83       	std	Y+2, r24	; 0x02
					xMissedYield = pdFALSE;
    68e4:	10 92 66 05 	sts	0x0566, r1
					portYIELD_WITHIN_API();
    68e8:	0e 94 fb 2b 	call	0x57f6	; 0x57f6 <vPortYield>
				}
			}
		}
	}
	taskEXIT_CRITICAL();
    68ec:	0f 90       	pop	r0
    68ee:	0f be       	out	0x3f, r0	; 63

	return xAlreadyYielded;
    68f0:	8a 81       	ldd	r24, Y+2	; 0x02
}
    68f2:	0f 90       	pop	r0
    68f4:	0f 90       	pop	r0
    68f6:	0f 90       	pop	r0
    68f8:	0f 90       	pop	r0
    68fa:	cf 91       	pop	r28
    68fc:	df 91       	pop	r29
    68fe:	08 95       	ret

00006900 <xTaskGetTickCount>:
 *----------------------------------------------------------*/



portTickType xTaskGetTickCount( void )
{
    6900:	df 93       	push	r29
    6902:	cf 93       	push	r28
    6904:	00 d0       	rcall	.+0      	; 0x6906 <xTaskGetTickCount+0x6>
    6906:	cd b7       	in	r28, 0x3d	; 61
    6908:	de b7       	in	r29, 0x3e	; 62
portTickType xTicks;

	/* Critical section required if running on a 16 bit processor. */
	taskENTER_CRITICAL();
    690a:	0f b6       	in	r0, 0x3f	; 63
    690c:	f8 94       	cli
    690e:	0f 92       	push	r0
	{
		xTicks = xTickCount;
    6910:	80 91 5f 05 	lds	r24, 0x055F
    6914:	90 91 60 05 	lds	r25, 0x0560
    6918:	9a 83       	std	Y+2, r25	; 0x02
    691a:	89 83       	std	Y+1, r24	; 0x01
	}
	taskEXIT_CRITICAL();
    691c:	0f 90       	pop	r0
    691e:	0f be       	out	0x3f, r0	; 63

	return xTicks;
    6920:	89 81       	ldd	r24, Y+1	; 0x01
    6922:	9a 81       	ldd	r25, Y+2	; 0x02
}
    6924:	0f 90       	pop	r0
    6926:	0f 90       	pop	r0
    6928:	cf 91       	pop	r28
    692a:	df 91       	pop	r29
    692c:	08 95       	ret

0000692e <xTaskGetTickCountFromISR>:
/*-----------------------------------------------------------*/

portTickType xTaskGetTickCountFromISR( void )
{
    692e:	df 93       	push	r29
    6930:	cf 93       	push	r28
    6932:	00 d0       	rcall	.+0      	; 0x6934 <xTaskGetTickCountFromISR+0x6>
    6934:	0f 92       	push	r0
    6936:	cd b7       	in	r28, 0x3d	; 61
    6938:	de b7       	in	r29, 0x3e	; 62
portTickType xReturn;
unsigned portBASE_TYPE uxSavedInterruptStatus;

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    693a:	19 82       	std	Y+1, r1	; 0x01
	xReturn = xTickCount;
    693c:	80 91 5f 05 	lds	r24, 0x055F
    6940:	90 91 60 05 	lds	r25, 0x0560
    6944:	9b 83       	std	Y+3, r25	; 0x03
    6946:	8a 83       	std	Y+2, r24	; 0x02
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    6948:	8a 81       	ldd	r24, Y+2	; 0x02
    694a:	9b 81       	ldd	r25, Y+3	; 0x03
}
    694c:	0f 90       	pop	r0
    694e:	0f 90       	pop	r0
    6950:	0f 90       	pop	r0
    6952:	cf 91       	pop	r28
    6954:	df 91       	pop	r29
    6956:	08 95       	ret

00006958 <uxTaskGetNumberOfTasks>:
/*-----------------------------------------------------------*/

unsigned portBASE_TYPE uxTaskGetNumberOfTasks( void )
{
    6958:	df 93       	push	r29
    695a:	cf 93       	push	r28
    695c:	cd b7       	in	r28, 0x3d	; 61
    695e:	de b7       	in	r29, 0x3e	; 62
	/* A critical section is not required because the variables are of type
	portBASE_TYPE. */
	return uxCurrentNumberOfTasks;
    6960:	80 91 5e 05 	lds	r24, 0x055E
}
    6964:	cf 91       	pop	r28
    6966:	df 91       	pop	r29
    6968:	08 95       	ret

0000696a <vTaskIncrementTick>:
 * SCHEDULER INTERNALS AVAILABLE FOR PORTING PURPOSES
 * documented in task.h
 *----------------------------------------------------------*/

void vTaskIncrementTick( void )
{
    696a:	df 93       	push	r29
    696c:	cf 93       	push	r28
    696e:	00 d0       	rcall	.+0      	; 0x6970 <vTaskIncrementTick+0x6>
    6970:	00 d0       	rcall	.+0      	; 0x6972 <vTaskIncrementTick+0x8>
    6972:	00 d0       	rcall	.+0      	; 0x6974 <vTaskIncrementTick+0xa>
    6974:	cd b7       	in	r28, 0x3d	; 61
    6976:	de b7       	in	r29, 0x3e	; 62
tskTCB * pxTCB;

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    6978:	80 91 64 05 	lds	r24, 0x0564
    697c:	88 23       	and	r24, r24
    697e:	09 f0       	breq	.+2      	; 0x6982 <vTaskIncrementTick+0x18>
    6980:	bb c0       	rjmp	.+374    	; 0x6af8 <vTaskIncrementTick+0x18e>
	{
		++xTickCount;
    6982:	80 91 5f 05 	lds	r24, 0x055F
    6986:	90 91 60 05 	lds	r25, 0x0560
    698a:	01 96       	adiw	r24, 0x01	; 1
    698c:	90 93 60 05 	sts	0x0560, r25
    6990:	80 93 5f 05 	sts	0x055F, r24
		if( xTickCount == ( portTickType ) 0U )
    6994:	80 91 5f 05 	lds	r24, 0x055F
    6998:	90 91 60 05 	lds	r25, 0x0560
    699c:	00 97       	sbiw	r24, 0x00	; 0
    699e:	d1 f5       	brne	.+116    	; 0x6a14 <vTaskIncrementTick+0xaa>
			/* Tick count has overflowed so we need to swap the delay lists.
			If there are any items in pxDelayedTaskList here then there is
			an error! */
			configASSERT( ( listLIST_IS_EMPTY( pxDelayedTaskList ) ) );
			
			pxTemp = pxDelayedTaskList;
    69a0:	80 91 96 05 	lds	r24, 0x0596
    69a4:	90 91 97 05 	lds	r25, 0x0597
    69a8:	9c 83       	std	Y+4, r25	; 0x04
    69aa:	8b 83       	std	Y+3, r24	; 0x03
			pxDelayedTaskList = pxOverflowDelayedTaskList;
    69ac:	80 91 98 05 	lds	r24, 0x0598
    69b0:	90 91 99 05 	lds	r25, 0x0599
    69b4:	90 93 97 05 	sts	0x0597, r25
    69b8:	80 93 96 05 	sts	0x0596, r24
			pxOverflowDelayedTaskList = pxTemp;
    69bc:	8b 81       	ldd	r24, Y+3	; 0x03
    69be:	9c 81       	ldd	r25, Y+4	; 0x04
    69c0:	90 93 99 05 	sts	0x0599, r25
    69c4:	80 93 98 05 	sts	0x0598, r24
			xNumOfOverflows++;
    69c8:	80 91 67 05 	lds	r24, 0x0567
    69cc:	8f 5f       	subi	r24, 0xFF	; 255
    69ce:	80 93 67 05 	sts	0x0567, r24
	
			if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    69d2:	e0 91 96 05 	lds	r30, 0x0596
    69d6:	f0 91 97 05 	lds	r31, 0x0597
    69da:	80 81       	ld	r24, Z
    69dc:	88 23       	and	r24, r24
    69de:	39 f4       	brne	.+14     	; 0x69ee <vTaskIncrementTick+0x84>
				/* The new current delayed list is empty.  Set
				xNextTaskUnblockTime to the maximum possible value so it is
				extremely unlikely that the	
				if( xTickCount >= xNextTaskUnblockTime ) test will pass until
				there is an item in the delayed list. */
				xNextTaskUnblockTime = portMAX_DELAY;
    69e0:	8f ef       	ldi	r24, 0xFF	; 255
    69e2:	9f ef       	ldi	r25, 0xFF	; 255
    69e4:	90 93 08 01 	sts	0x0108, r25
    69e8:	80 93 07 01 	sts	0x0107, r24
    69ec:	13 c0       	rjmp	.+38     	; 0x6a14 <vTaskIncrementTick+0xaa>
			{
				/* The new current delayed list is not empty, get the value of
				the item at the head of the delayed list.  This is the time at
				which the task at the head of the delayed list should be removed
				from the Blocked state. */
				pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
    69ee:	e0 91 96 05 	lds	r30, 0x0596
    69f2:	f0 91 97 05 	lds	r31, 0x0597
    69f6:	05 80       	ldd	r0, Z+5	; 0x05
    69f8:	f6 81       	ldd	r31, Z+6	; 0x06
    69fa:	e0 2d       	mov	r30, r0
    69fc:	86 81       	ldd	r24, Z+6	; 0x06
    69fe:	97 81       	ldd	r25, Z+7	; 0x07
    6a00:	9e 83       	std	Y+6, r25	; 0x06
    6a02:	8d 83       	std	Y+5, r24	; 0x05
				xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
    6a04:	ed 81       	ldd	r30, Y+5	; 0x05
    6a06:	fe 81       	ldd	r31, Y+6	; 0x06
    6a08:	82 81       	ldd	r24, Z+2	; 0x02
    6a0a:	93 81       	ldd	r25, Z+3	; 0x03
    6a0c:	90 93 08 01 	sts	0x0108, r25
    6a10:	80 93 07 01 	sts	0x0107, r24
			}
		}

		/* See if this tick has made a timeout expire. */
		prvCheckDelayedTasks();
    6a14:	20 91 5f 05 	lds	r18, 0x055F
    6a18:	30 91 60 05 	lds	r19, 0x0560
    6a1c:	80 91 07 01 	lds	r24, 0x0107
    6a20:	90 91 08 01 	lds	r25, 0x0108
    6a24:	28 17       	cp	r18, r24
    6a26:	39 07       	cpc	r19, r25
    6a28:	08 f4       	brcc	.+2      	; 0x6a2c <vTaskIncrementTick+0xc2>
    6a2a:	6b c0       	rjmp	.+214    	; 0x6b02 <vTaskIncrementTick+0x198>
    6a2c:	e0 91 96 05 	lds	r30, 0x0596
    6a30:	f0 91 97 05 	lds	r31, 0x0597
    6a34:	80 81       	ld	r24, Z
    6a36:	88 23       	and	r24, r24
    6a38:	39 f4       	brne	.+14     	; 0x6a48 <vTaskIncrementTick+0xde>
    6a3a:	8f ef       	ldi	r24, 0xFF	; 255
    6a3c:	9f ef       	ldi	r25, 0xFF	; 255
    6a3e:	90 93 08 01 	sts	0x0108, r25
    6a42:	80 93 07 01 	sts	0x0107, r24
    6a46:	5d c0       	rjmp	.+186    	; 0x6b02 <vTaskIncrementTick+0x198>
    6a48:	e0 91 96 05 	lds	r30, 0x0596
    6a4c:	f0 91 97 05 	lds	r31, 0x0597
    6a50:	05 80       	ldd	r0, Z+5	; 0x05
    6a52:	f6 81       	ldd	r31, Z+6	; 0x06
    6a54:	e0 2d       	mov	r30, r0
    6a56:	86 81       	ldd	r24, Z+6	; 0x06
    6a58:	97 81       	ldd	r25, Z+7	; 0x07
    6a5a:	9e 83       	std	Y+6, r25	; 0x06
    6a5c:	8d 83       	std	Y+5, r24	; 0x05
    6a5e:	ed 81       	ldd	r30, Y+5	; 0x05
    6a60:	fe 81       	ldd	r31, Y+6	; 0x06
    6a62:	82 81       	ldd	r24, Z+2	; 0x02
    6a64:	93 81       	ldd	r25, Z+3	; 0x03
    6a66:	9a 83       	std	Y+2, r25	; 0x02
    6a68:	89 83       	std	Y+1, r24	; 0x01
    6a6a:	20 91 5f 05 	lds	r18, 0x055F
    6a6e:	30 91 60 05 	lds	r19, 0x0560
    6a72:	89 81       	ldd	r24, Y+1	; 0x01
    6a74:	9a 81       	ldd	r25, Y+2	; 0x02
    6a76:	28 17       	cp	r18, r24
    6a78:	39 07       	cpc	r19, r25
    6a7a:	38 f4       	brcc	.+14     	; 0x6a8a <vTaskIncrementTick+0x120>
    6a7c:	89 81       	ldd	r24, Y+1	; 0x01
    6a7e:	9a 81       	ldd	r25, Y+2	; 0x02
    6a80:	90 93 08 01 	sts	0x0108, r25
    6a84:	80 93 07 01 	sts	0x0107, r24
    6a88:	3c c0       	rjmp	.+120    	; 0x6b02 <vTaskIncrementTick+0x198>
    6a8a:	8d 81       	ldd	r24, Y+5	; 0x05
    6a8c:	9e 81       	ldd	r25, Y+6	; 0x06
    6a8e:	02 96       	adiw	r24, 0x02	; 2
    6a90:	0e 94 f3 29 	call	0x53e6	; 0x53e6 <vListRemove>
    6a94:	ed 81       	ldd	r30, Y+5	; 0x05
    6a96:	fe 81       	ldd	r31, Y+6	; 0x06
    6a98:	84 89       	ldd	r24, Z+20	; 0x14
    6a9a:	95 89       	ldd	r25, Z+21	; 0x15
    6a9c:	00 97       	sbiw	r24, 0x00	; 0
    6a9e:	29 f0       	breq	.+10     	; 0x6aaa <vTaskIncrementTick+0x140>
    6aa0:	8d 81       	ldd	r24, Y+5	; 0x05
    6aa2:	9e 81       	ldd	r25, Y+6	; 0x06
    6aa4:	0c 96       	adiw	r24, 0x0c	; 12
    6aa6:	0e 94 f3 29 	call	0x53e6	; 0x53e6 <vListRemove>
    6aaa:	ed 81       	ldd	r30, Y+5	; 0x05
    6aac:	fe 81       	ldd	r31, Y+6	; 0x06
    6aae:	96 89       	ldd	r25, Z+22	; 0x16
    6ab0:	80 91 62 05 	lds	r24, 0x0562
    6ab4:	89 17       	cp	r24, r25
    6ab6:	28 f4       	brcc	.+10     	; 0x6ac2 <vTaskIncrementTick+0x158>
    6ab8:	ed 81       	ldd	r30, Y+5	; 0x05
    6aba:	fe 81       	ldd	r31, Y+6	; 0x06
    6abc:	86 89       	ldd	r24, Z+22	; 0x16
    6abe:	80 93 62 05 	sts	0x0562, r24
    6ac2:	ed 81       	ldd	r30, Y+5	; 0x05
    6ac4:	fe 81       	ldd	r31, Y+6	; 0x06
    6ac6:	86 89       	ldd	r24, Z+22	; 0x16
    6ac8:	28 2f       	mov	r18, r24
    6aca:	30 e0       	ldi	r19, 0x00	; 0
    6acc:	c9 01       	movw	r24, r18
    6ace:	88 0f       	add	r24, r24
    6ad0:	99 1f       	adc	r25, r25
    6ad2:	88 0f       	add	r24, r24
    6ad4:	99 1f       	adc	r25, r25
    6ad6:	88 0f       	add	r24, r24
    6ad8:	99 1f       	adc	r25, r25
    6ada:	82 0f       	add	r24, r18
    6adc:	93 1f       	adc	r25, r19
    6ade:	ac 01       	movw	r20, r24
    6ae0:	47 59       	subi	r20, 0x97	; 151
    6ae2:	5a 4f       	sbci	r21, 0xFA	; 250
    6ae4:	8d 81       	ldd	r24, Y+5	; 0x05
    6ae6:	9e 81       	ldd	r25, Y+6	; 0x06
    6ae8:	9c 01       	movw	r18, r24
    6aea:	2e 5f       	subi	r18, 0xFE	; 254
    6aec:	3f 4f       	sbci	r19, 0xFF	; 255
    6aee:	ca 01       	movw	r24, r20
    6af0:	b9 01       	movw	r22, r18
    6af2:	0e 94 3b 29 	call	0x5276	; 0x5276 <vListInsertEnd>
    6af6:	9a cf       	rjmp	.-204    	; 0x6a2c <vTaskIncrementTick+0xc2>
	}
	else
	{
		++uxMissedTicks;
    6af8:	80 91 65 05 	lds	r24, 0x0565
    6afc:	8f 5f       	subi	r24, 0xFF	; 255
    6afe:	80 93 65 05 	sts	0x0565, r24
		}
	}
	#endif

	traceTASK_INCREMENT_TICK( xTickCount );
}
    6b02:	26 96       	adiw	r28, 0x06	; 6
    6b04:	0f b6       	in	r0, 0x3f	; 63
    6b06:	f8 94       	cli
    6b08:	de bf       	out	0x3e, r29	; 62
    6b0a:	0f be       	out	0x3f, r0	; 63
    6b0c:	cd bf       	out	0x3d, r28	; 61
    6b0e:	cf 91       	pop	r28
    6b10:	df 91       	pop	r29
    6b12:	08 95       	ret

00006b14 <vTaskSwitchContext>:

#endif
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
    6b14:	df 93       	push	r29
    6b16:	cf 93       	push	r28
    6b18:	00 d0       	rcall	.+0      	; 0x6b1a <vTaskSwitchContext+0x6>
    6b1a:	cd b7       	in	r28, 0x3d	; 61
    6b1c:	de b7       	in	r29, 0x3e	; 62
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
    6b1e:	80 91 64 05 	lds	r24, 0x0564
    6b22:	88 23       	and	r24, r24
    6b24:	49 f0       	breq	.+18     	; 0x6b38 <vTaskSwitchContext+0x24>
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xMissedYield = pdTRUE;
    6b26:	81 e0       	ldi	r24, 0x01	; 1
    6b28:	80 93 66 05 	sts	0x0566, r24
    6b2c:	54 c0       	rjmp	.+168    	; 0x6bd6 <vTaskSwitchContext+0xc2>
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
		{
			configASSERT( uxTopReadyPriority );
			--uxTopReadyPriority;
    6b2e:	80 91 62 05 	lds	r24, 0x0562
    6b32:	81 50       	subi	r24, 0x01	; 1
    6b34:	80 93 62 05 	sts	0x0562, r24
	
		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
    6b38:	80 91 62 05 	lds	r24, 0x0562
    6b3c:	28 2f       	mov	r18, r24
    6b3e:	30 e0       	ldi	r19, 0x00	; 0
    6b40:	c9 01       	movw	r24, r18
    6b42:	88 0f       	add	r24, r24
    6b44:	99 1f       	adc	r25, r25
    6b46:	88 0f       	add	r24, r24
    6b48:	99 1f       	adc	r25, r25
    6b4a:	88 0f       	add	r24, r24
    6b4c:	99 1f       	adc	r25, r25
    6b4e:	82 0f       	add	r24, r18
    6b50:	93 1f       	adc	r25, r19
    6b52:	fc 01       	movw	r30, r24
    6b54:	e7 59       	subi	r30, 0x97	; 151
    6b56:	fa 4f       	sbci	r31, 0xFA	; 250
    6b58:	80 81       	ld	r24, Z
    6b5a:	88 23       	and	r24, r24
    6b5c:	41 f3       	breq	.-48     	; 0x6b2e <vTaskSwitchContext+0x1a>
			--uxTopReadyPriority;
		}
	
		/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the tasks of the
		same priority get an equal share of the processor time. */
		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );
    6b5e:	80 91 62 05 	lds	r24, 0x0562
    6b62:	28 2f       	mov	r18, r24
    6b64:	30 e0       	ldi	r19, 0x00	; 0
    6b66:	c9 01       	movw	r24, r18
    6b68:	88 0f       	add	r24, r24
    6b6a:	99 1f       	adc	r25, r25
    6b6c:	88 0f       	add	r24, r24
    6b6e:	99 1f       	adc	r25, r25
    6b70:	88 0f       	add	r24, r24
    6b72:	99 1f       	adc	r25, r25
    6b74:	82 0f       	add	r24, r18
    6b76:	93 1f       	adc	r25, r19
    6b78:	87 59       	subi	r24, 0x97	; 151
    6b7a:	9a 4f       	sbci	r25, 0xFA	; 250
    6b7c:	9a 83       	std	Y+2, r25	; 0x02
    6b7e:	89 83       	std	Y+1, r24	; 0x01
    6b80:	e9 81       	ldd	r30, Y+1	; 0x01
    6b82:	fa 81       	ldd	r31, Y+2	; 0x02
    6b84:	01 80       	ldd	r0, Z+1	; 0x01
    6b86:	f2 81       	ldd	r31, Z+2	; 0x02
    6b88:	e0 2d       	mov	r30, r0
    6b8a:	82 81       	ldd	r24, Z+2	; 0x02
    6b8c:	93 81       	ldd	r25, Z+3	; 0x03
    6b8e:	e9 81       	ldd	r30, Y+1	; 0x01
    6b90:	fa 81       	ldd	r31, Y+2	; 0x02
    6b92:	92 83       	std	Z+2, r25	; 0x02
    6b94:	81 83       	std	Z+1, r24	; 0x01
    6b96:	e9 81       	ldd	r30, Y+1	; 0x01
    6b98:	fa 81       	ldd	r31, Y+2	; 0x02
    6b9a:	21 81       	ldd	r18, Z+1	; 0x01
    6b9c:	32 81       	ldd	r19, Z+2	; 0x02
    6b9e:	89 81       	ldd	r24, Y+1	; 0x01
    6ba0:	9a 81       	ldd	r25, Y+2	; 0x02
    6ba2:	03 96       	adiw	r24, 0x03	; 3
    6ba4:	28 17       	cp	r18, r24
    6ba6:	39 07       	cpc	r19, r25
    6ba8:	59 f4       	brne	.+22     	; 0x6bc0 <vTaskSwitchContext+0xac>
    6baa:	e9 81       	ldd	r30, Y+1	; 0x01
    6bac:	fa 81       	ldd	r31, Y+2	; 0x02
    6bae:	01 80       	ldd	r0, Z+1	; 0x01
    6bb0:	f2 81       	ldd	r31, Z+2	; 0x02
    6bb2:	e0 2d       	mov	r30, r0
    6bb4:	82 81       	ldd	r24, Z+2	; 0x02
    6bb6:	93 81       	ldd	r25, Z+3	; 0x03
    6bb8:	e9 81       	ldd	r30, Y+1	; 0x01
    6bba:	fa 81       	ldd	r31, Y+2	; 0x02
    6bbc:	92 83       	std	Z+2, r25	; 0x02
    6bbe:	81 83       	std	Z+1, r24	; 0x01
    6bc0:	e9 81       	ldd	r30, Y+1	; 0x01
    6bc2:	fa 81       	ldd	r31, Y+2	; 0x02
    6bc4:	01 80       	ldd	r0, Z+1	; 0x01
    6bc6:	f2 81       	ldd	r31, Z+2	; 0x02
    6bc8:	e0 2d       	mov	r30, r0
    6bca:	86 81       	ldd	r24, Z+6	; 0x06
    6bcc:	97 81       	ldd	r25, Z+7	; 0x07
    6bce:	90 93 5c 05 	sts	0x055C, r25
    6bd2:	80 93 5b 05 	sts	0x055B, r24
	
		traceTASK_SWITCHED_IN();
		vWriteTraceToBuffer();
	}
}
    6bd6:	0f 90       	pop	r0
    6bd8:	0f 90       	pop	r0
    6bda:	cf 91       	pop	r28
    6bdc:	df 91       	pop	r29
    6bde:	08 95       	ret

00006be0 <vTaskPlaceOnEventList>:
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( const xList * const pxEventList, portTickType xTicksToWait )
{
    6be0:	df 93       	push	r29
    6be2:	cf 93       	push	r28
    6be4:	00 d0       	rcall	.+0      	; 0x6be6 <vTaskPlaceOnEventList+0x6>
    6be6:	00 d0       	rcall	.+0      	; 0x6be8 <vTaskPlaceOnEventList+0x8>
    6be8:	00 d0       	rcall	.+0      	; 0x6bea <vTaskPlaceOnEventList+0xa>
    6bea:	cd b7       	in	r28, 0x3d	; 61
    6bec:	de b7       	in	r29, 0x3e	; 62
    6bee:	9c 83       	std	Y+4, r25	; 0x04
    6bf0:	8b 83       	std	Y+3, r24	; 0x03
    6bf2:	7e 83       	std	Y+6, r23	; 0x06
    6bf4:	6d 83       	std	Y+5, r22	; 0x05
	SCHEDULER SUSPENDED. */

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event. */
	vListInsert( ( xList * ) pxEventList, ( xListItem * ) &( pxCurrentTCB->xEventListItem ) );
    6bf6:	4b 81       	ldd	r20, Y+3	; 0x03
    6bf8:	5c 81       	ldd	r21, Y+4	; 0x04
    6bfa:	80 91 5b 05 	lds	r24, 0x055B
    6bfe:	90 91 5c 05 	lds	r25, 0x055C
    6c02:	9c 01       	movw	r18, r24
    6c04:	24 5f       	subi	r18, 0xF4	; 244
    6c06:	3f 4f       	sbci	r19, 0xFF	; 255
    6c08:	ca 01       	movw	r24, r20
    6c0a:	b9 01       	movw	r22, r18
    6c0c:	0e 94 87 29 	call	0x530e	; 0x530e <vListInsert>

	/* We must remove ourselves from the ready list before adding ourselves
	to the blocked list as the same list item is used for both lists.  We have
	exclusive access to the ready lists as the scheduler is locked. */
	vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    6c10:	80 91 5b 05 	lds	r24, 0x055B
    6c14:	90 91 5c 05 	lds	r25, 0x055C
    6c18:	02 96       	adiw	r24, 0x02	; 2
    6c1a:	0e 94 f3 29 	call	0x53e6	; 0x53e6 <vListRemove>
	}
	#else
	{
			/* Calculate the time at which the task should be woken if the event does
			not occur.  This may overflow but this doesn't matter. */
			xTimeToWake = xTickCount + xTicksToWait;
    6c1e:	20 91 5f 05 	lds	r18, 0x055F
    6c22:	30 91 60 05 	lds	r19, 0x0560
    6c26:	8d 81       	ldd	r24, Y+5	; 0x05
    6c28:	9e 81       	ldd	r25, Y+6	; 0x06
    6c2a:	82 0f       	add	r24, r18
    6c2c:	93 1f       	adc	r25, r19
    6c2e:	9a 83       	std	Y+2, r25	; 0x02
    6c30:	89 83       	std	Y+1, r24	; 0x01
			prvAddCurrentTaskToDelayedList( xTimeToWake );
    6c32:	89 81       	ldd	r24, Y+1	; 0x01
    6c34:	9a 81       	ldd	r25, Y+2	; 0x02
    6c36:	0e 94 ea 37 	call	0x6fd4	; 0x6fd4 <prvAddCurrentTaskToDelayedList>
	}
	#endif
}
    6c3a:	26 96       	adiw	r28, 0x06	; 6
    6c3c:	0f b6       	in	r0, 0x3f	; 63
    6c3e:	f8 94       	cli
    6c40:	de bf       	out	0x3e, r29	; 62
    6c42:	0f be       	out	0x3f, r0	; 63
    6c44:	cd bf       	out	0x3d, r28	; 61
    6c46:	cf 91       	pop	r28
    6c48:	df 91       	pop	r29
    6c4a:	08 95       	ret

00006c4c <xTaskRemoveFromEventList>:
	
#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xTaskRemoveFromEventList( const xList * const pxEventList )
{
    6c4c:	df 93       	push	r29
    6c4e:	cf 93       	push	r28
    6c50:	00 d0       	rcall	.+0      	; 0x6c52 <xTaskRemoveFromEventList+0x6>
    6c52:	00 d0       	rcall	.+0      	; 0x6c54 <xTaskRemoveFromEventList+0x8>
    6c54:	0f 92       	push	r0
    6c56:	cd b7       	in	r28, 0x3d	; 61
    6c58:	de b7       	in	r29, 0x3e	; 62
    6c5a:	9d 83       	std	Y+5, r25	; 0x05
    6c5c:	8c 83       	std	Y+4, r24	; 0x04
	get called - the lock count on the queue will get modified instead.  This
	means we can always expect exclusive access to the event list here.
	
	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
    6c5e:	ec 81       	ldd	r30, Y+4	; 0x04
    6c60:	fd 81       	ldd	r31, Y+5	; 0x05
    6c62:	05 80       	ldd	r0, Z+5	; 0x05
    6c64:	f6 81       	ldd	r31, Z+6	; 0x06
    6c66:	e0 2d       	mov	r30, r0
    6c68:	86 81       	ldd	r24, Z+6	; 0x06
    6c6a:	97 81       	ldd	r25, Z+7	; 0x07
    6c6c:	9b 83       	std	Y+3, r25	; 0x03
    6c6e:	8a 83       	std	Y+2, r24	; 0x02
	configASSERT( pxUnblockedTCB );
	vListRemove( &( pxUnblockedTCB->xEventListItem ) );
    6c70:	8a 81       	ldd	r24, Y+2	; 0x02
    6c72:	9b 81       	ldd	r25, Y+3	; 0x03
    6c74:	0c 96       	adiw	r24, 0x0c	; 12
    6c76:	0e 94 f3 29 	call	0x53e6	; 0x53e6 <vListRemove>

	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    6c7a:	80 91 64 05 	lds	r24, 0x0564
    6c7e:	88 23       	and	r24, r24
    6c80:	61 f5       	brne	.+88     	; 0x6cda <xTaskRemoveFromEventList+0x8e>
	{
		vListRemove( &( pxUnblockedTCB->xGenericListItem ) );
    6c82:	8a 81       	ldd	r24, Y+2	; 0x02
    6c84:	9b 81       	ldd	r25, Y+3	; 0x03
    6c86:	02 96       	adiw	r24, 0x02	; 2
    6c88:	0e 94 f3 29 	call	0x53e6	; 0x53e6 <vListRemove>
		prvAddTaskToReadyQueue( pxUnblockedTCB );
    6c8c:	ea 81       	ldd	r30, Y+2	; 0x02
    6c8e:	fb 81       	ldd	r31, Y+3	; 0x03
    6c90:	96 89       	ldd	r25, Z+22	; 0x16
    6c92:	80 91 62 05 	lds	r24, 0x0562
    6c96:	89 17       	cp	r24, r25
    6c98:	28 f4       	brcc	.+10     	; 0x6ca4 <xTaskRemoveFromEventList+0x58>
    6c9a:	ea 81       	ldd	r30, Y+2	; 0x02
    6c9c:	fb 81       	ldd	r31, Y+3	; 0x03
    6c9e:	86 89       	ldd	r24, Z+22	; 0x16
    6ca0:	80 93 62 05 	sts	0x0562, r24
    6ca4:	ea 81       	ldd	r30, Y+2	; 0x02
    6ca6:	fb 81       	ldd	r31, Y+3	; 0x03
    6ca8:	86 89       	ldd	r24, Z+22	; 0x16
    6caa:	28 2f       	mov	r18, r24
    6cac:	30 e0       	ldi	r19, 0x00	; 0
    6cae:	c9 01       	movw	r24, r18
    6cb0:	88 0f       	add	r24, r24
    6cb2:	99 1f       	adc	r25, r25
    6cb4:	88 0f       	add	r24, r24
    6cb6:	99 1f       	adc	r25, r25
    6cb8:	88 0f       	add	r24, r24
    6cba:	99 1f       	adc	r25, r25
    6cbc:	82 0f       	add	r24, r18
    6cbe:	93 1f       	adc	r25, r19
    6cc0:	ac 01       	movw	r20, r24
    6cc2:	47 59       	subi	r20, 0x97	; 151
    6cc4:	5a 4f       	sbci	r21, 0xFA	; 250
    6cc6:	8a 81       	ldd	r24, Y+2	; 0x02
    6cc8:	9b 81       	ldd	r25, Y+3	; 0x03
    6cca:	9c 01       	movw	r18, r24
    6ccc:	2e 5f       	subi	r18, 0xFE	; 254
    6cce:	3f 4f       	sbci	r19, 0xFF	; 255
    6cd0:	ca 01       	movw	r24, r20
    6cd2:	b9 01       	movw	r22, r18
    6cd4:	0e 94 3b 29 	call	0x5276	; 0x5276 <vListInsertEnd>
    6cd8:	0a c0       	rjmp	.+20     	; 0x6cee <xTaskRemoveFromEventList+0xa2>
	}
	else
	{
		/* We cannot access the delayed or ready lists, so will hold this
		task pending until the scheduler is resumed. */
		vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
    6cda:	8a 81       	ldd	r24, Y+2	; 0x02
    6cdc:	9b 81       	ldd	r25, Y+3	; 0x03
    6cde:	9c 01       	movw	r18, r24
    6ce0:	24 5f       	subi	r18, 0xF4	; 244
    6ce2:	3f 4f       	sbci	r19, 0xFF	; 255
    6ce4:	8a e9       	ldi	r24, 0x9A	; 154
    6ce6:	95 e0       	ldi	r25, 0x05	; 5
    6ce8:	b9 01       	movw	r22, r18
    6cea:	0e 94 3b 29 	call	0x5276	; 0x5276 <vListInsertEnd>
	}

	if( pxUnblockedTCB->uxPriority >= pxCurrentTCB->uxPriority )
    6cee:	ea 81       	ldd	r30, Y+2	; 0x02
    6cf0:	fb 81       	ldd	r31, Y+3	; 0x03
    6cf2:	96 89       	ldd	r25, Z+22	; 0x16
    6cf4:	e0 91 5b 05 	lds	r30, 0x055B
    6cf8:	f0 91 5c 05 	lds	r31, 0x055C
    6cfc:	86 89       	ldd	r24, Z+22	; 0x16
    6cfe:	98 17       	cp	r25, r24
    6d00:	18 f0       	brcs	.+6      	; 0x6d08 <xTaskRemoveFromEventList+0xbc>
	{
		/* Return true if the task removed from the event list has
		a higher priority than the calling task.  This allows
		the calling task to know if it should force a context
		switch now. */
		xReturn = pdTRUE;
    6d02:	81 e0       	ldi	r24, 0x01	; 1
    6d04:	89 83       	std	Y+1, r24	; 0x01
    6d06:	01 c0       	rjmp	.+2      	; 0x6d0a <xTaskRemoveFromEventList+0xbe>
	}
	else
	{
		xReturn = pdFALSE;
    6d08:	19 82       	std	Y+1, r1	; 0x01
	}

	return xReturn;
    6d0a:	89 81       	ldd	r24, Y+1	; 0x01
}
    6d0c:	0f 90       	pop	r0
    6d0e:	0f 90       	pop	r0
    6d10:	0f 90       	pop	r0
    6d12:	0f 90       	pop	r0
    6d14:	0f 90       	pop	r0
    6d16:	cf 91       	pop	r28
    6d18:	df 91       	pop	r29
    6d1a:	08 95       	ret

00006d1c <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( xTimeOutType * const pxTimeOut )
{
    6d1c:	df 93       	push	r29
    6d1e:	cf 93       	push	r28
    6d20:	00 d0       	rcall	.+0      	; 0x6d22 <vTaskSetTimeOutState+0x6>
    6d22:	cd b7       	in	r28, 0x3d	; 61
    6d24:	de b7       	in	r29, 0x3e	; 62
    6d26:	9a 83       	std	Y+2, r25	; 0x02
    6d28:	89 83       	std	Y+1, r24	; 0x01
	configASSERT( pxTimeOut );
	pxTimeOut->xOverflowCount = xNumOfOverflows;
    6d2a:	80 91 67 05 	lds	r24, 0x0567
    6d2e:	e9 81       	ldd	r30, Y+1	; 0x01
    6d30:	fa 81       	ldd	r31, Y+2	; 0x02
    6d32:	80 83       	st	Z, r24
	pxTimeOut->xTimeOnEntering = xTickCount;
    6d34:	80 91 5f 05 	lds	r24, 0x055F
    6d38:	90 91 60 05 	lds	r25, 0x0560
    6d3c:	e9 81       	ldd	r30, Y+1	; 0x01
    6d3e:	fa 81       	ldd	r31, Y+2	; 0x02
    6d40:	92 83       	std	Z+2, r25	; 0x02
    6d42:	81 83       	std	Z+1, r24	; 0x01
}
    6d44:	0f 90       	pop	r0
    6d46:	0f 90       	pop	r0
    6d48:	cf 91       	pop	r28
    6d4a:	df 91       	pop	r29
    6d4c:	08 95       	ret

00006d4e <xTaskCheckForTimeOut>:
/*-----------------------------------------------------------*/

portBASE_TYPE xTaskCheckForTimeOut( xTimeOutType * const pxTimeOut, portTickType * const pxTicksToWait )
{
    6d4e:	df 93       	push	r29
    6d50:	cf 93       	push	r28
    6d52:	00 d0       	rcall	.+0      	; 0x6d54 <xTaskCheckForTimeOut+0x6>
    6d54:	00 d0       	rcall	.+0      	; 0x6d56 <xTaskCheckForTimeOut+0x8>
    6d56:	0f 92       	push	r0
    6d58:	cd b7       	in	r28, 0x3d	; 61
    6d5a:	de b7       	in	r29, 0x3e	; 62
    6d5c:	9b 83       	std	Y+3, r25	; 0x03
    6d5e:	8a 83       	std	Y+2, r24	; 0x02
    6d60:	7d 83       	std	Y+5, r23	; 0x05
    6d62:	6c 83       	std	Y+4, r22	; 0x04
portBASE_TYPE xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
    6d64:	0f b6       	in	r0, 0x3f	; 63
    6d66:	f8 94       	cli
    6d68:	0f 92       	push	r0
				xReturn = pdFALSE;
			}
			else /* We are not blocking indefinitely, perform the checks below. */
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( ( portTickType ) xTickCount >= ( portTickType ) pxTimeOut->xTimeOnEntering ) )
    6d6a:	ea 81       	ldd	r30, Y+2	; 0x02
    6d6c:	fb 81       	ldd	r31, Y+3	; 0x03
    6d6e:	90 81       	ld	r25, Z
    6d70:	80 91 67 05 	lds	r24, 0x0567
    6d74:	98 17       	cp	r25, r24
    6d76:	71 f0       	breq	.+28     	; 0x6d94 <xTaskCheckForTimeOut+0x46>
    6d78:	ea 81       	ldd	r30, Y+2	; 0x02
    6d7a:	fb 81       	ldd	r31, Y+3	; 0x03
    6d7c:	21 81       	ldd	r18, Z+1	; 0x01
    6d7e:	32 81       	ldd	r19, Z+2	; 0x02
    6d80:	80 91 5f 05 	lds	r24, 0x055F
    6d84:	90 91 60 05 	lds	r25, 0x0560
    6d88:	82 17       	cp	r24, r18
    6d8a:	93 07       	cpc	r25, r19
    6d8c:	18 f0       	brcs	.+6      	; 0x6d94 <xTaskCheckForTimeOut+0x46>
		{
			/* The tick count is greater than the time at which vTaskSetTimeout()
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
    6d8e:	81 e0       	ldi	r24, 0x01	; 1
    6d90:	89 83       	std	Y+1, r24	; 0x01
    6d92:	2f c0       	rjmp	.+94     	; 0x6df2 <xTaskCheckForTimeOut+0xa4>
		}
		else if( ( ( portTickType ) ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering ) ) < ( portTickType ) *pxTicksToWait )
    6d94:	20 91 5f 05 	lds	r18, 0x055F
    6d98:	30 91 60 05 	lds	r19, 0x0560
    6d9c:	ea 81       	ldd	r30, Y+2	; 0x02
    6d9e:	fb 81       	ldd	r31, Y+3	; 0x03
    6da0:	81 81       	ldd	r24, Z+1	; 0x01
    6da2:	92 81       	ldd	r25, Z+2	; 0x02
    6da4:	28 1b       	sub	r18, r24
    6da6:	39 0b       	sbc	r19, r25
    6da8:	ec 81       	ldd	r30, Y+4	; 0x04
    6daa:	fd 81       	ldd	r31, Y+5	; 0x05
    6dac:	80 81       	ld	r24, Z
    6dae:	91 81       	ldd	r25, Z+1	; 0x01
    6db0:	28 17       	cp	r18, r24
    6db2:	39 07       	cpc	r19, r25
    6db4:	e0 f4       	brcc	.+56     	; 0x6dee <xTaskCheckForTimeOut+0xa0>
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering );
    6db6:	ec 81       	ldd	r30, Y+4	; 0x04
    6db8:	fd 81       	ldd	r31, Y+5	; 0x05
    6dba:	40 81       	ld	r20, Z
    6dbc:	51 81       	ldd	r21, Z+1	; 0x01
    6dbe:	ea 81       	ldd	r30, Y+2	; 0x02
    6dc0:	fb 81       	ldd	r31, Y+3	; 0x03
    6dc2:	21 81       	ldd	r18, Z+1	; 0x01
    6dc4:	32 81       	ldd	r19, Z+2	; 0x02
    6dc6:	80 91 5f 05 	lds	r24, 0x055F
    6dca:	90 91 60 05 	lds	r25, 0x0560
    6dce:	b9 01       	movw	r22, r18
    6dd0:	68 1b       	sub	r22, r24
    6dd2:	79 0b       	sbc	r23, r25
    6dd4:	cb 01       	movw	r24, r22
    6dd6:	84 0f       	add	r24, r20
    6dd8:	95 1f       	adc	r25, r21
    6dda:	ec 81       	ldd	r30, Y+4	; 0x04
    6ddc:	fd 81       	ldd	r31, Y+5	; 0x05
    6dde:	91 83       	std	Z+1, r25	; 0x01
    6de0:	80 83       	st	Z, r24
			vTaskSetTimeOutState( pxTimeOut );
    6de2:	8a 81       	ldd	r24, Y+2	; 0x02
    6de4:	9b 81       	ldd	r25, Y+3	; 0x03
    6de6:	0e 94 8e 36 	call	0x6d1c	; 0x6d1c <vTaskSetTimeOutState>
			xReturn = pdFALSE;
    6dea:	19 82       	std	Y+1, r1	; 0x01
    6dec:	02 c0       	rjmp	.+4      	; 0x6df2 <xTaskCheckForTimeOut+0xa4>
		}
		else
		{
			xReturn = pdTRUE;
    6dee:	81 e0       	ldi	r24, 0x01	; 1
    6df0:	89 83       	std	Y+1, r24	; 0x01
		}
	}
	taskEXIT_CRITICAL();
    6df2:	0f 90       	pop	r0
    6df4:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    6df6:	89 81       	ldd	r24, Y+1	; 0x01
}
    6df8:	0f 90       	pop	r0
    6dfa:	0f 90       	pop	r0
    6dfc:	0f 90       	pop	r0
    6dfe:	0f 90       	pop	r0
    6e00:	0f 90       	pop	r0
    6e02:	cf 91       	pop	r28
    6e04:	df 91       	pop	r29
    6e06:	08 95       	ret

00006e08 <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
    6e08:	df 93       	push	r29
    6e0a:	cf 93       	push	r28
    6e0c:	cd b7       	in	r28, 0x3d	; 61
    6e0e:	de b7       	in	r29, 0x3e	; 62
	xMissedYield = pdTRUE;
    6e10:	81 e0       	ldi	r24, 0x01	; 1
    6e12:	80 93 66 05 	sts	0x0566, r24
}
    6e16:	cf 91       	pop	r28
    6e18:	df 91       	pop	r29
    6e1a:	08 95       	ret

00006e1c <prvIdleTask>:
 *
 * void prvIdleTask( void *pvParameters );
 *
 */
static portTASK_FUNCTION( prvIdleTask, pvParameters )
{
    6e1c:	df 93       	push	r29
    6e1e:	cf 93       	push	r28
    6e20:	00 d0       	rcall	.+0      	; 0x6e22 <prvIdleTask+0x6>
    6e22:	cd b7       	in	r28, 0x3d	; 61
    6e24:	de b7       	in	r29, 0x3e	; 62
    6e26:	9a 83       	std	Y+2, r25	; 0x02
    6e28:	89 83       	std	Y+1, r24	; 0x01
	( void ) pvParameters;

	for( ;; )
	{
		/* See if any tasks have been deleted. */
		prvCheckTasksWaitingTermination();
    6e2a:	0e 94 ac 37 	call	0x6f58	; 0x6f58 <prvCheckTasksWaitingTermination>
    6e2e:	fd cf       	rjmp	.-6      	; 0x6e2a <prvIdleTask+0xe>

00006e30 <prvInitialiseTCBVariables>:
 *----------------------------------------------------------*/



static void prvInitialiseTCBVariables( tskTCB *pxTCB, const signed char * const pcName, unsigned portBASE_TYPE uxPriority, const xMemoryRegion * const xRegions, unsigned short usStackDepth )
{
    6e30:	0f 93       	push	r16
    6e32:	1f 93       	push	r17
    6e34:	df 93       	push	r29
    6e36:	cf 93       	push	r28
    6e38:	cd b7       	in	r28, 0x3d	; 61
    6e3a:	de b7       	in	r29, 0x3e	; 62
    6e3c:	29 97       	sbiw	r28, 0x09	; 9
    6e3e:	0f b6       	in	r0, 0x3f	; 63
    6e40:	f8 94       	cli
    6e42:	de bf       	out	0x3e, r29	; 62
    6e44:	0f be       	out	0x3f, r0	; 63
    6e46:	cd bf       	out	0x3d, r28	; 61
    6e48:	9a 83       	std	Y+2, r25	; 0x02
    6e4a:	89 83       	std	Y+1, r24	; 0x01
    6e4c:	7c 83       	std	Y+4, r23	; 0x04
    6e4e:	6b 83       	std	Y+3, r22	; 0x03
    6e50:	4d 83       	std	Y+5, r20	; 0x05
    6e52:	3f 83       	std	Y+7, r19	; 0x07
    6e54:	2e 83       	std	Y+6, r18	; 0x06
    6e56:	19 87       	std	Y+9, r17	; 0x09
    6e58:	08 87       	std	Y+8, r16	; 0x08
	/* Store the function name in the TCB. */
	#if configMAX_TASK_NAME_LEN > 1
	{
		/* Don't bring strncpy into the build unnecessarily. */
		strncpy( ( char * ) pxTCB->pcTaskName, ( const char * ) pcName, ( unsigned short ) configMAX_TASK_NAME_LEN );
    6e5a:	89 81       	ldd	r24, Y+1	; 0x01
    6e5c:	9a 81       	ldd	r25, Y+2	; 0x02
    6e5e:	49 96       	adiw	r24, 0x19	; 25
    6e60:	2b 81       	ldd	r18, Y+3	; 0x03
    6e62:	3c 81       	ldd	r19, Y+4	; 0x04
    6e64:	b9 01       	movw	r22, r18
    6e66:	48 e0       	ldi	r20, 0x08	; 8
    6e68:	50 e0       	ldi	r21, 0x00	; 0
    6e6a:	0e 94 05 3d 	call	0x7a0a	; 0x7a0a <strncpy>
	}
	#endif
	pxTCB->pcTaskName[ ( unsigned short ) configMAX_TASK_NAME_LEN - ( unsigned short ) 1 ] = ( signed char ) '\0';
    6e6e:	e9 81       	ldd	r30, Y+1	; 0x01
    6e70:	fa 81       	ldd	r31, Y+2	; 0x02
    6e72:	10 a2       	std	Z+32, r1	; 0x20

	/* This is used as an array index so must ensure it's not too large.  First
	remove the privilege bit if one is present. */
	if( uxPriority >= configMAX_PRIORITIES )
    6e74:	8d 81       	ldd	r24, Y+5	; 0x05
    6e76:	83 30       	cpi	r24, 0x03	; 3
    6e78:	10 f0       	brcs	.+4      	; 0x6e7e <prvInitialiseTCBVariables+0x4e>
	{
		uxPriority = configMAX_PRIORITIES - ( unsigned portBASE_TYPE ) 1U;
    6e7a:	82 e0       	ldi	r24, 0x02	; 2
    6e7c:	8d 83       	std	Y+5, r24	; 0x05
	}

	pxTCB->uxPriority = uxPriority;
    6e7e:	e9 81       	ldd	r30, Y+1	; 0x01
    6e80:	fa 81       	ldd	r31, Y+2	; 0x02
    6e82:	8d 81       	ldd	r24, Y+5	; 0x05
    6e84:	86 8b       	std	Z+22, r24	; 0x16
	{
		pxTCB->uxBasePriority = uxPriority;
	}
	#endif

	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
    6e86:	89 81       	ldd	r24, Y+1	; 0x01
    6e88:	9a 81       	ldd	r25, Y+2	; 0x02
    6e8a:	02 96       	adiw	r24, 0x02	; 2
    6e8c:	0e 94 2b 29 	call	0x5256	; 0x5256 <vListInitialiseItem>
	vListInitialiseItem( &( pxTCB->xEventListItem ) );
    6e90:	89 81       	ldd	r24, Y+1	; 0x01
    6e92:	9a 81       	ldd	r25, Y+2	; 0x02
    6e94:	0c 96       	adiw	r24, 0x0c	; 12
    6e96:	0e 94 2b 29 	call	0x5256	; 0x5256 <vListInitialiseItem>

	/* Set the pxTCB as a link back from the xListItem.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );
    6e9a:	e9 81       	ldd	r30, Y+1	; 0x01
    6e9c:	fa 81       	ldd	r31, Y+2	; 0x02
    6e9e:	89 81       	ldd	r24, Y+1	; 0x01
    6ea0:	9a 81       	ldd	r25, Y+2	; 0x02
    6ea2:	91 87       	std	Z+9, r25	; 0x09
    6ea4:	80 87       	std	Z+8, r24	; 0x08

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPriority );
    6ea6:	8d 81       	ldd	r24, Y+5	; 0x05
    6ea8:	28 2f       	mov	r18, r24
    6eaa:	30 e0       	ldi	r19, 0x00	; 0
    6eac:	83 e0       	ldi	r24, 0x03	; 3
    6eae:	90 e0       	ldi	r25, 0x00	; 0
    6eb0:	82 1b       	sub	r24, r18
    6eb2:	93 0b       	sbc	r25, r19
    6eb4:	e9 81       	ldd	r30, Y+1	; 0x01
    6eb6:	fa 81       	ldd	r31, Y+2	; 0x02
    6eb8:	95 87       	std	Z+13, r25	; 0x0d
    6eba:	84 87       	std	Z+12, r24	; 0x0c
	listSET_LIST_ITEM_OWNER( &( pxTCB->xEventListItem ), pxTCB );
    6ebc:	e9 81       	ldd	r30, Y+1	; 0x01
    6ebe:	fa 81       	ldd	r31, Y+2	; 0x02
    6ec0:	89 81       	ldd	r24, Y+1	; 0x01
    6ec2:	9a 81       	ldd	r25, Y+2	; 0x02
    6ec4:	93 8b       	std	Z+19, r25	; 0x13
    6ec6:	82 8b       	std	Z+18, r24	; 0x12
	{
		( void ) xRegions;
		( void ) usStackDepth;
	}
	#endif
}
    6ec8:	29 96       	adiw	r28, 0x09	; 9
    6eca:	0f b6       	in	r0, 0x3f	; 63
    6ecc:	f8 94       	cli
    6ece:	de bf       	out	0x3e, r29	; 62
    6ed0:	0f be       	out	0x3f, r0	; 63
    6ed2:	cd bf       	out	0x3d, r28	; 61
    6ed4:	cf 91       	pop	r28
    6ed6:	df 91       	pop	r29
    6ed8:	1f 91       	pop	r17
    6eda:	0f 91       	pop	r16
    6edc:	08 95       	ret

00006ede <prvInitialiseTaskLists>:
	}
	/*-----------------------------------------------------------*/
#endif

static void prvInitialiseTaskLists( void )
{
    6ede:	df 93       	push	r29
    6ee0:	cf 93       	push	r28
    6ee2:	0f 92       	push	r0
    6ee4:	cd b7       	in	r28, 0x3d	; 61
    6ee6:	de b7       	in	r29, 0x3e	; 62
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
    6ee8:	19 82       	std	Y+1, r1	; 0x01
    6eea:	13 c0       	rjmp	.+38     	; 0x6f12 <prvInitialiseTaskLists+0x34>
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
    6eec:	89 81       	ldd	r24, Y+1	; 0x01
    6eee:	28 2f       	mov	r18, r24
    6ef0:	30 e0       	ldi	r19, 0x00	; 0
    6ef2:	c9 01       	movw	r24, r18
    6ef4:	88 0f       	add	r24, r24
    6ef6:	99 1f       	adc	r25, r25
    6ef8:	88 0f       	add	r24, r24
    6efa:	99 1f       	adc	r25, r25
    6efc:	88 0f       	add	r24, r24
    6efe:	99 1f       	adc	r25, r25
    6f00:	82 0f       	add	r24, r18
    6f02:	93 1f       	adc	r25, r19
    6f04:	87 59       	subi	r24, 0x97	; 151
    6f06:	9a 4f       	sbci	r25, 0xFA	; 250
    6f08:	0e 94 01 29 	call	0x5202	; 0x5202 <vListInitialise>

static void prvInitialiseTaskLists( void )
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
    6f0c:	89 81       	ldd	r24, Y+1	; 0x01
    6f0e:	8f 5f       	subi	r24, 0xFF	; 255
    6f10:	89 83       	std	Y+1, r24	; 0x01
    6f12:	89 81       	ldd	r24, Y+1	; 0x01
    6f14:	83 30       	cpi	r24, 0x03	; 3
    6f16:	50 f3       	brcs	.-44     	; 0x6eec <prvInitialiseTaskLists+0xe>
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
	}

	vListInitialise( ( xList * ) &xDelayedTaskList1 );
    6f18:	84 e8       	ldi	r24, 0x84	; 132
    6f1a:	95 e0       	ldi	r25, 0x05	; 5
    6f1c:	0e 94 01 29 	call	0x5202	; 0x5202 <vListInitialise>
	vListInitialise( ( xList * ) &xDelayedTaskList2 );
    6f20:	8d e8       	ldi	r24, 0x8D	; 141
    6f22:	95 e0       	ldi	r25, 0x05	; 5
    6f24:	0e 94 01 29 	call	0x5202	; 0x5202 <vListInitialise>
	vListInitialise( ( xList * ) &xPendingReadyList );
    6f28:	8a e9       	ldi	r24, 0x9A	; 154
    6f2a:	95 e0       	ldi	r25, 0x05	; 5
    6f2c:	0e 94 01 29 	call	0x5202	; 0x5202 <vListInitialise>

	#if ( INCLUDE_vTaskDelete == 1 )
	{
		vListInitialise( ( xList * ) &xTasksWaitingTermination );
    6f30:	83 ea       	ldi	r24, 0xA3	; 163
    6f32:	95 e0       	ldi	r25, 0x05	; 5
    6f34:	0e 94 01 29 	call	0x5202	; 0x5202 <vListInitialise>
	}
	#endif

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
    6f38:	84 e8       	ldi	r24, 0x84	; 132
    6f3a:	95 e0       	ldi	r25, 0x05	; 5
    6f3c:	90 93 97 05 	sts	0x0597, r25
    6f40:	80 93 96 05 	sts	0x0596, r24
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
    6f44:	8d e8       	ldi	r24, 0x8D	; 141
    6f46:	95 e0       	ldi	r25, 0x05	; 5
    6f48:	90 93 99 05 	sts	0x0599, r25
    6f4c:	80 93 98 05 	sts	0x0598, r24
}
    6f50:	0f 90       	pop	r0
    6f52:	cf 91       	pop	r28
    6f54:	df 91       	pop	r29
    6f56:	08 95       	ret

00006f58 <prvCheckTasksWaitingTermination>:
/*-----------------------------------------------------------*/

static void prvCheckTasksWaitingTermination( void )
{
    6f58:	df 93       	push	r29
    6f5a:	cf 93       	push	r28
    6f5c:	00 d0       	rcall	.+0      	; 0x6f5e <prvCheckTasksWaitingTermination+0x6>
    6f5e:	0f 92       	push	r0
    6f60:	cd b7       	in	r28, 0x3d	; 61
    6f62:	de b7       	in	r29, 0x3e	; 62
	{
		portBASE_TYPE xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		if( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0U )
    6f64:	80 91 5d 05 	lds	r24, 0x055D
    6f68:	88 23       	and	r24, r24
    6f6a:	71 f1       	breq	.+92     	; 0x6fc8 <prvCheckTasksWaitingTermination+0x70>
		{
			vTaskSuspendAll();
    6f6c:	0e 94 ea 33 	call	0x67d4	; 0x67d4 <vTaskSuspendAll>
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
    6f70:	80 91 a3 05 	lds	r24, 0x05A3
    6f74:	1b 82       	std	Y+3, r1	; 0x03
    6f76:	88 23       	and	r24, r24
    6f78:	11 f4       	brne	.+4      	; 0x6f7e <prvCheckTasksWaitingTermination+0x26>
    6f7a:	81 e0       	ldi	r24, 0x01	; 1
    6f7c:	8b 83       	std	Y+3, r24	; 0x03
			xTaskResumeAll();
    6f7e:	0e 94 f6 33 	call	0x67ec	; 0x67ec <xTaskResumeAll>

			if( xListIsEmpty == pdFALSE )
    6f82:	8b 81       	ldd	r24, Y+3	; 0x03
    6f84:	88 23       	and	r24, r24
    6f86:	01 f5       	brne	.+64     	; 0x6fc8 <prvCheckTasksWaitingTermination+0x70>
			{
				tskTCB *pxTCB;

				taskENTER_CRITICAL();
    6f88:	0f b6       	in	r0, 0x3f	; 63
    6f8a:	f8 94       	cli
    6f8c:	0f 92       	push	r0
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( ( xList * ) &xTasksWaitingTermination ) );
    6f8e:	e0 91 a8 05 	lds	r30, 0x05A8
    6f92:	f0 91 a9 05 	lds	r31, 0x05A9
    6f96:	86 81       	ldd	r24, Z+6	; 0x06
    6f98:	97 81       	ldd	r25, Z+7	; 0x07
    6f9a:	9a 83       	std	Y+2, r25	; 0x02
    6f9c:	89 83       	std	Y+1, r24	; 0x01
					vListRemove( &( pxTCB->xGenericListItem ) );
    6f9e:	89 81       	ldd	r24, Y+1	; 0x01
    6fa0:	9a 81       	ldd	r25, Y+2	; 0x02
    6fa2:	02 96       	adiw	r24, 0x02	; 2
    6fa4:	0e 94 f3 29 	call	0x53e6	; 0x53e6 <vListRemove>
					--uxCurrentNumberOfTasks;
    6fa8:	80 91 5e 05 	lds	r24, 0x055E
    6fac:	81 50       	subi	r24, 0x01	; 1
    6fae:	80 93 5e 05 	sts	0x055E, r24
					--uxTasksDeleted;
    6fb2:	80 91 5d 05 	lds	r24, 0x055D
    6fb6:	81 50       	subi	r24, 0x01	; 1
    6fb8:	80 93 5d 05 	sts	0x055D, r24
				}
				taskEXIT_CRITICAL();
    6fbc:	0f 90       	pop	r0
    6fbe:	0f be       	out	0x3f, r0	; 63

				prvDeleteTCB( pxTCB );
    6fc0:	89 81       	ldd	r24, Y+1	; 0x01
    6fc2:	9a 81       	ldd	r25, Y+2	; 0x02
    6fc4:	0e 94 83 38 	call	0x7106	; 0x7106 <prvDeleteTCB>
			}
		}
	}
	#endif
}
    6fc8:	0f 90       	pop	r0
    6fca:	0f 90       	pop	r0
    6fcc:	0f 90       	pop	r0
    6fce:	cf 91       	pop	r28
    6fd0:	df 91       	pop	r29
    6fd2:	08 95       	ret

00006fd4 <prvAddCurrentTaskToDelayedList>:
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( portTickType xTimeToWake )
{
    6fd4:	df 93       	push	r29
    6fd6:	cf 93       	push	r28
    6fd8:	00 d0       	rcall	.+0      	; 0x6fda <prvAddCurrentTaskToDelayedList+0x6>
    6fda:	cd b7       	in	r28, 0x3d	; 61
    6fdc:	de b7       	in	r29, 0x3e	; 62
    6fde:	9a 83       	std	Y+2, r25	; 0x02
    6fe0:	89 83       	std	Y+1, r24	; 0x01
	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
    6fe2:	e0 91 5b 05 	lds	r30, 0x055B
    6fe6:	f0 91 5c 05 	lds	r31, 0x055C
    6fea:	89 81       	ldd	r24, Y+1	; 0x01
    6fec:	9a 81       	ldd	r25, Y+2	; 0x02
    6fee:	93 83       	std	Z+3, r25	; 0x03
    6ff0:	82 83       	std	Z+2, r24	; 0x02

	if( xTimeToWake < xTickCount )
    6ff2:	20 91 5f 05 	lds	r18, 0x055F
    6ff6:	30 91 60 05 	lds	r19, 0x0560
    6ffa:	89 81       	ldd	r24, Y+1	; 0x01
    6ffc:	9a 81       	ldd	r25, Y+2	; 0x02
    6ffe:	82 17       	cp	r24, r18
    7000:	93 07       	cpc	r25, r19
    7002:	70 f4       	brcc	.+28     	; 0x7020 <prvAddCurrentTaskToDelayedList+0x4c>
	{
		/* Wake time has overflowed.  Place this item in the overflow list. */
		vListInsert( ( xList * ) pxOverflowDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    7004:	80 91 98 05 	lds	r24, 0x0598
    7008:	90 91 99 05 	lds	r25, 0x0599
    700c:	20 91 5b 05 	lds	r18, 0x055B
    7010:	30 91 5c 05 	lds	r19, 0x055C
    7014:	2e 5f       	subi	r18, 0xFE	; 254
    7016:	3f 4f       	sbci	r19, 0xFF	; 255
    7018:	b9 01       	movw	r22, r18
    701a:	0e 94 87 29 	call	0x530e	; 0x530e <vListInsert>
    701e:	1e c0       	rjmp	.+60     	; 0x705c <prvAddCurrentTaskToDelayedList+0x88>
	}
	else
	{
		/* The wake time has not overflowed, so we can use the current block list. */
		vListInsert( ( xList * ) pxDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    7020:	40 91 96 05 	lds	r20, 0x0596
    7024:	50 91 97 05 	lds	r21, 0x0597
    7028:	80 91 5b 05 	lds	r24, 0x055B
    702c:	90 91 5c 05 	lds	r25, 0x055C
    7030:	9c 01       	movw	r18, r24
    7032:	2e 5f       	subi	r18, 0xFE	; 254
    7034:	3f 4f       	sbci	r19, 0xFF	; 255
    7036:	ca 01       	movw	r24, r20
    7038:	b9 01       	movw	r22, r18
    703a:	0e 94 87 29 	call	0x530e	; 0x530e <vListInsert>

		/* If the task entering the blocked state was placed at the head of the
		list of blocked tasks then xNextTaskUnblockTime needs to be updated
		too. */
		if( xTimeToWake < xNextTaskUnblockTime )
    703e:	20 91 07 01 	lds	r18, 0x0107
    7042:	30 91 08 01 	lds	r19, 0x0108
    7046:	89 81       	ldd	r24, Y+1	; 0x01
    7048:	9a 81       	ldd	r25, Y+2	; 0x02
    704a:	82 17       	cp	r24, r18
    704c:	93 07       	cpc	r25, r19
    704e:	30 f4       	brcc	.+12     	; 0x705c <prvAddCurrentTaskToDelayedList+0x88>
		{
			xNextTaskUnblockTime = xTimeToWake;
    7050:	89 81       	ldd	r24, Y+1	; 0x01
    7052:	9a 81       	ldd	r25, Y+2	; 0x02
    7054:	90 93 08 01 	sts	0x0108, r25
    7058:	80 93 07 01 	sts	0x0107, r24
		}
	}
}
    705c:	0f 90       	pop	r0
    705e:	0f 90       	pop	r0
    7060:	cf 91       	pop	r28
    7062:	df 91       	pop	r29
    7064:	08 95       	ret

00007066 <prvAllocateTCBAndStack>:
/*-----------------------------------------------------------*/

static tskTCB *prvAllocateTCBAndStack( unsigned short usStackDepth, portSTACK_TYPE *puxStackBuffer )
{
    7066:	df 93       	push	r29
    7068:	cf 93       	push	r28
    706a:	cd b7       	in	r28, 0x3d	; 61
    706c:	de b7       	in	r29, 0x3e	; 62
    706e:	28 97       	sbiw	r28, 0x08	; 8
    7070:	0f b6       	in	r0, 0x3f	; 63
    7072:	f8 94       	cli
    7074:	de bf       	out	0x3e, r29	; 62
    7076:	0f be       	out	0x3f, r0	; 63
    7078:	cd bf       	out	0x3d, r28	; 61
    707a:	9c 83       	std	Y+4, r25	; 0x04
    707c:	8b 83       	std	Y+3, r24	; 0x03
    707e:	7e 83       	std	Y+6, r23	; 0x06
    7080:	6d 83       	std	Y+5, r22	; 0x05
tskTCB *pxNewTCB;

	/* Allocate space for the TCB.  Where the memory comes from depends on
	the implementation of the port malloc function. */
	pxNewTCB = ( tskTCB * ) pvPortMalloc( sizeof( tskTCB ) );
    7082:	81 e2       	ldi	r24, 0x21	; 33
    7084:	90 e0       	ldi	r25, 0x00	; 0
    7086:	0e 94 95 28 	call	0x512a	; 0x512a <pvPortMalloc>
    708a:	9a 83       	std	Y+2, r25	; 0x02
    708c:	89 83       	std	Y+1, r24	; 0x01

	if( pxNewTCB != NULL )
    708e:	89 81       	ldd	r24, Y+1	; 0x01
    7090:	9a 81       	ldd	r25, Y+2	; 0x02
    7092:	00 97       	sbiw	r24, 0x00	; 0
    7094:	69 f1       	breq	.+90     	; 0x70f0 <prvAllocateTCBAndStack+0x8a>
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t )usStackDepth ) * sizeof( portSTACK_TYPE ) ), puxStackBuffer );
    7096:	8d 81       	ldd	r24, Y+5	; 0x05
    7098:	9e 81       	ldd	r25, Y+6	; 0x06
    709a:	00 97       	sbiw	r24, 0x00	; 0
    709c:	39 f4       	brne	.+14     	; 0x70ac <prvAllocateTCBAndStack+0x46>
    709e:	8b 81       	ldd	r24, Y+3	; 0x03
    70a0:	9c 81       	ldd	r25, Y+4	; 0x04
    70a2:	0e 94 95 28 	call	0x512a	; 0x512a <pvPortMalloc>
    70a6:	98 87       	std	Y+8, r25	; 0x08
    70a8:	8f 83       	std	Y+7, r24	; 0x07
    70aa:	04 c0       	rjmp	.+8      	; 0x70b4 <prvAllocateTCBAndStack+0x4e>
    70ac:	8d 81       	ldd	r24, Y+5	; 0x05
    70ae:	9e 81       	ldd	r25, Y+6	; 0x06
    70b0:	98 87       	std	Y+8, r25	; 0x08
    70b2:	8f 83       	std	Y+7, r24	; 0x07
    70b4:	e9 81       	ldd	r30, Y+1	; 0x01
    70b6:	fa 81       	ldd	r31, Y+2	; 0x02
    70b8:	8f 81       	ldd	r24, Y+7	; 0x07
    70ba:	98 85       	ldd	r25, Y+8	; 0x08
    70bc:	90 8f       	std	Z+24, r25	; 0x18
    70be:	87 8b       	std	Z+23, r24	; 0x17

		if( pxNewTCB->pxStack == NULL )
    70c0:	e9 81       	ldd	r30, Y+1	; 0x01
    70c2:	fa 81       	ldd	r31, Y+2	; 0x02
    70c4:	87 89       	ldd	r24, Z+23	; 0x17
    70c6:	90 8d       	ldd	r25, Z+24	; 0x18
    70c8:	00 97       	sbiw	r24, 0x00	; 0
    70ca:	39 f4       	brne	.+14     	; 0x70da <prvAllocateTCBAndStack+0x74>
		{
			/* Could not allocate the stack.  Delete the allocated TCB. */
			vPortFree( pxNewTCB );
    70cc:	89 81       	ldd	r24, Y+1	; 0x01
    70ce:	9a 81       	ldd	r25, Y+2	; 0x02
    70d0:	0e 94 db 28 	call	0x51b6	; 0x51b6 <vPortFree>
			pxNewTCB = NULL;
    70d4:	1a 82       	std	Y+2, r1	; 0x02
    70d6:	19 82       	std	Y+1, r1	; 0x01
    70d8:	0b c0       	rjmp	.+22     	; 0x70f0 <prvAllocateTCBAndStack+0x8a>
		}
		else
		{
			/* Just to help debugging. */
			memset( pxNewTCB->pxStack, ( int ) tskSTACK_FILL_BYTE, ( size_t ) usStackDepth * sizeof( portSTACK_TYPE ) );
    70da:	e9 81       	ldd	r30, Y+1	; 0x01
    70dc:	fa 81       	ldd	r31, Y+2	; 0x02
    70de:	87 89       	ldd	r24, Z+23	; 0x17
    70e0:	90 8d       	ldd	r25, Z+24	; 0x18
    70e2:	2b 81       	ldd	r18, Y+3	; 0x03
    70e4:	3c 81       	ldd	r19, Y+4	; 0x04
    70e6:	65 ea       	ldi	r22, 0xA5	; 165
    70e8:	70 e0       	ldi	r23, 0x00	; 0
    70ea:	a9 01       	movw	r20, r18
    70ec:	0e 94 f5 3c 	call	0x79ea	; 0x79ea <memset>
		}
	}

	return pxNewTCB;
    70f0:	89 81       	ldd	r24, Y+1	; 0x01
    70f2:	9a 81       	ldd	r25, Y+2	; 0x02
}
    70f4:	28 96       	adiw	r28, 0x08	; 8
    70f6:	0f b6       	in	r0, 0x3f	; 63
    70f8:	f8 94       	cli
    70fa:	de bf       	out	0x3e, r29	; 62
    70fc:	0f be       	out	0x3f, r0	; 63
    70fe:	cd bf       	out	0x3d, r28	; 61
    7100:	cf 91       	pop	r28
    7102:	df 91       	pop	r29
    7104:	08 95       	ret

00007106 <prvDeleteTCB>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

	static void prvDeleteTCB( tskTCB *pxTCB )
	{
    7106:	df 93       	push	r29
    7108:	cf 93       	push	r28
    710a:	00 d0       	rcall	.+0      	; 0x710c <prvDeleteTCB+0x6>
    710c:	cd b7       	in	r28, 0x3d	; 61
    710e:	de b7       	in	r29, 0x3e	; 62
    7110:	9a 83       	std	Y+2, r25	; 0x02
    7112:	89 83       	std	Y+1, r24	; 0x01
		/* Free up the memory allocated by the scheduler for the task.  It is up to
		the task to free any memory allocated at the application level. */
		vPortFreeAligned( pxTCB->pxStack );
    7114:	e9 81       	ldd	r30, Y+1	; 0x01
    7116:	fa 81       	ldd	r31, Y+2	; 0x02
    7118:	87 89       	ldd	r24, Z+23	; 0x17
    711a:	90 8d       	ldd	r25, Z+24	; 0x18
    711c:	0e 94 db 28 	call	0x51b6	; 0x51b6 <vPortFree>
		vPortFree( pxTCB );
    7120:	89 81       	ldd	r24, Y+1	; 0x01
    7122:	9a 81       	ldd	r25, Y+2	; 0x02
    7124:	0e 94 db 28 	call	0x51b6	; 0x51b6 <vPortFree>
	}
    7128:	0f 90       	pop	r0
    712a:	0f 90       	pop	r0
    712c:	cf 91       	pop	r28
    712e:	df 91       	pop	r29
    7130:	08 95       	ret

00007132 <main>:



s8 i=30,flag=0;
void main(void)
{
    7132:	0f 93       	push	r16
    7134:	1f 93       	push	r17
    7136:	df 93       	push	r29
    7138:	cf 93       	push	r28
    713a:	cd b7       	in	r28, 0x3d	; 61
    713c:	de b7       	in	r29, 0x3e	; 62
    713e:	c8 54       	subi	r28, 0x48	; 72
    7140:	d0 40       	sbci	r29, 0x00	; 0
    7142:	0f b6       	in	r0, 0x3f	; 63
    7144:	f8 94       	cli
    7146:	de bf       	out	0x3e, r29	; 62
    7148:	0f be       	out	0x3f, r0	; 63
    714a:	cd bf       	out	0x3d, r28	; 61
	DIO_Init();
    714c:	0e 94 07 0c 	call	0x180e	; 0x180e <DIO_Init>
	LCD_Init();
    7150:	0e 94 a3 11 	call	0x2346	; 0x2346 <LCD_Init>
	sei();
    7154:	78 94       	sei
	EXI_Enable(EX_INT2);
    7156:	82 e0       	ldi	r24, 0x02	; 2
    7158:	0e 94 64 0c 	call	0x18c8	; 0x18c8 <EXI_Enable>
	EXI_TriggerEdge(EX_INT2,FALLING_EDGE);
    715c:	82 e0       	ldi	r24, 0x02	; 2
    715e:	62 e0       	ldi	r22, 0x02	; 2
    7160:	0e 94 b8 0c 	call	0x1970	; 0x1970 <EXI_TriggerEdge>

	LCD_WriteString("Welcome To Our");
    7164:	86 e7       	ldi	r24, 0x76	; 118
    7166:	90 e0       	ldi	r25, 0x00	; 0
    7168:	0e 94 af 14 	call	0x295e	; 0x295e <LCD_WriteString>
	LCD_SetCursor(1,1);
    716c:	81 e0       	ldi	r24, 0x01	; 1
    716e:	61 e0       	ldi	r22, 0x01	; 1
    7170:	0e 94 63 15 	call	0x2ac6	; 0x2ac6 <LCD_SetCursor>
	LCD_WriteString("Small Traffic");
    7174:	85 e8       	ldi	r24, 0x85	; 133
    7176:	90 e0       	ldi	r25, 0x00	; 0
    7178:	0e 94 af 14 	call	0x295e	; 0x295e <LCD_WriteString>
	PORTC = seven[0];
    717c:	e5 e3       	ldi	r30, 0x35	; 53
    717e:	f0 e0       	ldi	r31, 0x00	; 0
    7180:	80 91 09 01 	lds	r24, 0x0109
    7184:	80 83       	st	Z, r24
	PORTD = seven[0];
    7186:	e2 e3       	ldi	r30, 0x32	; 50
    7188:	f0 e0       	ldi	r31, 0x00	; 0
    718a:	80 91 09 01 	lds	r24, 0x0109
    718e:	80 83       	st	Z, r24
    7190:	fe 01       	movw	r30, r28
    7192:	ed 5b       	subi	r30, 0xBD	; 189
    7194:	ff 4f       	sbci	r31, 0xFF	; 255
    7196:	80 e0       	ldi	r24, 0x00	; 0
    7198:	90 e0       	ldi	r25, 0x00	; 0
    719a:	af e2       	ldi	r26, 0x2F	; 47
    719c:	b4 e4       	ldi	r27, 0x44	; 68
    719e:	80 83       	st	Z, r24
    71a0:	91 83       	std	Z+1, r25	; 0x01
    71a2:	a2 83       	std	Z+2, r26	; 0x02
    71a4:	b3 83       	std	Z+3, r27	; 0x03
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    71a6:	8e 01       	movw	r16, r28
    71a8:	01 5c       	subi	r16, 0xC1	; 193
    71aa:	1f 4f       	sbci	r17, 0xFF	; 255
    71ac:	fe 01       	movw	r30, r28
    71ae:	ed 5b       	subi	r30, 0xBD	; 189
    71b0:	ff 4f       	sbci	r31, 0xFF	; 255
    71b2:	60 81       	ld	r22, Z
    71b4:	71 81       	ldd	r23, Z+1	; 0x01
    71b6:	82 81       	ldd	r24, Z+2	; 0x02
    71b8:	93 81       	ldd	r25, Z+3	; 0x03
    71ba:	20 e0       	ldi	r18, 0x00	; 0
    71bc:	30 e0       	ldi	r19, 0x00	; 0
    71be:	4a ef       	ldi	r20, 0xFA	; 250
    71c0:	54 e4       	ldi	r21, 0x44	; 68
    71c2:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    71c6:	dc 01       	movw	r26, r24
    71c8:	cb 01       	movw	r24, r22
    71ca:	f8 01       	movw	r30, r16
    71cc:	80 83       	st	Z, r24
    71ce:	91 83       	std	Z+1, r25	; 0x01
    71d0:	a2 83       	std	Z+2, r26	; 0x02
    71d2:	b3 83       	std	Z+3, r27	; 0x03
	if (__tmp < 1.0)
    71d4:	fe 01       	movw	r30, r28
    71d6:	ff 96       	adiw	r30, 0x3f	; 63
    71d8:	60 81       	ld	r22, Z
    71da:	71 81       	ldd	r23, Z+1	; 0x01
    71dc:	82 81       	ldd	r24, Z+2	; 0x02
    71de:	93 81       	ldd	r25, Z+3	; 0x03
    71e0:	20 e0       	ldi	r18, 0x00	; 0
    71e2:	30 e0       	ldi	r19, 0x00	; 0
    71e4:	40 e8       	ldi	r20, 0x80	; 128
    71e6:	5f e3       	ldi	r21, 0x3F	; 63
    71e8:	0e 94 79 03 	call	0x6f2	; 0x6f2 <__ltsf2>
    71ec:	88 23       	and	r24, r24
    71ee:	2c f4       	brge	.+10     	; 0x71fa <main+0xc8>
		__ticks = 1;
    71f0:	81 e0       	ldi	r24, 0x01	; 1
    71f2:	90 e0       	ldi	r25, 0x00	; 0
    71f4:	9e af       	std	Y+62, r25	; 0x3e
    71f6:	8d af       	std	Y+61, r24	; 0x3d
    71f8:	46 c0       	rjmp	.+140    	; 0x7286 <main+0x154>
	else if (__tmp > 65535)
    71fa:	fe 01       	movw	r30, r28
    71fc:	ff 96       	adiw	r30, 0x3f	; 63
    71fe:	60 81       	ld	r22, Z
    7200:	71 81       	ldd	r23, Z+1	; 0x01
    7202:	82 81       	ldd	r24, Z+2	; 0x02
    7204:	93 81       	ldd	r25, Z+3	; 0x03
    7206:	20 e0       	ldi	r18, 0x00	; 0
    7208:	3f ef       	ldi	r19, 0xFF	; 255
    720a:	4f e7       	ldi	r20, 0x7F	; 127
    720c:	57 e4       	ldi	r21, 0x47	; 71
    720e:	0e 94 19 03 	call	0x632	; 0x632 <__gtsf2>
    7212:	18 16       	cp	r1, r24
    7214:	64 f5       	brge	.+88     	; 0x726e <main+0x13c>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    7216:	fe 01       	movw	r30, r28
    7218:	ed 5b       	subi	r30, 0xBD	; 189
    721a:	ff 4f       	sbci	r31, 0xFF	; 255
    721c:	60 81       	ld	r22, Z
    721e:	71 81       	ldd	r23, Z+1	; 0x01
    7220:	82 81       	ldd	r24, Z+2	; 0x02
    7222:	93 81       	ldd	r25, Z+3	; 0x03
    7224:	20 e0       	ldi	r18, 0x00	; 0
    7226:	30 e0       	ldi	r19, 0x00	; 0
    7228:	40 e2       	ldi	r20, 0x20	; 32
    722a:	51 e4       	ldi	r21, 0x41	; 65
    722c:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    7230:	dc 01       	movw	r26, r24
    7232:	cb 01       	movw	r24, r22
    7234:	bc 01       	movw	r22, r24
    7236:	cd 01       	movw	r24, r26
    7238:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    723c:	dc 01       	movw	r26, r24
    723e:	cb 01       	movw	r24, r22
    7240:	9e af       	std	Y+62, r25	; 0x3e
    7242:	8d af       	std	Y+61, r24	; 0x3d
    7244:	0f c0       	rjmp	.+30     	; 0x7264 <main+0x132>
    7246:	88 ec       	ldi	r24, 0xC8	; 200
    7248:	90 e0       	ldi	r25, 0x00	; 0
    724a:	9c af       	std	Y+60, r25	; 0x3c
    724c:	8b af       	std	Y+59, r24	; 0x3b
    724e:	8b ad       	ldd	r24, Y+59	; 0x3b
    7250:	9c ad       	ldd	r25, Y+60	; 0x3c
    7252:	01 97       	sbiw	r24, 0x01	; 1
    7254:	f1 f7       	brne	.-4      	; 0x7252 <main+0x120>
    7256:	9c af       	std	Y+60, r25	; 0x3c
    7258:	8b af       	std	Y+59, r24	; 0x3b
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    725a:	8d ad       	ldd	r24, Y+61	; 0x3d
    725c:	9e ad       	ldd	r25, Y+62	; 0x3e
    725e:	01 97       	sbiw	r24, 0x01	; 1
    7260:	9e af       	std	Y+62, r25	; 0x3e
    7262:	8d af       	std	Y+61, r24	; 0x3d
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    7264:	8d ad       	ldd	r24, Y+61	; 0x3d
    7266:	9e ad       	ldd	r25, Y+62	; 0x3e
    7268:	00 97       	sbiw	r24, 0x00	; 0
    726a:	69 f7       	brne	.-38     	; 0x7246 <main+0x114>
    726c:	16 c0       	rjmp	.+44     	; 0x729a <main+0x168>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    726e:	fe 01       	movw	r30, r28
    7270:	ff 96       	adiw	r30, 0x3f	; 63
    7272:	60 81       	ld	r22, Z
    7274:	71 81       	ldd	r23, Z+1	; 0x01
    7276:	82 81       	ldd	r24, Z+2	; 0x02
    7278:	93 81       	ldd	r25, Z+3	; 0x03
    727a:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    727e:	dc 01       	movw	r26, r24
    7280:	cb 01       	movw	r24, r22
    7282:	9e af       	std	Y+62, r25	; 0x3e
    7284:	8d af       	std	Y+61, r24	; 0x3d
    7286:	8d ad       	ldd	r24, Y+61	; 0x3d
    7288:	9e ad       	ldd	r25, Y+62	; 0x3e
    728a:	9a af       	std	Y+58, r25	; 0x3a
    728c:	89 af       	std	Y+57, r24	; 0x39
    728e:	89 ad       	ldd	r24, Y+57	; 0x39
    7290:	9a ad       	ldd	r25, Y+58	; 0x3a
    7292:	01 97       	sbiw	r24, 0x01	; 1
    7294:	f1 f7       	brne	.-4      	; 0x7292 <main+0x160>
    7296:	9a af       	std	Y+58, r25	; 0x3a
    7298:	89 af       	std	Y+57, r24	; 0x39
	while(1){



		//Cars off People on
		LCD_Clear();
    729a:	0e 94 db 14 	call	0x29b6	; 0x29b6 <LCD_Clear>
		flag=0;
    729e:	10 92 ac 05 	sts	0x05AC, r1
		u8 seg0=0,seg1=0;
    72a2:	fe 01       	movw	r30, r28
    72a4:	e8 5b       	subi	r30, 0xB8	; 184
    72a6:	ff 4f       	sbci	r31, 0xFF	; 255
    72a8:	10 82       	st	Z, r1
    72aa:	fe 01       	movw	r30, r28
    72ac:	e9 5b       	subi	r30, 0xB9	; 185
    72ae:	ff 4f       	sbci	r31, 0xFF	; 255
    72b0:	10 82       	st	Z, r1
		LCD_WriteString("People Go");
    72b2:	83 e9       	ldi	r24, 0x93	; 147
    72b4:	90 e0       	ldi	r25, 0x00	; 0
    72b6:	0e 94 af 14 	call	0x295e	; 0x295e <LCD_WriteString>
		DIO_WritePin(PINB05,HIGH);
    72ba:	8d e0       	ldi	r24, 0x0D	; 13
    72bc:	61 e0       	ldi	r22, 0x01	; 1
    72be:	0e 94 f9 09 	call	0x13f2	; 0x13f2 <DIO_WritePin>
		for(i=30;i>=0;i--){
    72c2:	8e e1       	ldi	r24, 0x1E	; 30
    72c4:	80 93 13 01 	sts	0x0113, r24
    72c8:	a6 c0       	rjmp	.+332    	; 0x7416 <main+0x2e4>
			seg1=i/10;
    72ca:	80 91 13 01 	lds	r24, 0x0113
    72ce:	9a e0       	ldi	r25, 0x0A	; 10
    72d0:	69 2f       	mov	r22, r25
    72d2:	0e 94 5f 3c 	call	0x78be	; 0x78be <__divmodqi4>
    72d6:	fe 01       	movw	r30, r28
    72d8:	e9 5b       	subi	r30, 0xB9	; 185
    72da:	ff 4f       	sbci	r31, 0xFF	; 255
    72dc:	80 83       	st	Z, r24
			seg0=i%10;
    72de:	80 91 13 01 	lds	r24, 0x0113
    72e2:	9a e0       	ldi	r25, 0x0A	; 10
    72e4:	69 2f       	mov	r22, r25
    72e6:	0e 94 5f 3c 	call	0x78be	; 0x78be <__divmodqi4>
    72ea:	89 2f       	mov	r24, r25
    72ec:	fe 01       	movw	r30, r28
    72ee:	e8 5b       	subi	r30, 0xB8	; 184
    72f0:	ff 4f       	sbci	r31, 0xFF	; 255
    72f2:	80 83       	st	Z, r24
			PORTC=seven[seg1];
    72f4:	a5 e3       	ldi	r26, 0x35	; 53
    72f6:	b0 e0       	ldi	r27, 0x00	; 0
    72f8:	fe 01       	movw	r30, r28
    72fa:	e9 5b       	subi	r30, 0xB9	; 185
    72fc:	ff 4f       	sbci	r31, 0xFF	; 255
    72fe:	80 81       	ld	r24, Z
    7300:	88 2f       	mov	r24, r24
    7302:	90 e0       	ldi	r25, 0x00	; 0
    7304:	fc 01       	movw	r30, r24
    7306:	e7 5f       	subi	r30, 0xF7	; 247
    7308:	fe 4f       	sbci	r31, 0xFE	; 254
    730a:	80 81       	ld	r24, Z
    730c:	8c 93       	st	X, r24
			PORTD=seven[seg0];
    730e:	a2 e3       	ldi	r26, 0x32	; 50
    7310:	b0 e0       	ldi	r27, 0x00	; 0
    7312:	fe 01       	movw	r30, r28
    7314:	e8 5b       	subi	r30, 0xB8	; 184
    7316:	ff 4f       	sbci	r31, 0xFF	; 255
    7318:	80 81       	ld	r24, Z
    731a:	88 2f       	mov	r24, r24
    731c:	90 e0       	ldi	r25, 0x00	; 0
    731e:	fc 01       	movw	r30, r24
    7320:	e7 5f       	subi	r30, 0xF7	; 247
    7322:	fe 4f       	sbci	r31, 0xFE	; 254
    7324:	80 81       	ld	r24, Z
    7326:	8c 93       	st	X, r24
    7328:	80 e0       	ldi	r24, 0x00	; 0
    732a:	90 e0       	ldi	r25, 0x00	; 0
    732c:	a1 e6       	ldi	r26, 0x61	; 97
    732e:	b4 e4       	ldi	r27, 0x44	; 68
    7330:	8d ab       	std	Y+53, r24	; 0x35
    7332:	9e ab       	std	Y+54, r25	; 0x36
    7334:	af ab       	std	Y+55, r26	; 0x37
    7336:	b8 af       	std	Y+56, r27	; 0x38
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    7338:	6d a9       	ldd	r22, Y+53	; 0x35
    733a:	7e a9       	ldd	r23, Y+54	; 0x36
    733c:	8f a9       	ldd	r24, Y+55	; 0x37
    733e:	98 ad       	ldd	r25, Y+56	; 0x38
    7340:	20 e0       	ldi	r18, 0x00	; 0
    7342:	30 e0       	ldi	r19, 0x00	; 0
    7344:	4a ef       	ldi	r20, 0xFA	; 250
    7346:	54 e4       	ldi	r21, 0x44	; 68
    7348:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    734c:	dc 01       	movw	r26, r24
    734e:	cb 01       	movw	r24, r22
    7350:	89 ab       	std	Y+49, r24	; 0x31
    7352:	9a ab       	std	Y+50, r25	; 0x32
    7354:	ab ab       	std	Y+51, r26	; 0x33
    7356:	bc ab       	std	Y+52, r27	; 0x34
	if (__tmp < 1.0)
    7358:	69 a9       	ldd	r22, Y+49	; 0x31
    735a:	7a a9       	ldd	r23, Y+50	; 0x32
    735c:	8b a9       	ldd	r24, Y+51	; 0x33
    735e:	9c a9       	ldd	r25, Y+52	; 0x34
    7360:	20 e0       	ldi	r18, 0x00	; 0
    7362:	30 e0       	ldi	r19, 0x00	; 0
    7364:	40 e8       	ldi	r20, 0x80	; 128
    7366:	5f e3       	ldi	r21, 0x3F	; 63
    7368:	0e 94 79 03 	call	0x6f2	; 0x6f2 <__ltsf2>
    736c:	88 23       	and	r24, r24
    736e:	2c f4       	brge	.+10     	; 0x737a <main+0x248>
		__ticks = 1;
    7370:	81 e0       	ldi	r24, 0x01	; 1
    7372:	90 e0       	ldi	r25, 0x00	; 0
    7374:	98 ab       	std	Y+48, r25	; 0x30
    7376:	8f a7       	std	Y+47, r24	; 0x2f
    7378:	3f c0       	rjmp	.+126    	; 0x73f8 <main+0x2c6>
	else if (__tmp > 65535)
    737a:	69 a9       	ldd	r22, Y+49	; 0x31
    737c:	7a a9       	ldd	r23, Y+50	; 0x32
    737e:	8b a9       	ldd	r24, Y+51	; 0x33
    7380:	9c a9       	ldd	r25, Y+52	; 0x34
    7382:	20 e0       	ldi	r18, 0x00	; 0
    7384:	3f ef       	ldi	r19, 0xFF	; 255
    7386:	4f e7       	ldi	r20, 0x7F	; 127
    7388:	57 e4       	ldi	r21, 0x47	; 71
    738a:	0e 94 19 03 	call	0x632	; 0x632 <__gtsf2>
    738e:	18 16       	cp	r1, r24
    7390:	4c f5       	brge	.+82     	; 0x73e4 <main+0x2b2>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    7392:	6d a9       	ldd	r22, Y+53	; 0x35
    7394:	7e a9       	ldd	r23, Y+54	; 0x36
    7396:	8f a9       	ldd	r24, Y+55	; 0x37
    7398:	98 ad       	ldd	r25, Y+56	; 0x38
    739a:	20 e0       	ldi	r18, 0x00	; 0
    739c:	30 e0       	ldi	r19, 0x00	; 0
    739e:	40 e2       	ldi	r20, 0x20	; 32
    73a0:	51 e4       	ldi	r21, 0x41	; 65
    73a2:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    73a6:	dc 01       	movw	r26, r24
    73a8:	cb 01       	movw	r24, r22
    73aa:	bc 01       	movw	r22, r24
    73ac:	cd 01       	movw	r24, r26
    73ae:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    73b2:	dc 01       	movw	r26, r24
    73b4:	cb 01       	movw	r24, r22
    73b6:	98 ab       	std	Y+48, r25	; 0x30
    73b8:	8f a7       	std	Y+47, r24	; 0x2f
    73ba:	0f c0       	rjmp	.+30     	; 0x73da <main+0x2a8>
    73bc:	88 ec       	ldi	r24, 0xC8	; 200
    73be:	90 e0       	ldi	r25, 0x00	; 0
    73c0:	9e a7       	std	Y+46, r25	; 0x2e
    73c2:	8d a7       	std	Y+45, r24	; 0x2d
    73c4:	8d a5       	ldd	r24, Y+45	; 0x2d
    73c6:	9e a5       	ldd	r25, Y+46	; 0x2e
    73c8:	01 97       	sbiw	r24, 0x01	; 1
    73ca:	f1 f7       	brne	.-4      	; 0x73c8 <main+0x296>
    73cc:	9e a7       	std	Y+46, r25	; 0x2e
    73ce:	8d a7       	std	Y+45, r24	; 0x2d
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    73d0:	8f a5       	ldd	r24, Y+47	; 0x2f
    73d2:	98 a9       	ldd	r25, Y+48	; 0x30
    73d4:	01 97       	sbiw	r24, 0x01	; 1
    73d6:	98 ab       	std	Y+48, r25	; 0x30
    73d8:	8f a7       	std	Y+47, r24	; 0x2f
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    73da:	8f a5       	ldd	r24, Y+47	; 0x2f
    73dc:	98 a9       	ldd	r25, Y+48	; 0x30
    73de:	00 97       	sbiw	r24, 0x00	; 0
    73e0:	69 f7       	brne	.-38     	; 0x73bc <main+0x28a>
    73e2:	14 c0       	rjmp	.+40     	; 0x740c <main+0x2da>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    73e4:	69 a9       	ldd	r22, Y+49	; 0x31
    73e6:	7a a9       	ldd	r23, Y+50	; 0x32
    73e8:	8b a9       	ldd	r24, Y+51	; 0x33
    73ea:	9c a9       	ldd	r25, Y+52	; 0x34
    73ec:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    73f0:	dc 01       	movw	r26, r24
    73f2:	cb 01       	movw	r24, r22
    73f4:	98 ab       	std	Y+48, r25	; 0x30
    73f6:	8f a7       	std	Y+47, r24	; 0x2f
    73f8:	8f a5       	ldd	r24, Y+47	; 0x2f
    73fa:	98 a9       	ldd	r25, Y+48	; 0x30
    73fc:	9c a7       	std	Y+44, r25	; 0x2c
    73fe:	8b a7       	std	Y+43, r24	; 0x2b
    7400:	8b a5       	ldd	r24, Y+43	; 0x2b
    7402:	9c a5       	ldd	r25, Y+44	; 0x2c
    7404:	01 97       	sbiw	r24, 0x01	; 1
    7406:	f1 f7       	brne	.-4      	; 0x7404 <main+0x2d2>
    7408:	9c a7       	std	Y+44, r25	; 0x2c
    740a:	8b a7       	std	Y+43, r24	; 0x2b
		LCD_Clear();
		flag=0;
		u8 seg0=0,seg1=0;
		LCD_WriteString("People Go");
		DIO_WritePin(PINB05,HIGH);
		for(i=30;i>=0;i--){
    740c:	80 91 13 01 	lds	r24, 0x0113
    7410:	81 50       	subi	r24, 0x01	; 1
    7412:	80 93 13 01 	sts	0x0113, r24
    7416:	80 91 13 01 	lds	r24, 0x0113
    741a:	88 23       	and	r24, r24
    741c:	0c f0       	brlt	.+2      	; 0x7420 <main+0x2ee>
    741e:	55 cf       	rjmp	.-342    	; 0x72ca <main+0x198>
			PORTC=seven[seg1];
			PORTD=seven[seg0];

			_delay_ms(900);
		}
		DIO_WritePin(PINB05,LOW);
    7420:	8d e0       	ldi	r24, 0x0D	; 13
    7422:	60 e0       	ldi	r22, 0x00	; 0
    7424:	0e 94 f9 09 	call	0x13f2	; 0x13f2 <DIO_WritePin>

		//Warning
		LCD_Clear();
    7428:	0e 94 db 14 	call	0x29b6	; 0x29b6 <LCD_Clear>
		LCD_WriteString("Warning......");
    742c:	8d e9       	ldi	r24, 0x9D	; 157
    742e:	90 e0       	ldi	r25, 0x00	; 0
    7430:	0e 94 af 14 	call	0x295e	; 0x295e <LCD_WriteString>
		LCD_SetCursor(1,0);
    7434:	81 e0       	ldi	r24, 0x01	; 1
    7436:	60 e0       	ldi	r22, 0x00	; 0
    7438:	0e 94 63 15 	call	0x2ac6	; 0x2ac6 <LCD_SetCursor>
		LCD_WriteString("Cars will go");
    743c:	8b ea       	ldi	r24, 0xAB	; 171
    743e:	90 e0       	ldi	r25, 0x00	; 0
    7440:	0e 94 af 14 	call	0x295e	; 0x295e <LCD_WriteString>
		DIO_WritePin(PINB06,HIGH);
    7444:	8e e0       	ldi	r24, 0x0E	; 14
    7446:	61 e0       	ldi	r22, 0x01	; 1
    7448:	0e 94 f9 09 	call	0x13f2	; 0x13f2 <DIO_WritePin>
		for(i=5;i>=0;i--){
    744c:	85 e0       	ldi	r24, 0x05	; 5
    744e:	80 93 13 01 	sts	0x0113, r24
    7452:	88 c0       	rjmp	.+272    	; 0x7564 <main+0x432>
			PORTC=seven[0];
    7454:	e5 e3       	ldi	r30, 0x35	; 53
    7456:	f0 e0       	ldi	r31, 0x00	; 0
    7458:	80 91 09 01 	lds	r24, 0x0109
    745c:	80 83       	st	Z, r24
			PORTD=seven[i];
    745e:	a2 e3       	ldi	r26, 0x32	; 50
    7460:	b0 e0       	ldi	r27, 0x00	; 0
    7462:	80 91 13 01 	lds	r24, 0x0113
    7466:	99 27       	eor	r25, r25
    7468:	87 fd       	sbrc	r24, 7
    746a:	90 95       	com	r25
    746c:	fc 01       	movw	r30, r24
    746e:	e7 5f       	subi	r30, 0xF7	; 247
    7470:	fe 4f       	sbci	r31, 0xFE	; 254
    7472:	80 81       	ld	r24, Z
    7474:	8c 93       	st	X, r24
    7476:	80 e0       	ldi	r24, 0x00	; 0
    7478:	90 e0       	ldi	r25, 0x00	; 0
    747a:	a1 e6       	ldi	r26, 0x61	; 97
    747c:	b4 e4       	ldi	r27, 0x44	; 68
    747e:	8f a3       	std	Y+39, r24	; 0x27
    7480:	98 a7       	std	Y+40, r25	; 0x28
    7482:	a9 a7       	std	Y+41, r26	; 0x29
    7484:	ba a7       	std	Y+42, r27	; 0x2a
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    7486:	6f a1       	ldd	r22, Y+39	; 0x27
    7488:	78 a5       	ldd	r23, Y+40	; 0x28
    748a:	89 a5       	ldd	r24, Y+41	; 0x29
    748c:	9a a5       	ldd	r25, Y+42	; 0x2a
    748e:	20 e0       	ldi	r18, 0x00	; 0
    7490:	30 e0       	ldi	r19, 0x00	; 0
    7492:	4a ef       	ldi	r20, 0xFA	; 250
    7494:	54 e4       	ldi	r21, 0x44	; 68
    7496:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    749a:	dc 01       	movw	r26, r24
    749c:	cb 01       	movw	r24, r22
    749e:	8b a3       	std	Y+35, r24	; 0x23
    74a0:	9c a3       	std	Y+36, r25	; 0x24
    74a2:	ad a3       	std	Y+37, r26	; 0x25
    74a4:	be a3       	std	Y+38, r27	; 0x26
	if (__tmp < 1.0)
    74a6:	6b a1       	ldd	r22, Y+35	; 0x23
    74a8:	7c a1       	ldd	r23, Y+36	; 0x24
    74aa:	8d a1       	ldd	r24, Y+37	; 0x25
    74ac:	9e a1       	ldd	r25, Y+38	; 0x26
    74ae:	20 e0       	ldi	r18, 0x00	; 0
    74b0:	30 e0       	ldi	r19, 0x00	; 0
    74b2:	40 e8       	ldi	r20, 0x80	; 128
    74b4:	5f e3       	ldi	r21, 0x3F	; 63
    74b6:	0e 94 79 03 	call	0x6f2	; 0x6f2 <__ltsf2>
    74ba:	88 23       	and	r24, r24
    74bc:	2c f4       	brge	.+10     	; 0x74c8 <main+0x396>
		__ticks = 1;
    74be:	81 e0       	ldi	r24, 0x01	; 1
    74c0:	90 e0       	ldi	r25, 0x00	; 0
    74c2:	9a a3       	std	Y+34, r25	; 0x22
    74c4:	89 a3       	std	Y+33, r24	; 0x21
    74c6:	3f c0       	rjmp	.+126    	; 0x7546 <main+0x414>
	else if (__tmp > 65535)
    74c8:	6b a1       	ldd	r22, Y+35	; 0x23
    74ca:	7c a1       	ldd	r23, Y+36	; 0x24
    74cc:	8d a1       	ldd	r24, Y+37	; 0x25
    74ce:	9e a1       	ldd	r25, Y+38	; 0x26
    74d0:	20 e0       	ldi	r18, 0x00	; 0
    74d2:	3f ef       	ldi	r19, 0xFF	; 255
    74d4:	4f e7       	ldi	r20, 0x7F	; 127
    74d6:	57 e4       	ldi	r21, 0x47	; 71
    74d8:	0e 94 19 03 	call	0x632	; 0x632 <__gtsf2>
    74dc:	18 16       	cp	r1, r24
    74de:	4c f5       	brge	.+82     	; 0x7532 <main+0x400>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    74e0:	6f a1       	ldd	r22, Y+39	; 0x27
    74e2:	78 a5       	ldd	r23, Y+40	; 0x28
    74e4:	89 a5       	ldd	r24, Y+41	; 0x29
    74e6:	9a a5       	ldd	r25, Y+42	; 0x2a
    74e8:	20 e0       	ldi	r18, 0x00	; 0
    74ea:	30 e0       	ldi	r19, 0x00	; 0
    74ec:	40 e2       	ldi	r20, 0x20	; 32
    74ee:	51 e4       	ldi	r21, 0x41	; 65
    74f0:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    74f4:	dc 01       	movw	r26, r24
    74f6:	cb 01       	movw	r24, r22
    74f8:	bc 01       	movw	r22, r24
    74fa:	cd 01       	movw	r24, r26
    74fc:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    7500:	dc 01       	movw	r26, r24
    7502:	cb 01       	movw	r24, r22
    7504:	9a a3       	std	Y+34, r25	; 0x22
    7506:	89 a3       	std	Y+33, r24	; 0x21
    7508:	0f c0       	rjmp	.+30     	; 0x7528 <main+0x3f6>
    750a:	88 ec       	ldi	r24, 0xC8	; 200
    750c:	90 e0       	ldi	r25, 0x00	; 0
    750e:	98 a3       	std	Y+32, r25	; 0x20
    7510:	8f 8f       	std	Y+31, r24	; 0x1f
    7512:	8f 8d       	ldd	r24, Y+31	; 0x1f
    7514:	98 a1       	ldd	r25, Y+32	; 0x20
    7516:	01 97       	sbiw	r24, 0x01	; 1
    7518:	f1 f7       	brne	.-4      	; 0x7516 <main+0x3e4>
    751a:	98 a3       	std	Y+32, r25	; 0x20
    751c:	8f 8f       	std	Y+31, r24	; 0x1f
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    751e:	89 a1       	ldd	r24, Y+33	; 0x21
    7520:	9a a1       	ldd	r25, Y+34	; 0x22
    7522:	01 97       	sbiw	r24, 0x01	; 1
    7524:	9a a3       	std	Y+34, r25	; 0x22
    7526:	89 a3       	std	Y+33, r24	; 0x21
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    7528:	89 a1       	ldd	r24, Y+33	; 0x21
    752a:	9a a1       	ldd	r25, Y+34	; 0x22
    752c:	00 97       	sbiw	r24, 0x00	; 0
    752e:	69 f7       	brne	.-38     	; 0x750a <main+0x3d8>
    7530:	14 c0       	rjmp	.+40     	; 0x755a <main+0x428>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    7532:	6b a1       	ldd	r22, Y+35	; 0x23
    7534:	7c a1       	ldd	r23, Y+36	; 0x24
    7536:	8d a1       	ldd	r24, Y+37	; 0x25
    7538:	9e a1       	ldd	r25, Y+38	; 0x26
    753a:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    753e:	dc 01       	movw	r26, r24
    7540:	cb 01       	movw	r24, r22
    7542:	9a a3       	std	Y+34, r25	; 0x22
    7544:	89 a3       	std	Y+33, r24	; 0x21
    7546:	89 a1       	ldd	r24, Y+33	; 0x21
    7548:	9a a1       	ldd	r25, Y+34	; 0x22
    754a:	9e 8f       	std	Y+30, r25	; 0x1e
    754c:	8d 8f       	std	Y+29, r24	; 0x1d
    754e:	8d 8d       	ldd	r24, Y+29	; 0x1d
    7550:	9e 8d       	ldd	r25, Y+30	; 0x1e
    7552:	01 97       	sbiw	r24, 0x01	; 1
    7554:	f1 f7       	brne	.-4      	; 0x7552 <main+0x420>
    7556:	9e 8f       	std	Y+30, r25	; 0x1e
    7558:	8d 8f       	std	Y+29, r24	; 0x1d
		LCD_Clear();
		LCD_WriteString("Warning......");
		LCD_SetCursor(1,0);
		LCD_WriteString("Cars will go");
		DIO_WritePin(PINB06,HIGH);
		for(i=5;i>=0;i--){
    755a:	80 91 13 01 	lds	r24, 0x0113
    755e:	81 50       	subi	r24, 0x01	; 1
    7560:	80 93 13 01 	sts	0x0113, r24
    7564:	80 91 13 01 	lds	r24, 0x0113
    7568:	88 23       	and	r24, r24
    756a:	0c f0       	brlt	.+2      	; 0x756e <main+0x43c>
    756c:	73 cf       	rjmp	.-282    	; 0x7454 <main+0x322>
			PORTC=seven[0];
			PORTD=seven[i];
			_delay_ms(900);
		}
		DIO_WritePin(PINB06,LOW);
    756e:	8e e0       	ldi	r24, 0x0E	; 14
    7570:	60 e0       	ldi	r22, 0x00	; 0
    7572:	0e 94 f9 09 	call	0x13f2	; 0x13f2 <DIO_WritePin>
		//Cars On People Off
		LCD_Clear();
    7576:	0e 94 db 14 	call	0x29b6	; 0x29b6 <LCD_Clear>
		LCD_WriteString("Waring:Stop");
    757a:	88 eb       	ldi	r24, 0xB8	; 184
    757c:	90 e0       	ldi	r25, 0x00	; 0
    757e:	0e 94 af 14 	call	0x295e	; 0x295e <LCD_WriteString>
		LCD_SetCursor(1,0);
    7582:	81 e0       	ldi	r24, 0x01	; 1
    7584:	60 e0       	ldi	r22, 0x00	; 0
    7586:	0e 94 63 15 	call	0x2ac6	; 0x2ac6 <LCD_SetCursor>
		LCD_WriteString("use key to go");
    758a:	84 ec       	ldi	r24, 0xC4	; 196
    758c:	90 e0       	ldi	r25, 0x00	; 0
    758e:	0e 94 af 14 	call	0x295e	; 0x295e <LCD_WriteString>
		DIO_WritePin(PINB07,HIGH);
    7592:	8f e0       	ldi	r24, 0x0F	; 15
    7594:	61 e0       	ldi	r22, 0x01	; 1
    7596:	0e 94 f9 09 	call	0x13f2	; 0x13f2 <DIO_WritePin>
		flag=1;
    759a:	81 e0       	ldi	r24, 0x01	; 1
    759c:	80 93 ac 05 	sts	0x05AC, r24
		for(i=30;i>=0;i--){
    75a0:	8e e1       	ldi	r24, 0x1E	; 30
    75a2:	80 93 13 01 	sts	0x0113, r24
    75a6:	a6 c0       	rjmp	.+332    	; 0x76f4 <main+0x5c2>
			seg1=i/10;
    75a8:	80 91 13 01 	lds	r24, 0x0113
    75ac:	9a e0       	ldi	r25, 0x0A	; 10
    75ae:	69 2f       	mov	r22, r25
    75b0:	0e 94 5f 3c 	call	0x78be	; 0x78be <__divmodqi4>
    75b4:	fe 01       	movw	r30, r28
    75b6:	e9 5b       	subi	r30, 0xB9	; 185
    75b8:	ff 4f       	sbci	r31, 0xFF	; 255
    75ba:	80 83       	st	Z, r24
			seg0=i%10;
    75bc:	80 91 13 01 	lds	r24, 0x0113
    75c0:	9a e0       	ldi	r25, 0x0A	; 10
    75c2:	69 2f       	mov	r22, r25
    75c4:	0e 94 5f 3c 	call	0x78be	; 0x78be <__divmodqi4>
    75c8:	89 2f       	mov	r24, r25
    75ca:	fe 01       	movw	r30, r28
    75cc:	e8 5b       	subi	r30, 0xB8	; 184
    75ce:	ff 4f       	sbci	r31, 0xFF	; 255
    75d0:	80 83       	st	Z, r24
			PORTC=seven[seg1];
    75d2:	a5 e3       	ldi	r26, 0x35	; 53
    75d4:	b0 e0       	ldi	r27, 0x00	; 0
    75d6:	fe 01       	movw	r30, r28
    75d8:	e9 5b       	subi	r30, 0xB9	; 185
    75da:	ff 4f       	sbci	r31, 0xFF	; 255
    75dc:	80 81       	ld	r24, Z
    75de:	88 2f       	mov	r24, r24
    75e0:	90 e0       	ldi	r25, 0x00	; 0
    75e2:	fc 01       	movw	r30, r24
    75e4:	e7 5f       	subi	r30, 0xF7	; 247
    75e6:	fe 4f       	sbci	r31, 0xFE	; 254
    75e8:	80 81       	ld	r24, Z
    75ea:	8c 93       	st	X, r24
			PORTD=seven[seg0];
    75ec:	a2 e3       	ldi	r26, 0x32	; 50
    75ee:	b0 e0       	ldi	r27, 0x00	; 0
    75f0:	fe 01       	movw	r30, r28
    75f2:	e8 5b       	subi	r30, 0xB8	; 184
    75f4:	ff 4f       	sbci	r31, 0xFF	; 255
    75f6:	80 81       	ld	r24, Z
    75f8:	88 2f       	mov	r24, r24
    75fa:	90 e0       	ldi	r25, 0x00	; 0
    75fc:	fc 01       	movw	r30, r24
    75fe:	e7 5f       	subi	r30, 0xF7	; 247
    7600:	fe 4f       	sbci	r31, 0xFE	; 254
    7602:	80 81       	ld	r24, Z
    7604:	8c 93       	st	X, r24
    7606:	80 e0       	ldi	r24, 0x00	; 0
    7608:	90 e0       	ldi	r25, 0x00	; 0
    760a:	a1 e6       	ldi	r26, 0x61	; 97
    760c:	b4 e4       	ldi	r27, 0x44	; 68
    760e:	89 8f       	std	Y+25, r24	; 0x19
    7610:	9a 8f       	std	Y+26, r25	; 0x1a
    7612:	ab 8f       	std	Y+27, r26	; 0x1b
    7614:	bc 8f       	std	Y+28, r27	; 0x1c
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    7616:	69 8d       	ldd	r22, Y+25	; 0x19
    7618:	7a 8d       	ldd	r23, Y+26	; 0x1a
    761a:	8b 8d       	ldd	r24, Y+27	; 0x1b
    761c:	9c 8d       	ldd	r25, Y+28	; 0x1c
    761e:	20 e0       	ldi	r18, 0x00	; 0
    7620:	30 e0       	ldi	r19, 0x00	; 0
    7622:	4a ef       	ldi	r20, 0xFA	; 250
    7624:	54 e4       	ldi	r21, 0x44	; 68
    7626:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    762a:	dc 01       	movw	r26, r24
    762c:	cb 01       	movw	r24, r22
    762e:	8d 8b       	std	Y+21, r24	; 0x15
    7630:	9e 8b       	std	Y+22, r25	; 0x16
    7632:	af 8b       	std	Y+23, r26	; 0x17
    7634:	b8 8f       	std	Y+24, r27	; 0x18
	if (__tmp < 1.0)
    7636:	6d 89       	ldd	r22, Y+21	; 0x15
    7638:	7e 89       	ldd	r23, Y+22	; 0x16
    763a:	8f 89       	ldd	r24, Y+23	; 0x17
    763c:	98 8d       	ldd	r25, Y+24	; 0x18
    763e:	20 e0       	ldi	r18, 0x00	; 0
    7640:	30 e0       	ldi	r19, 0x00	; 0
    7642:	40 e8       	ldi	r20, 0x80	; 128
    7644:	5f e3       	ldi	r21, 0x3F	; 63
    7646:	0e 94 79 03 	call	0x6f2	; 0x6f2 <__ltsf2>
    764a:	88 23       	and	r24, r24
    764c:	2c f4       	brge	.+10     	; 0x7658 <main+0x526>
		__ticks = 1;
    764e:	81 e0       	ldi	r24, 0x01	; 1
    7650:	90 e0       	ldi	r25, 0x00	; 0
    7652:	9c 8b       	std	Y+20, r25	; 0x14
    7654:	8b 8b       	std	Y+19, r24	; 0x13
    7656:	3f c0       	rjmp	.+126    	; 0x76d6 <main+0x5a4>
	else if (__tmp > 65535)
    7658:	6d 89       	ldd	r22, Y+21	; 0x15
    765a:	7e 89       	ldd	r23, Y+22	; 0x16
    765c:	8f 89       	ldd	r24, Y+23	; 0x17
    765e:	98 8d       	ldd	r25, Y+24	; 0x18
    7660:	20 e0       	ldi	r18, 0x00	; 0
    7662:	3f ef       	ldi	r19, 0xFF	; 255
    7664:	4f e7       	ldi	r20, 0x7F	; 127
    7666:	57 e4       	ldi	r21, 0x47	; 71
    7668:	0e 94 19 03 	call	0x632	; 0x632 <__gtsf2>
    766c:	18 16       	cp	r1, r24
    766e:	4c f5       	brge	.+82     	; 0x76c2 <main+0x590>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    7670:	69 8d       	ldd	r22, Y+25	; 0x19
    7672:	7a 8d       	ldd	r23, Y+26	; 0x1a
    7674:	8b 8d       	ldd	r24, Y+27	; 0x1b
    7676:	9c 8d       	ldd	r25, Y+28	; 0x1c
    7678:	20 e0       	ldi	r18, 0x00	; 0
    767a:	30 e0       	ldi	r19, 0x00	; 0
    767c:	40 e2       	ldi	r20, 0x20	; 32
    767e:	51 e4       	ldi	r21, 0x41	; 65
    7680:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    7684:	dc 01       	movw	r26, r24
    7686:	cb 01       	movw	r24, r22
    7688:	bc 01       	movw	r22, r24
    768a:	cd 01       	movw	r24, r26
    768c:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    7690:	dc 01       	movw	r26, r24
    7692:	cb 01       	movw	r24, r22
    7694:	9c 8b       	std	Y+20, r25	; 0x14
    7696:	8b 8b       	std	Y+19, r24	; 0x13
    7698:	0f c0       	rjmp	.+30     	; 0x76b8 <main+0x586>
    769a:	88 ec       	ldi	r24, 0xC8	; 200
    769c:	90 e0       	ldi	r25, 0x00	; 0
    769e:	9a 8b       	std	Y+18, r25	; 0x12
    76a0:	89 8b       	std	Y+17, r24	; 0x11
    76a2:	89 89       	ldd	r24, Y+17	; 0x11
    76a4:	9a 89       	ldd	r25, Y+18	; 0x12
    76a6:	01 97       	sbiw	r24, 0x01	; 1
    76a8:	f1 f7       	brne	.-4      	; 0x76a6 <main+0x574>
    76aa:	9a 8b       	std	Y+18, r25	; 0x12
    76ac:	89 8b       	std	Y+17, r24	; 0x11
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    76ae:	8b 89       	ldd	r24, Y+19	; 0x13
    76b0:	9c 89       	ldd	r25, Y+20	; 0x14
    76b2:	01 97       	sbiw	r24, 0x01	; 1
    76b4:	9c 8b       	std	Y+20, r25	; 0x14
    76b6:	8b 8b       	std	Y+19, r24	; 0x13
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    76b8:	8b 89       	ldd	r24, Y+19	; 0x13
    76ba:	9c 89       	ldd	r25, Y+20	; 0x14
    76bc:	00 97       	sbiw	r24, 0x00	; 0
    76be:	69 f7       	brne	.-38     	; 0x769a <main+0x568>
    76c0:	14 c0       	rjmp	.+40     	; 0x76ea <main+0x5b8>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    76c2:	6d 89       	ldd	r22, Y+21	; 0x15
    76c4:	7e 89       	ldd	r23, Y+22	; 0x16
    76c6:	8f 89       	ldd	r24, Y+23	; 0x17
    76c8:	98 8d       	ldd	r25, Y+24	; 0x18
    76ca:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    76ce:	dc 01       	movw	r26, r24
    76d0:	cb 01       	movw	r24, r22
    76d2:	9c 8b       	std	Y+20, r25	; 0x14
    76d4:	8b 8b       	std	Y+19, r24	; 0x13
    76d6:	8b 89       	ldd	r24, Y+19	; 0x13
    76d8:	9c 89       	ldd	r25, Y+20	; 0x14
    76da:	98 8b       	std	Y+16, r25	; 0x10
    76dc:	8f 87       	std	Y+15, r24	; 0x0f
    76de:	8f 85       	ldd	r24, Y+15	; 0x0f
    76e0:	98 89       	ldd	r25, Y+16	; 0x10
    76e2:	01 97       	sbiw	r24, 0x01	; 1
    76e4:	f1 f7       	brne	.-4      	; 0x76e2 <main+0x5b0>
    76e6:	98 8b       	std	Y+16, r25	; 0x10
    76e8:	8f 87       	std	Y+15, r24	; 0x0f
		LCD_WriteString("Waring:Stop");
		LCD_SetCursor(1,0);
		LCD_WriteString("use key to go");
		DIO_WritePin(PINB07,HIGH);
		flag=1;
		for(i=30;i>=0;i--){
    76ea:	80 91 13 01 	lds	r24, 0x0113
    76ee:	81 50       	subi	r24, 0x01	; 1
    76f0:	80 93 13 01 	sts	0x0113, r24
    76f4:	80 91 13 01 	lds	r24, 0x0113
    76f8:	88 23       	and	r24, r24
    76fa:	0c f0       	brlt	.+2      	; 0x76fe <main+0x5cc>
    76fc:	55 cf       	rjmp	.-342    	; 0x75a8 <main+0x476>
			PORTC=seven[seg1];
			PORTD=seven[seg0];

			_delay_ms(900);
		}
		DIO_WritePin(PINB07,LOW);
    76fe:	8f e0       	ldi	r24, 0x0F	; 15
    7700:	60 e0       	ldi	r22, 0x00	; 0
    7702:	0e 94 f9 09 	call	0x13f2	; 0x13f2 <DIO_WritePin>
		//Warning
		LCD_Clear();
    7706:	0e 94 db 14 	call	0x29b6	; 0x29b6 <LCD_Clear>
		LCD_WriteString("Peaple Ready");
    770a:	82 ed       	ldi	r24, 0xD2	; 210
    770c:	90 e0       	ldi	r25, 0x00	; 0
    770e:	0e 94 af 14 	call	0x295e	; 0x295e <LCD_WriteString>

		DIO_WritePin(PINB06,HIGH);
    7712:	8e e0       	ldi	r24, 0x0E	; 14
    7714:	61 e0       	ldi	r22, 0x01	; 1
    7716:	0e 94 f9 09 	call	0x13f2	; 0x13f2 <DIO_WritePin>
		for(i=5;i>=0;i--){
    771a:	85 e0       	ldi	r24, 0x05	; 5
    771c:	80 93 13 01 	sts	0x0113, r24
    7720:	88 c0       	rjmp	.+272    	; 0x7832 <main+0x700>
			PORTC=seven[0];
    7722:	e5 e3       	ldi	r30, 0x35	; 53
    7724:	f0 e0       	ldi	r31, 0x00	; 0
    7726:	80 91 09 01 	lds	r24, 0x0109
    772a:	80 83       	st	Z, r24
			PORTD=seven[i];
    772c:	a2 e3       	ldi	r26, 0x32	; 50
    772e:	b0 e0       	ldi	r27, 0x00	; 0
    7730:	80 91 13 01 	lds	r24, 0x0113
    7734:	99 27       	eor	r25, r25
    7736:	87 fd       	sbrc	r24, 7
    7738:	90 95       	com	r25
    773a:	fc 01       	movw	r30, r24
    773c:	e7 5f       	subi	r30, 0xF7	; 247
    773e:	fe 4f       	sbci	r31, 0xFE	; 254
    7740:	80 81       	ld	r24, Z
    7742:	8c 93       	st	X, r24
    7744:	80 e0       	ldi	r24, 0x00	; 0
    7746:	90 e0       	ldi	r25, 0x00	; 0
    7748:	a1 e6       	ldi	r26, 0x61	; 97
    774a:	b4 e4       	ldi	r27, 0x44	; 68
    774c:	8b 87       	std	Y+11, r24	; 0x0b
    774e:	9c 87       	std	Y+12, r25	; 0x0c
    7750:	ad 87       	std	Y+13, r26	; 0x0d
    7752:	be 87       	std	Y+14, r27	; 0x0e
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    7754:	6b 85       	ldd	r22, Y+11	; 0x0b
    7756:	7c 85       	ldd	r23, Y+12	; 0x0c
    7758:	8d 85       	ldd	r24, Y+13	; 0x0d
    775a:	9e 85       	ldd	r25, Y+14	; 0x0e
    775c:	20 e0       	ldi	r18, 0x00	; 0
    775e:	30 e0       	ldi	r19, 0x00	; 0
    7760:	4a ef       	ldi	r20, 0xFA	; 250
    7762:	54 e4       	ldi	r21, 0x44	; 68
    7764:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    7768:	dc 01       	movw	r26, r24
    776a:	cb 01       	movw	r24, r22
    776c:	8f 83       	std	Y+7, r24	; 0x07
    776e:	98 87       	std	Y+8, r25	; 0x08
    7770:	a9 87       	std	Y+9, r26	; 0x09
    7772:	ba 87       	std	Y+10, r27	; 0x0a
	if (__tmp < 1.0)
    7774:	6f 81       	ldd	r22, Y+7	; 0x07
    7776:	78 85       	ldd	r23, Y+8	; 0x08
    7778:	89 85       	ldd	r24, Y+9	; 0x09
    777a:	9a 85       	ldd	r25, Y+10	; 0x0a
    777c:	20 e0       	ldi	r18, 0x00	; 0
    777e:	30 e0       	ldi	r19, 0x00	; 0
    7780:	40 e8       	ldi	r20, 0x80	; 128
    7782:	5f e3       	ldi	r21, 0x3F	; 63
    7784:	0e 94 79 03 	call	0x6f2	; 0x6f2 <__ltsf2>
    7788:	88 23       	and	r24, r24
    778a:	2c f4       	brge	.+10     	; 0x7796 <main+0x664>
		__ticks = 1;
    778c:	81 e0       	ldi	r24, 0x01	; 1
    778e:	90 e0       	ldi	r25, 0x00	; 0
    7790:	9e 83       	std	Y+6, r25	; 0x06
    7792:	8d 83       	std	Y+5, r24	; 0x05
    7794:	3f c0       	rjmp	.+126    	; 0x7814 <main+0x6e2>
	else if (__tmp > 65535)
    7796:	6f 81       	ldd	r22, Y+7	; 0x07
    7798:	78 85       	ldd	r23, Y+8	; 0x08
    779a:	89 85       	ldd	r24, Y+9	; 0x09
    779c:	9a 85       	ldd	r25, Y+10	; 0x0a
    779e:	20 e0       	ldi	r18, 0x00	; 0
    77a0:	3f ef       	ldi	r19, 0xFF	; 255
    77a2:	4f e7       	ldi	r20, 0x7F	; 127
    77a4:	57 e4       	ldi	r21, 0x47	; 71
    77a6:	0e 94 19 03 	call	0x632	; 0x632 <__gtsf2>
    77aa:	18 16       	cp	r1, r24
    77ac:	4c f5       	brge	.+82     	; 0x7800 <main+0x6ce>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    77ae:	6b 85       	ldd	r22, Y+11	; 0x0b
    77b0:	7c 85       	ldd	r23, Y+12	; 0x0c
    77b2:	8d 85       	ldd	r24, Y+13	; 0x0d
    77b4:	9e 85       	ldd	r25, Y+14	; 0x0e
    77b6:	20 e0       	ldi	r18, 0x00	; 0
    77b8:	30 e0       	ldi	r19, 0x00	; 0
    77ba:	40 e2       	ldi	r20, 0x20	; 32
    77bc:	51 e4       	ldi	r21, 0x41	; 65
    77be:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    77c2:	dc 01       	movw	r26, r24
    77c4:	cb 01       	movw	r24, r22
    77c6:	bc 01       	movw	r22, r24
    77c8:	cd 01       	movw	r24, r26
    77ca:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    77ce:	dc 01       	movw	r26, r24
    77d0:	cb 01       	movw	r24, r22
    77d2:	9e 83       	std	Y+6, r25	; 0x06
    77d4:	8d 83       	std	Y+5, r24	; 0x05
    77d6:	0f c0       	rjmp	.+30     	; 0x77f6 <main+0x6c4>
    77d8:	88 ec       	ldi	r24, 0xC8	; 200
    77da:	90 e0       	ldi	r25, 0x00	; 0
    77dc:	9c 83       	std	Y+4, r25	; 0x04
    77de:	8b 83       	std	Y+3, r24	; 0x03
    77e0:	8b 81       	ldd	r24, Y+3	; 0x03
    77e2:	9c 81       	ldd	r25, Y+4	; 0x04
    77e4:	01 97       	sbiw	r24, 0x01	; 1
    77e6:	f1 f7       	brne	.-4      	; 0x77e4 <main+0x6b2>
    77e8:	9c 83       	std	Y+4, r25	; 0x04
    77ea:	8b 83       	std	Y+3, r24	; 0x03
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    77ec:	8d 81       	ldd	r24, Y+5	; 0x05
    77ee:	9e 81       	ldd	r25, Y+6	; 0x06
    77f0:	01 97       	sbiw	r24, 0x01	; 1
    77f2:	9e 83       	std	Y+6, r25	; 0x06
    77f4:	8d 83       	std	Y+5, r24	; 0x05
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    77f6:	8d 81       	ldd	r24, Y+5	; 0x05
    77f8:	9e 81       	ldd	r25, Y+6	; 0x06
    77fa:	00 97       	sbiw	r24, 0x00	; 0
    77fc:	69 f7       	brne	.-38     	; 0x77d8 <main+0x6a6>
    77fe:	14 c0       	rjmp	.+40     	; 0x7828 <main+0x6f6>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    7800:	6f 81       	ldd	r22, Y+7	; 0x07
    7802:	78 85       	ldd	r23, Y+8	; 0x08
    7804:	89 85       	ldd	r24, Y+9	; 0x09
    7806:	9a 85       	ldd	r25, Y+10	; 0x0a
    7808:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    780c:	dc 01       	movw	r26, r24
    780e:	cb 01       	movw	r24, r22
    7810:	9e 83       	std	Y+6, r25	; 0x06
    7812:	8d 83       	std	Y+5, r24	; 0x05
    7814:	8d 81       	ldd	r24, Y+5	; 0x05
    7816:	9e 81       	ldd	r25, Y+6	; 0x06
    7818:	9a 83       	std	Y+2, r25	; 0x02
    781a:	89 83       	std	Y+1, r24	; 0x01
    781c:	89 81       	ldd	r24, Y+1	; 0x01
    781e:	9a 81       	ldd	r25, Y+2	; 0x02
    7820:	01 97       	sbiw	r24, 0x01	; 1
    7822:	f1 f7       	brne	.-4      	; 0x7820 <main+0x6ee>
    7824:	9a 83       	std	Y+2, r25	; 0x02
    7826:	89 83       	std	Y+1, r24	; 0x01
		//Warning
		LCD_Clear();
		LCD_WriteString("Peaple Ready");

		DIO_WritePin(PINB06,HIGH);
		for(i=5;i>=0;i--){
    7828:	80 91 13 01 	lds	r24, 0x0113
    782c:	81 50       	subi	r24, 0x01	; 1
    782e:	80 93 13 01 	sts	0x0113, r24
    7832:	80 91 13 01 	lds	r24, 0x0113
    7836:	88 23       	and	r24, r24
    7838:	0c f0       	brlt	.+2      	; 0x783c <main+0x70a>
    783a:	73 cf       	rjmp	.-282    	; 0x7722 <main+0x5f0>
			PORTC=seven[0];
			PORTD=seven[i];

			_delay_ms(900);
		}
		DIO_WritePin(PINB06,LOW);
    783c:	8e e0       	ldi	r24, 0x0E	; 14
    783e:	60 e0       	ldi	r22, 0x00	; 0
    7840:	0e 94 f9 09 	call	0x13f2	; 0x13f2 <DIO_WritePin>
    7844:	2a cd       	rjmp	.-1452   	; 0x729a <main+0x168>

00007846 <__vector_3>:



}

ISR(INT2_vect){
    7846:	1f 92       	push	r1
    7848:	0f 92       	push	r0
    784a:	0f b6       	in	r0, 0x3f	; 63
    784c:	0f 92       	push	r0
    784e:	11 24       	eor	r1, r1
    7850:	8f 93       	push	r24
    7852:	df 93       	push	r29
    7854:	cf 93       	push	r28
    7856:	cd b7       	in	r28, 0x3d	; 61
    7858:	de b7       	in	r29, 0x3e	; 62
	if(i>5 && flag==1){
    785a:	80 91 13 01 	lds	r24, 0x0113
    785e:	86 30       	cpi	r24, 0x06	; 6
    7860:	3c f0       	brlt	.+14     	; 0x7870 <__vector_3+0x2a>
    7862:	80 91 ac 05 	lds	r24, 0x05AC
    7866:	81 30       	cpi	r24, 0x01	; 1
    7868:	19 f4       	brne	.+6      	; 0x7870 <__vector_3+0x2a>
		i=6;
    786a:	86 e0       	ldi	r24, 0x06	; 6
    786c:	80 93 13 01 	sts	0x0113, r24

	}

}
    7870:	cf 91       	pop	r28
    7872:	df 91       	pop	r29
    7874:	8f 91       	pop	r24
    7876:	0f 90       	pop	r0
    7878:	0f be       	out	0x3f, r0	; 63
    787a:	0f 90       	pop	r0
    787c:	1f 90       	pop	r1
    787e:	18 95       	reti

00007880 <__mulsi3>:
    7880:	62 9f       	mul	r22, r18
    7882:	d0 01       	movw	r26, r0
    7884:	73 9f       	mul	r23, r19
    7886:	f0 01       	movw	r30, r0
    7888:	82 9f       	mul	r24, r18
    788a:	e0 0d       	add	r30, r0
    788c:	f1 1d       	adc	r31, r1
    788e:	64 9f       	mul	r22, r20
    7890:	e0 0d       	add	r30, r0
    7892:	f1 1d       	adc	r31, r1
    7894:	92 9f       	mul	r25, r18
    7896:	f0 0d       	add	r31, r0
    7898:	83 9f       	mul	r24, r19
    789a:	f0 0d       	add	r31, r0
    789c:	74 9f       	mul	r23, r20
    789e:	f0 0d       	add	r31, r0
    78a0:	65 9f       	mul	r22, r21
    78a2:	f0 0d       	add	r31, r0
    78a4:	99 27       	eor	r25, r25
    78a6:	72 9f       	mul	r23, r18
    78a8:	b0 0d       	add	r27, r0
    78aa:	e1 1d       	adc	r30, r1
    78ac:	f9 1f       	adc	r31, r25
    78ae:	63 9f       	mul	r22, r19
    78b0:	b0 0d       	add	r27, r0
    78b2:	e1 1d       	adc	r30, r1
    78b4:	f9 1f       	adc	r31, r25
    78b6:	bd 01       	movw	r22, r26
    78b8:	cf 01       	movw	r24, r30
    78ba:	11 24       	eor	r1, r1
    78bc:	08 95       	ret

000078be <__divmodqi4>:
    78be:	87 fb       	bst	r24, 7
    78c0:	08 2e       	mov	r0, r24
    78c2:	06 26       	eor	r0, r22
    78c4:	87 fd       	sbrc	r24, 7
    78c6:	81 95       	neg	r24
    78c8:	67 fd       	sbrc	r22, 7
    78ca:	61 95       	neg	r22
    78cc:	20 d0       	rcall	.+64     	; 0x790e <__udivmodqi4>
    78ce:	0e f4       	brtc	.+2      	; 0x78d2 <__divmodqi4_1>
    78d0:	91 95       	neg	r25

000078d2 <__divmodqi4_1>:
    78d2:	07 fc       	sbrc	r0, 7
    78d4:	81 95       	neg	r24

000078d6 <__divmodqi4_exit>:
    78d6:	08 95       	ret

000078d8 <__divmodsi4>:
    78d8:	97 fb       	bst	r25, 7
    78da:	09 2e       	mov	r0, r25
    78dc:	05 26       	eor	r0, r21
    78de:	0e d0       	rcall	.+28     	; 0x78fc <__divmodsi4_neg1>
    78e0:	57 fd       	sbrc	r21, 7
    78e2:	04 d0       	rcall	.+8      	; 0x78ec <__divmodsi4_neg2>
    78e4:	20 d0       	rcall	.+64     	; 0x7926 <__udivmodsi4>
    78e6:	0a d0       	rcall	.+20     	; 0x78fc <__divmodsi4_neg1>
    78e8:	00 1c       	adc	r0, r0
    78ea:	38 f4       	brcc	.+14     	; 0x78fa <__divmodsi4_exit>

000078ec <__divmodsi4_neg2>:
    78ec:	50 95       	com	r21
    78ee:	40 95       	com	r20
    78f0:	30 95       	com	r19
    78f2:	21 95       	neg	r18
    78f4:	3f 4f       	sbci	r19, 0xFF	; 255
    78f6:	4f 4f       	sbci	r20, 0xFF	; 255
    78f8:	5f 4f       	sbci	r21, 0xFF	; 255

000078fa <__divmodsi4_exit>:
    78fa:	08 95       	ret

000078fc <__divmodsi4_neg1>:
    78fc:	f6 f7       	brtc	.-4      	; 0x78fa <__divmodsi4_exit>
    78fe:	90 95       	com	r25
    7900:	80 95       	com	r24
    7902:	70 95       	com	r23
    7904:	61 95       	neg	r22
    7906:	7f 4f       	sbci	r23, 0xFF	; 255
    7908:	8f 4f       	sbci	r24, 0xFF	; 255
    790a:	9f 4f       	sbci	r25, 0xFF	; 255
    790c:	08 95       	ret

0000790e <__udivmodqi4>:
    790e:	99 1b       	sub	r25, r25
    7910:	79 e0       	ldi	r23, 0x09	; 9
    7912:	04 c0       	rjmp	.+8      	; 0x791c <__udivmodqi4_ep>

00007914 <__udivmodqi4_loop>:
    7914:	99 1f       	adc	r25, r25
    7916:	96 17       	cp	r25, r22
    7918:	08 f0       	brcs	.+2      	; 0x791c <__udivmodqi4_ep>
    791a:	96 1b       	sub	r25, r22

0000791c <__udivmodqi4_ep>:
    791c:	88 1f       	adc	r24, r24
    791e:	7a 95       	dec	r23
    7920:	c9 f7       	brne	.-14     	; 0x7914 <__udivmodqi4_loop>
    7922:	80 95       	com	r24
    7924:	08 95       	ret

00007926 <__udivmodsi4>:
    7926:	a1 e2       	ldi	r26, 0x21	; 33
    7928:	1a 2e       	mov	r1, r26
    792a:	aa 1b       	sub	r26, r26
    792c:	bb 1b       	sub	r27, r27
    792e:	fd 01       	movw	r30, r26
    7930:	0d c0       	rjmp	.+26     	; 0x794c <__udivmodsi4_ep>

00007932 <__udivmodsi4_loop>:
    7932:	aa 1f       	adc	r26, r26
    7934:	bb 1f       	adc	r27, r27
    7936:	ee 1f       	adc	r30, r30
    7938:	ff 1f       	adc	r31, r31
    793a:	a2 17       	cp	r26, r18
    793c:	b3 07       	cpc	r27, r19
    793e:	e4 07       	cpc	r30, r20
    7940:	f5 07       	cpc	r31, r21
    7942:	20 f0       	brcs	.+8      	; 0x794c <__udivmodsi4_ep>
    7944:	a2 1b       	sub	r26, r18
    7946:	b3 0b       	sbc	r27, r19
    7948:	e4 0b       	sbc	r30, r20
    794a:	f5 0b       	sbc	r31, r21

0000794c <__udivmodsi4_ep>:
    794c:	66 1f       	adc	r22, r22
    794e:	77 1f       	adc	r23, r23
    7950:	88 1f       	adc	r24, r24
    7952:	99 1f       	adc	r25, r25
    7954:	1a 94       	dec	r1
    7956:	69 f7       	brne	.-38     	; 0x7932 <__udivmodsi4_loop>
    7958:	60 95       	com	r22
    795a:	70 95       	com	r23
    795c:	80 95       	com	r24
    795e:	90 95       	com	r25
    7960:	9b 01       	movw	r18, r22
    7962:	ac 01       	movw	r20, r24
    7964:	bd 01       	movw	r22, r26
    7966:	cf 01       	movw	r24, r30
    7968:	08 95       	ret

0000796a <__prologue_saves__>:
    796a:	2f 92       	push	r2
    796c:	3f 92       	push	r3
    796e:	4f 92       	push	r4
    7970:	5f 92       	push	r5
    7972:	6f 92       	push	r6
    7974:	7f 92       	push	r7
    7976:	8f 92       	push	r8
    7978:	9f 92       	push	r9
    797a:	af 92       	push	r10
    797c:	bf 92       	push	r11
    797e:	cf 92       	push	r12
    7980:	df 92       	push	r13
    7982:	ef 92       	push	r14
    7984:	ff 92       	push	r15
    7986:	0f 93       	push	r16
    7988:	1f 93       	push	r17
    798a:	cf 93       	push	r28
    798c:	df 93       	push	r29
    798e:	cd b7       	in	r28, 0x3d	; 61
    7990:	de b7       	in	r29, 0x3e	; 62
    7992:	ca 1b       	sub	r28, r26
    7994:	db 0b       	sbc	r29, r27
    7996:	0f b6       	in	r0, 0x3f	; 63
    7998:	f8 94       	cli
    799a:	de bf       	out	0x3e, r29	; 62
    799c:	0f be       	out	0x3f, r0	; 63
    799e:	cd bf       	out	0x3d, r28	; 61
    79a0:	09 94       	ijmp

000079a2 <__epilogue_restores__>:
    79a2:	2a 88       	ldd	r2, Y+18	; 0x12
    79a4:	39 88       	ldd	r3, Y+17	; 0x11
    79a6:	48 88       	ldd	r4, Y+16	; 0x10
    79a8:	5f 84       	ldd	r5, Y+15	; 0x0f
    79aa:	6e 84       	ldd	r6, Y+14	; 0x0e
    79ac:	7d 84       	ldd	r7, Y+13	; 0x0d
    79ae:	8c 84       	ldd	r8, Y+12	; 0x0c
    79b0:	9b 84       	ldd	r9, Y+11	; 0x0b
    79b2:	aa 84       	ldd	r10, Y+10	; 0x0a
    79b4:	b9 84       	ldd	r11, Y+9	; 0x09
    79b6:	c8 84       	ldd	r12, Y+8	; 0x08
    79b8:	df 80       	ldd	r13, Y+7	; 0x07
    79ba:	ee 80       	ldd	r14, Y+6	; 0x06
    79bc:	fd 80       	ldd	r15, Y+5	; 0x05
    79be:	0c 81       	ldd	r16, Y+4	; 0x04
    79c0:	1b 81       	ldd	r17, Y+3	; 0x03
    79c2:	aa 81       	ldd	r26, Y+2	; 0x02
    79c4:	b9 81       	ldd	r27, Y+1	; 0x01
    79c6:	ce 0f       	add	r28, r30
    79c8:	d1 1d       	adc	r29, r1
    79ca:	0f b6       	in	r0, 0x3f	; 63
    79cc:	f8 94       	cli
    79ce:	de bf       	out	0x3e, r29	; 62
    79d0:	0f be       	out	0x3f, r0	; 63
    79d2:	cd bf       	out	0x3d, r28	; 61
    79d4:	ed 01       	movw	r28, r26
    79d6:	08 95       	ret

000079d8 <memcpy>:
    79d8:	fb 01       	movw	r30, r22
    79da:	dc 01       	movw	r26, r24
    79dc:	02 c0       	rjmp	.+4      	; 0x79e2 <memcpy+0xa>
    79de:	01 90       	ld	r0, Z+
    79e0:	0d 92       	st	X+, r0
    79e2:	41 50       	subi	r20, 0x01	; 1
    79e4:	50 40       	sbci	r21, 0x00	; 0
    79e6:	d8 f7       	brcc	.-10     	; 0x79de <memcpy+0x6>
    79e8:	08 95       	ret

000079ea <memset>:
    79ea:	dc 01       	movw	r26, r24
    79ec:	01 c0       	rjmp	.+2      	; 0x79f0 <memset+0x6>
    79ee:	6d 93       	st	X+, r22
    79f0:	41 50       	subi	r20, 0x01	; 1
    79f2:	50 40       	sbci	r21, 0x00	; 0
    79f4:	e0 f7       	brcc	.-8      	; 0x79ee <memset+0x4>
    79f6:	08 95       	ret

000079f8 <strlen>:
    79f8:	fc 01       	movw	r30, r24
    79fa:	01 90       	ld	r0, Z+
    79fc:	00 20       	and	r0, r0
    79fe:	e9 f7       	brne	.-6      	; 0x79fa <strlen+0x2>
    7a00:	80 95       	com	r24
    7a02:	90 95       	com	r25
    7a04:	8e 0f       	add	r24, r30
    7a06:	9f 1f       	adc	r25, r31
    7a08:	08 95       	ret

00007a0a <strncpy>:
    7a0a:	fb 01       	movw	r30, r22
    7a0c:	dc 01       	movw	r26, r24
    7a0e:	41 50       	subi	r20, 0x01	; 1
    7a10:	50 40       	sbci	r21, 0x00	; 0
    7a12:	48 f0       	brcs	.+18     	; 0x7a26 <strncpy+0x1c>
    7a14:	01 90       	ld	r0, Z+
    7a16:	0d 92       	st	X+, r0
    7a18:	00 20       	and	r0, r0
    7a1a:	c9 f7       	brne	.-14     	; 0x7a0e <strncpy+0x4>
    7a1c:	01 c0       	rjmp	.+2      	; 0x7a20 <strncpy+0x16>
    7a1e:	1d 92       	st	X+, r1
    7a20:	41 50       	subi	r20, 0x01	; 1
    7a22:	50 40       	sbci	r21, 0x00	; 0
    7a24:	e0 f7       	brcc	.-8      	; 0x7a1e <strncpy+0x14>
    7a26:	08 95       	ret

00007a28 <_exit>:
    7a28:	f8 94       	cli

00007a2a <__stop_program>:
    7a2a:	ff cf       	rjmp	.-2      	; 0x7a2a <__stop_program>
